[{"id":0,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"相关资源\r#\r\r  \rNo Starch Press\n  \rThe Pragmatic Bookshelf\n  \rManning\n  \rO\u0026rsquo;Reilly\n  \rLet Me Read\n  \rLibrary Genesis\n  \rSaltTiger 目前我主要在以下网站收集编程类电子书，大家去这上面找书就好，下载方法也一并给出：\n  \rCoderProg，点击验证码，跳转至Rapidgator或Turbobit网盘，将网盘链接复制到\r木薯牛网盘中转站（1G流量1.33元）进行中转，即可下载。\n  \rAvaxHome，跳转至icerbox网盘，将网盘链接复制到\r思飞网盘中转站（1G icerbox流量2.8元）进行中转，中转后自动转存到绑定的百度网盘，即可下载。\n  \rFox eBook，跳转至NitroFlare网盘，将网盘链接复制到\r木薯牛网盘中转站进行中转，即可下载。\n  \rLibrary Genesis，点击Mirrors链接直接下载。\n  \rLet Me Read，点击验证码，跳转DirectLink直接下载。\n    \rZlibrary\n  \rLeanpub\n  \rThe best Programming books\n  "},{"id":1,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"读书\r#\r\r 书籍是人类进步的阶梯\n  温故而知新,可以为师矣\n 《Java并发编程的艺术》\n 2021/10/9 P280 ~ P304 2021/10/30 finish  《操作系统导论》\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 finish  《Build On Your Lisp》\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 finish  《UNIX环境高级编程》\n 2021/10/22 CH11 2021/10/31 CH12 2021/11/10 2021/11/20 Ch16 2021/11/24 Finish  "},{"id":2,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  "},{"id":3,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":"Basic\r#\r\rQuick Sort\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } Binary Search\r#\r\r// 区间[l,r]划分成[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) { //check() 检查mid是否满足性质  r = mid; } else { l = mid + 1; } } } // 区间[l,r]划分成[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1\u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } "},{"id":4,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Java并发编程艺术","section":"C S","content":"11.2 定位问题\r#\r\r线上代码定位问题\n11.3 性能测试\r#\r\r相关的命令\n"},{"id":5,"href":"/docs/cs/leetcode/206/","title":"206th","section":"C S","content":"public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; } "},{"id":6,"href":"/docs/cs/leetcode/21/","title":"21st","section":"C S","content":"ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = \u0026amp;dummy; while (p1 \u0026amp;\u0026amp; p2) { if (p1-\u0026gt;val \u0026gt; p2-\u0026gt;val) { cur-\u0026gt;next = p2; p2 = p2-\u0026gt;next; } else { cur-\u0026gt;next = p1; p1 = p1-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = p1 ? p1 : p2; return dummy.next; "},{"id":7,"href":"/docs/cs/leetcode/273/","title":"273rd","section":"C S","content":"class Solution { private final String[] LESS_THAN_20 = {\u0026#34;\u0026#34;, \u0026#34;One\u0026#34;, \u0026#34;Two\u0026#34;, \u0026#34;Three\u0026#34;, \u0026#34;Four\u0026#34;, \u0026#34;Five\u0026#34;, \u0026#34;Six\u0026#34;, \u0026#34;Seven\u0026#34;, \u0026#34;Eight\u0026#34;, \u0026#34;Nine\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Eleven\u0026#34;, \u0026#34;Twelve\u0026#34;, \u0026#34;Thirteen\u0026#34;, \u0026#34;Fourteen\u0026#34;, \u0026#34;Fifteen\u0026#34;, \u0026#34;Sixteen\u0026#34;, \u0026#34;Seventeen\u0026#34;, \u0026#34;Eighteen\u0026#34;, \u0026#34;Nineteen\u0026#34;}; private final String[] TENS = {\u0026#34;\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Twenty\u0026#34;, \u0026#34;Thirty\u0026#34;, \u0026#34;Forty\u0026#34;, \u0026#34;Fifty\u0026#34;, \u0026#34;Sixty\u0026#34;, \u0026#34;Seventy\u0026#34;, \u0026#34;Eighty\u0026#34;, \u0026#34;Ninety\u0026#34;}; private final String[] THOUSANDS = {\u0026#34;\u0026#34;, \u0026#34;Thousand\u0026#34;, \u0026#34;Million\u0026#34;, \u0026#34;Billion\u0026#34;}; public String numberToWords(int num) { if (num == 0) return \u0026#34;Zero\u0026#34;; int i = 0; String words = \u0026#34;\u0026#34;; while (num \u0026gt; 0) { if (num % 1000 != 0) words = helper(num % 1000) +THOUSANDS[i] + \u0026#34; \u0026#34; + words; num /= 1000; i++; } return words.trim(); } private String helper(int num) { if (num == 0) return \u0026#34;\u0026#34;; else if (num \u0026lt; 20) return LESS_THAN_20[num] + \u0026#34; \u0026#34;; else if (num \u0026lt; 100) return TENS[num / 10] + \u0026#34; \u0026#34; + helper(num % 10); else return LESS_THAN_20[num / 100] + \u0026#34; Hundred \u0026#34; + helper(num % 100); } } "},{"id":8,"href":"/docs/cs/leetcode/29/","title":"29th","section":"C S","content":"long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a \u0026lt; 0) sign *= -1; if (b \u0026lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a \u0026gt;= b) { long count = 1; long c = b; while ((c \u0026lt;\u0026lt; 1) \u0026lt;= a) { c \u0026lt;\u0026lt;= 1; count \u0026lt;\u0026lt;= 1; } quotient += count; a -= c; } if (sign * quotient \u0026gt; INT_MAX) { return INT_MAX; } return quotient*sign; "},{"id":9,"href":"/docs/cs/leetcode/46/","title":"46th","section":"C S","content":"public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;bool\u0026gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, vector\u0026lt;int\u0026gt;\u0026amp; cur, vector\u0026lt;bool\u0026gt;\u0026amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } } "},{"id":10,"href":"/docs/cs/leetcode/542/","title":"542nd","section":"C S","content":" 看成图，0为起点\n vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; updateMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat) { int m = mat.size(), n = mat[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(m, vector\u0026lt;int\u0026gt;(n, -1)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (int i = 0 ; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!Q.empty()) { pair\u0026lt;int, int\u0026gt; node = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { pair\u0026lt;int, int\u0026gt; neighbor = {node.first + dx[i], node.second + dy[i]}; if (neighbor.first \u0026lt; 0 || neighbor.first \u0026gt;= m || neighbor.second \u0026lt; 0 || neighbor.second \u0026gt;= n || dist[neighbor.first][neighbor.second] != -1) continue; dist[neighbor.first][neighbor.second] = dist[node.first][node.second] + 1; Q.push(neighbor); } } return dist; } "},{"id":11,"href":"/docs/cs/leetcode/77/","title":"77th","section":"C S","content":"public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(ans, 1, k, n, new ArrayList\u0026lt;\u0026gt;()); return ans; } private void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans, int start, int k, int n, List\u0026lt;Integer\u0026gt; cur) { if (cur.size() == k) { ans.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = start; i \u0026lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } } "},{"id":12,"href":"/docs/cs/leetcode/784/","title":"784th","section":"C S","content":"public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List\u0026lt;String\u0026gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); } "},{"id":13,"href":"/docs/cs/leetcode/tips/","title":"Tips","section":"C S","content":"摩尔投票算法\r#\r\r/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */ "},{"id":14,"href":"/docs/cs/linux/gdb/","title":"G D B","section":"C S","content":"GCC\r#\r\r  -E 获取预处理后的文件内容\n  -V 将编译、链接过程打印\n  -g 用于GDB调试\n  ltrace 命令用来跟踪程序运行时调用的库函数\n -S 查看系统调用 -e trace=write 只看write系统调用  strace 查看系统调用的封装函数\nGDB\r#\r\rSegment Fault快速定位\n首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core  list start ctrl + x + a  "},{"id":15,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt xxd 查看文件二进制  输出当前用户是不是 root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  查看磁盘引导扇区 (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  统计所有 cpp 文件的行数\n find . | grep '\\.cpp$' | xargs cat | wc -l  统计命令行命令的频率\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  文件检索 - cat, more, less, head, tail, file, find\n  输入输出控制 - 重定向, 管道, tee, xargs\n  文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  正则表达式\n  系统监控 - jobs, ps, top, kill, free, demsg, lsof\n   如何比较两个文件是否完全相同?   diff or md5sum\n  如何列出一个C语言项目中所有被包含过的头文件?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n du -h -d 1 2\u0026gt;/dev/null | grep -v denied 磁盘分析\n\r配置linux\np@ssw0rd\n"},{"id":16,"href":"/docs/cs/linux/vim/","title":"Vim","section":"C S","content":" Vscode插件 Learn Vim  "},{"id":17,"href":"/docs/cs/linux/wsl/","title":"W S L","section":"C S","content":"\r为WSL2加图形化界面配置\n运行 startxfce4\n"},{"id":18,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"C S","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":19,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"C S","content":"Cargo\r#\r\r cargo new project-name  "},{"id":20,"href":"/docs/cs/resource/","title":"Resource","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \r📚 List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCS公开课程学习群课程推荐 \r克莱登大学CS(热心网友整理) \r🎓 Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos \r写在20年初的校招面试心得与自学CS经验及找工作分享 \rTeach Yourself Programming in Ten Years \rCS自学指南 \r从小白到BAT后端工程师的自学路线 \rA Self-Learning, Modern Computer Science Curriculum \r名校公开课程评价网  "},{"id":21,"href":"/docs/cs/tools/git/","title":"Git","section":"C S","content":"// 删除本地分支 git branch -d localBranchName\n// 删除远程分支 git push origin \u0026ndash;delete remoteBranchName\n修改github 日期\ngit commit\rgit cat-file -p HEAD \u0026gt; tmp.txt\r# at this point, edit the file to replace the timestamp\rgit hash-object -t commit -w tmp.txt\r#=\u0026gt; 2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rgit update-ref -m 'commit: foo' refs/heads/master \\\r2ee8fcc02658e23219143f5bcfe6f9a4615745f9\r取消跟踪,删除远程文件\ngit rm -r --cached .\rgit add .\rgit commit -m \u0026quot;update gitignore\u0026quot;\r配置全局信息\n \u0026ndash;local\n git config \u0026ndash;global user.name \u0026ldquo;myname\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;test@gmail.com\u0026rdquo;\n"},{"id":22,"href":"/docs/cs/tools/vscode/","title":"Vscode","section":"C S","content":"WSL相关\r#\r\rvscode server for wsl closed unexpectedly\nnetsh winsock reset重置网络 或移除wsl中的~/.vscode-server\n"},{"id":23,"href":"/docs/leetcode/","title":"Leet Code","section":"Docs","content":"目前分类目录\r#\r\r剑指 Offer\r#\r\r面试题 \r#\r\r国区周寨\r#\r\r  第273场\n \r5963. 反转两次的数字(E) \r5964. 执行所有后缀指令(M) \r5965. 相同元素的间隔之和(M)    第274场\n \r5967. 检查是否所有 A 都在 B 之前(E) \r5968. 银行中的激光束数量(M) \r5969. 摧毁小行星(M)    Dynamic Programming\r#\r\r \r122. 买卖股票的最佳时机 II(M) \r123. 买卖股票的最佳时机 III(H) \r309. 最佳买卖股票时机含冷冻期(M) \r714. Best Time to Buy and Sell Stock with Transaction Fee(M) \r118. Pascal\u0026rsquo;s Triangle(E) \r119. Pascal\u0026rsquo;s Triangle II(E) \r264. Ugly Number II(E) \r91. Decode Ways(M) \r120. Triangle(M) \r62. Unique Paths(M) \r63. Unique Paths II(M) \r64. Minimum Path Sum(M) \r509. Fibonacci Number(M) \r198. 打家劫舍(M) \r213. 打家劫舍 II(M)  Tree\r#\r\r \r559. Maximum Depth of N-ary Tree(E) \r700. Search in a Binary Search Tree(E) \r102. 二叉树的层序遍历(M)  Heap\r#\r\r \r1046. 最后一块石头的重量(E) \r347. 前 K 个高频元素(M) \r451. 根据字符出现频率排序(M)  Math\r#\r\r \r384. Shuffle an Array(E) \r519. Random Flip Matrix(M) \r1979. Find Greatest Common Divisor of Array(E) \r812. Largest Triangle Area(E)  DFS\r#\r\r \r139. Word Break(M)  Recursion\r#\r\r \r1492. The kth Factor of n(M)  BinarySearch\r#\r\rSorts\r#\r\r Quick Select  \r215. Kth Largest Element in an Array    Others\r#\r\r \r1005. Maximize Sum Of Array After K Negations(E) \r383. Ransom Note(E) \r748. Shortest Completing Word(E)  Design\r#\r\r \r355. 设计推特(M) \r146. LRU 缓存(M)  "},{"id":24,"href":"/docs/leetcode/design/146/","title":"146th","section":"Leet Code","content":" \rLink\n 使用java的双向链表LinkedList有坑啊，过不了。\nclass LRUCache { private int capacity; private DoubleList list; private Map\u0026lt;Integer, Node\u0026gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap\u0026lt;\u0026gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.get(key); node.val = value; list.remove(node); } else { node = new Node(value, key); if (map.size() == capacity) { // full  Node last = list.removeLast(); map.remove(last.key); } } list.addFirst(node); map.put(key, node); } } class DoubleList { Node head, tail; public DoubleList() { this.head = null; this.tail = null; } public void addFirst(Node node) { if (head == null) { this.head = node; this.tail = node; } else { node.prev = null; node.next = head; head.prev = node; head = node; } } public void remove(Node node) { if (node == head) { this.head = node.next; if (this.head != null) { this.head.prev = null; } } else if (node == tail) { this.tail = node.prev; if (this.tail != null) { this.tail.next = null; } } else { Node prev = node.prev; prev.next = node.next; prev.next.prev = prev; } } public Node removeLast() { Node res = this.tail; if (this.head == this.tail) { res = this.head; this.head = this.tail = null; } else { Node node = this.tail.prev; node.next = null; this.tail = node; } return res; } } class Node { int val; int key; Node prev; Node next; public Node(int val, int key) { this.val = val; this.key = key; } } "},{"id":25,"href":"/docs/leetcode/design/355/","title":"355th","section":"Leet Code","content":" \rLink\n class Twitter { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; follows; private Map\u0026lt;Integer, PriorityQueue\u0026lt;Integer\u0026gt;\u0026gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map\u0026lt;Integer, Integer\u0026gt; orders = new HashMap\u0026lt;\u0026gt;(); public Twitter() { follows = new HashMap\u0026lt;\u0026gt;(); tweets = new HashMap\u0026lt;\u0026gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue\u0026lt;Integer\u0026gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue\u0026lt;Integer\u0026gt;((a, b) -\u0026gt; b - a); tweets.put(userId, tmp); } int key = ai.incrementAndGet(); orders.put(key, tweetId); tmp.offer(key); } public List\u0026lt;Integer\u0026gt; getNewsFeed(int userId) { List\u0026lt;Integer\u0026gt; followees = follows.get(userId); PriorityQueue\u0026lt;Integer\u0026gt; tmp = new PriorityQueue\u0026lt;\u0026gt;(); if (followees != null) { for (int followeeId : followees) { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(followeeId); if (t != null) { updateTop10Data(t, tmp); } } } else { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(userId); if (t != null) { updateTop10Data(t, tmp); } } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (tmp.size() \u0026gt; 0) { res.add(0, orders.get(tmp.poll())); } return res; } private void updateTop10Data(PriorityQueue\u0026lt;Integer\u0026gt; data, PriorityQueue\u0026lt;Integer\u0026gt; res) { for (int d : data) { if (res.size() \u0026gt;= 10) { if (res.peek() \u0026lt; d) { res.poll(); res.offer(d); } } else { res.offer(d); } } } public void follow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); tmp.add(followerId); follows.put(followerId, tmp); } if (tmp.contains(followeeId)) { return; } tmp.add(followeeId); } public void unfollow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { return; } tmp.remove(new Integer(followeeId)); } } "},{"id":26,"href":"/docs/leetcode/dfs/139/","title":"139th","section":"Leet Code","content":" \rLink\n 遍历字符串，将其分成两部分left和right，判断是否都在wordList里。\n加上记忆化\npublic boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(wordDict); Map\u0026lt;String, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set\u0026lt;String\u0026gt; set, Map\u0026lt;String, Boolean\u0026gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i \u0026lt; n; i++) { String left = s.substring(0, i); String right = s.substring(i, n); if (set.contains(left) \u0026amp;\u0026amp; dfs(right, set, map)) { map.put(s, true); return true; } } map.put(s, false); return false; } 最佳实践：使用Trie\npublic class TreeNode { TreeNode[] children; boolean isWord; char value; TreeNode() { children = new TreeNode[26]; } } private TreeNode root = new TreeNode(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { TreeNode node = root; for (char c : word.toCharArray()) { if (node.children[c - \u0026#39;a\u0026#39;] == null) { node.children[c - \u0026#39;a\u0026#39;] = new TreeNode(); } node.children[c - \u0026#39;a\u0026#39;].value = c; node = node.children[c - \u0026#39;a\u0026#39;]; } node.isWord = true; } return dfs(s, 0); } private int[] memo = new int[301]; private boolean dfs(String s, int cur) { // s[cur:]  int n = s.length(); if (cur \u0026gt;= n) return true; if (memo[cur] == 1) return false; TreeNode node = root; for (int i = cur; i \u0026lt; n; i++) { TreeNode tmp = node.children[s.charAt(i) - \u0026#39;a\u0026#39;]; node = tmp; if (tmp != null) { if (tmp.isWord \u0026amp;\u0026amp; dfs(s, i + 1)) { return true; } } else { break; } } memo[cur] = 1; return false; } "},{"id":27,"href":"/docs/leetcode/dfs/5964/","title":"5964th","section":"Leet Code","content":" TODO: Link\n class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i \u0026lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i \u0026lt; len; i++) { if (checkAndRun(pos, s.charAt(i))) { res++; } else { break; } } return res; } private boolean checkAndRun(int[] pos, char c) { if (c == \u0026#39;U\u0026#39;) { if (pos[0] != 0) { pos[0]--; return true; } } else if (c == \u0026#39;R\u0026#39;) { if (pos[1] != (n - 1)) { pos[1]++; return true; } } else if (c == \u0026#39;L\u0026#39;) { if (pos[1] != 0) { pos[1]--; return true; } } else if (c == \u0026#39;D\u0026#39;) { if (pos[0] != (n - 1)) { pos[0]++; return true; } } return false; } } "},{"id":28,"href":"/docs/leetcode/dynamicprogramming/118/","title":"118th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i \u0026lt;= numRows; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= numRows; i++) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (int j = 1; j \u0026lt;= i; j++) { tmp.add(dp[i][j]); } ans.add(tmp); } return ans; } } "},{"id":29,"href":"/docs/leetcode/dynamicprogramming/119/","title":"119th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;Integer\u0026gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row \u0026lt;= rowIndex; row++) { for (int col = 1; col \u0026lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int col = 1; col \u0026lt;= rowIndex; col++) { ans.add(dp[rowIndex][col]); } return ans; } } 进阶优化空间：O(rowIndex)\nclass Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { vector\u0026lt;int\u0026gt; ans(rowIndex + 1, 1); for (int i = 0; i \u0026lt;= rowIndex; i++) { for (int j = i - 1; j \u0026gt;= 1; j--) { ans[j] = ans[j] + ans[j - 1]; } } return ans; } }; "},{"id":30,"href":"/docs/leetcode/dynamicprogramming/120/","title":"120th","section":"Leet Code","content":" \rLink\n DP 要从下往上找，否则不一定是全局最优\n2 3 4 6 5 1 4 1 8 3\nclass Solution { public int minimumTotal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j \u0026lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt;= i; j++) { dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); } } return dp[0][0]; } } "},{"id":31,"href":"/docs/leetcode/dynamicprogramming/122/","title":"122nd","section":"Leet Code","content":" \rLink\n 可以把数据看成折线图，则所有上升之和为解\npublic int maxProfit(int[] prices) { int res = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP\npublic int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润  int[] dp1 = new int[n]; // 第i天卖掉的最大利润  int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i \u0026lt; n; i++) { // 可以不买或卖  dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] + prices[i]); } return dp2[n - 1]; } "},{"id":32,"href":"/docs/leetcode/dynamicprogramming/123/","title":"123rd","section":"Leet Code","content":" \rLink\n public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: 持有第一股的最大利益  // dp[0][1]: 售出第一股的最大利益  // dp[0][2]: 持有第二股的最大利益  // dp[0][3]: 售出第二股的最大利益  int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i \u0026lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i - 1]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i - 1]); } return Math.max(dp[n][1], dp[n][3]); } "},{"id":33,"href":"/docs/leetcode/dynamicprogramming/198/","title":"198th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: 第一个房间抢  // dp[0][1]: 第一个房间不抢  int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } "},{"id":34,"href":"/docs/leetcode/dynamicprogramming/213/","title":"213th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j)  private int help(int[] nums, int i, int j) { // 0 : 抢  // 1 : 不抢  int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i \u0026lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[j - 1][0], dp[j - 1][1]); } } "},{"id":35,"href":"/docs/leetcode/dynamicprogramming/264/","title":"264th","section":"Leet Code","content":" \rLink\n 使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]\n[1] -\u0026gt; [2 3 5] -\u0026gt; [3 4 5 6 10] -\u0026gt; \u0026hellip;\nclass Solution { // Time Complexity: O(3N * lg3N)  // 每次产生 最小数的2、3、5倍数  public int nthUglyNumber(int n) { PriorityQueue\u0026lt;Long\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); q.add(1L); long top = -1L; for (int i = 0; i \u0026lt; n; i++) { top = q.peek(); while (!q.isEmpty() \u0026amp;\u0026amp; q.peek() == top) { q.poll(); } q.add(top * 2); q.add(top * 3); q.add(top * 5); } return (int)top; } } dp思想，对于任何丑数，它只能由某一个丑数x x2、x3、x*5里得到。\n定义三个指针i、j、k来定跟踪丑数的大小。\nnums X X X X X X idx2 ^\ridx3 ^\ridx5 ^\rclass Solution { // Time Complexity: O(n);  public int nthUglyNumber(int n) { int i = 0, j = 0, k = 0; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); res.add(1); for (int v = 0; v \u0026lt; n; v++) { int cur = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5)); res.add(cur); if (cur == res.get(i) * 2) i++; if (cur == res.get(j) * 3) j++; if (cur == res.get(k) * 5) k++; } return res.get(n - 1); } } "},{"id":36,"href":"/docs/leetcode/dynamicprogramming/309/","title":"309th","section":"Leet Code","content":" \rLink\n DP\npublic int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润  int[] dp1 = new int[n + 1]; // i天买入的最大利润  int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出)  dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入)  dp2[i] = Math.max(dp2[i - 1], dp1[i - 2] - prices[i - 1]); } return dp1[n]; } "},{"id":37,"href":"/docs/leetcode/dynamicprogramming/509/","title":"509th","section":"Leet Code","content":" \rLink\n public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i \u0026lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; } "},{"id":38,"href":"/docs/leetcode/dynamicprogramming/62/","title":"62nd","section":"Leet Code","content":" \rLink\n DP\ndp[i][j] 表示能到i行j列不同路径个数\n初始化第一行和和第一列为1\nclass Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j \u0026lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i \u0026lt;= m; i++) { for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+记忆化\nclass Solution { public int uniquePaths(int m, int n) { int[][] memo = new int[m][n]; return dfs(0, 0, m, n, memo); } private int dfs(int i, int j, int m, int n, int[][] memo) { if (i \u0026gt;= m || j \u0026gt;= n || i \u0026lt; 0 || j \u0026lt; 0) { return 0; } if (memo[i][j] != 0) { return memo[i][j]; } if (i == m - 1 \u0026amp;\u0026amp; j == n - 1) { return 1; } int res = dfs(i + 1, j, m, n, memo) + dfs(i, j + 1, m, n, memo); memo[i][j] = res; return res; } } "},{"id":39,"href":"/docs/leetcode/dynamicprogramming/63/","title":"63rd","section":"Leet Code","content":" \rLink\n 同\r62题题思路一样\n直接看DP解法，注意初始化，有障碍物时，就不能往后走了\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } "},{"id":40,"href":"/docs/leetcode/dynamicprogramming/64/","title":"64th","section":"Leet Code","content":" \rLink\n dp[i][j] 表示到i行j列最小总和 注意初始化\nclass Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int k = i; k \u0026gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j \u0026lt; n; j++) { for (int k = j; k \u0026gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } "},{"id":41,"href":"/docs/leetcode/dynamicprogramming/714/","title":"714th","section":"Leet Code","content":" \rLink\n 第i天买入的最大利润buy[i]\n卖出的最大利润sell[i]\n卖出的时候(完成了一笔交易)减去手续费\nclass Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } } "},{"id":42,"href":"/docs/leetcode/dynamicprogramming/91/","title":"91st","section":"Leet Code","content":" \rLink\n DFS搜索 + 记忆化 class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i \u0026gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i \u0026lt; n - 1 \u0026amp;\u0026amp; isValid(s.substring(i, i + 2))) { res += dfs(s, i + 2); } memo.put(s.substring(i), res); return res; } private boolean isValid(String s) { int val = Integer.valueOf(s); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } private boolean isValid(char c) { int t = c - \u0026#39;0\u0026#39;; return 1 \u0026lt;= t \u0026amp;\u0026amp; t \u0026lt;= 26; } } DP\n\rclass Solution { public int numDecodings(String s) { s = \u0026#34;#\u0026#34; + s; int n = s.length(); // dp[i] = s[0]..s[i]解码方式  int[] dp = new int[n]; dp[0] = 1; dp[1] = (s.charAt(1) == \u0026#39;0\u0026#39;) ? 0 : 1; for (int i = 2; i \u0026lt; n; i++) { if (!isValid(s.charAt(i)) \u0026amp;\u0026amp; !isValid(s.charAt(i - 1), s.charAt(i))) { return 0; } if (isValid(s.charAt(i))) { dp[i] = dp[i - 1]; } if (isValid(s.charAt(i - 1), s.charAt(i))) { dp[i] += dp[i - 2]; } } return dp[n - 1]; } private boolean isValid(char c) { return \u0026#39;1\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } private boolean isValid(char a, char b) { int val = (a - \u0026#39;0\u0026#39;) * 10 + (b - \u0026#39;0\u0026#39;); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } } "},{"id":43,"href":"/docs/leetcode/heap/1046/","title":"1046th","section":"Leet Code","content":" \rLink\n // Time Complexity: O(nlogn)  // Space Complexity: O(n)  public int lastStoneWeight(int[] stones) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() \u0026gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.poll(); } "},{"id":44,"href":"/docs/leetcode/heap/347/","title":"347th","section":"Leet Code","content":" \rLink\n public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() \u0026gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!pq.isEmpty()) { res[idx++] = pq.poll(); } return res; } "},{"id":45,"href":"/docs/leetcode/heap/451/","title":"451st","section":"Leet Code","content":" \rLink\n public String frequencySort(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue\u0026lt;Character\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i \u0026lt; n; i++) { sb.append(c); } } return sb.toString(); } "},{"id":46,"href":"/docs/leetcode/math/1979/","title":"1979th","section":"Leet Code","content":" \rLink\n public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a \u0026gt; b  private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); } "},{"id":47,"href":"/docs/leetcode/math/384/","title":"384th","section":"Leet Code","content":" \rLink\n 常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。\n第一轮：1/n\n第二轮：(n-1)/n * 1/(n-1)\n第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)\n…………\nprivate int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i \u0026lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; } "},{"id":48,"href":"/docs/leetcode/math/519/","title":"519th","section":"Leet Code","content":" \rLink\n class Solution { private int m; private int n; private int count; private Map\u0026lt;Integer, Integer\u0026gt; map; /** 转成一维数组 索引i 相当于=\u0026gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =\u0026gt; 5 =\u0026gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =\u0026gt; 6 =\u0026gt; 3 map[5] = 4 map[3] = map[4] = 5 ... ... */ public Solution(int m, int n) { this.m = m; this.n = n; this.count = 0; this.map = new HashMap\u0026lt;\u0026gt;(); } public int[] flip() { int k = (int)(Math.random() * (m * n - count)); int res = 0; if (map.get(k) == null) { res = k; } else { res = map.get(k); } int lastIdx = m * n - count - 1; if (map.get(lastIdx) != null) { map.put(k, map.get(lastIdx)); } else { map.put(k, lastIdx); } count++; return new int[]{res / n, res % n}; } public void reset() { map.clear(); count = 0; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(m, n); * int[] param_1 = obj.flip(); * obj.reset(); */ "},{"id":49,"href":"/docs/leetcode/math/812/","title":"812th","section":"Leet Code","content":" \rLink\n 看评论区都用线性代数，没学过线性代数的我，泪目了哭！\npublic double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i \u0026lt; points.length; i++) { for (int j = i + 1; j \u0026lt; points.length; j++) { for (int k = j + 1; k \u0026lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp \u0026gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b \u0026gt; c) || (a + c \u0026gt; b) || (b + c) \u0026gt; a; } // 果断找个公式，海伦公式  private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.sqrt(p * (p - a) * (p - b) * (p - c)); } private double length(int[] p1, int[] p2) { return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)); } "},{"id":50,"href":"/docs/leetcode/others/1005/","title":"1005th","section":"Leet Code","content":" \rLink\n 写的实在是太丑陋了, 太多边界条件不易写\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // 最小\u0026gt;0的数索引  for (int n : nums) { if (n \u0026lt; 0) i++; else break; } int j = i - 1; // 最大负数索引  int negCount = i; int idx = negCount - i; while (k \u0026gt; 0) { if (negCount \u0026gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i \u0026lt; nums.length \u0026amp;\u0026amp; nums[i] == 0) break; if ( i \u0026gt;= nums.length || (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt; nums[j])) { nums[j] = -nums[j]; } else { nums[i] = -nums[i]; } } k--; } int sum = 0; for (int n : nums) { sum += n; } return sum; } } 优先队列解法(最小堆)\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int n : nums) { q.add(n); } while (k \u0026gt; 0) { q.add(0 - q.poll()); k--; } int sum = 0; while (!q.isEmpty()) { sum += q.poll(); } return sum; } } "},{"id":51,"href":"/docs/leetcode/others/383/","title":"383rd","section":"Leet Code","content":" \rLink\n class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - \u0026#39;a\u0026#39;] \u0026lt;= 0) return false; count[c - \u0026#39;a\u0026#39;]--; } return true; } } "},{"id":52,"href":"/docs/leetcode/others/5963/","title":"5963rd","section":"Leet Code","content":" TODO: Link\n class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i) == \u0026#39;0\u0026#39;) { i--; } for ( ; i \u0026gt;= 0; i--) { sb.append(s.charAt(i)); } return sb.toString(); } } "},{"id":53,"href":"/docs/leetcode/others/5965/","title":"5965th","section":"Leet Code","content":" TODO: Link\n 稍微优化下还是超时，放弃\nclass Solution { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // if (i == begin) continue;  if (arr[begin] == arr[i]) { list.add(i); } } map.put(arr[begin], list); System.out.println(1); } else { System.out.println(2); } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } 超时\nclass Solution { public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (i == begin) continue; if (arr[begin] == arr[i]) { list.add(i); } } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } ``"},{"id":54,"href":"/docs/leetcode/others/5967/","title":"5967th","section":"Leet Code","content":" \rLink\n public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i \u0026lt; chs.length; i++) { if (chs[i] == \u0026#39;a\u0026#39;) { x = i; } else if (y == -1 \u0026amp;\u0026amp; chs[i] == \u0026#39;b\u0026#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x \u0026lt; y; } "},{"id":55,"href":"/docs/leetcode/others/5968/","title":"5968th","section":"Leet Code","content":" \rLink\n class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i \u0026lt; m - 1; i++) { if (!bank[i].contains(\u0026#34;1\u0026#34;)) { continue; } int t = calculate(bank, i); // 计算这一行符合的激光束数量  if (t \u0026gt; 0) { // update result  for (int j = 0; j \u0026lt; n; j++) { if (bank[i].charAt(j) == \u0026#39;1\u0026#39;) { res += t; } } } } return res; } private int calculate(String[] bank, int start) { int end = start; for (int i = end + 1; i \u0026lt; m; i++) { if (bank[i].contains(\u0026#34;1\u0026#34;)) { end = i; break; } } int result = 0; if (end != start) { for (int i = 0; i \u0026lt; n; i++) { if (bank[end].charAt(i) == \u0026#39;1\u0026#39;) { result++; } } } return result; } } "},{"id":56,"href":"/docs/leetcode/others/5969/","title":"5969th","section":"Leet Code","content":" [Link]\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t \u0026lt; a) { return false; } else { t += a; } } return true; } } "},{"id":57,"href":"/docs/leetcode/others/748/","title":"748th","section":"Leet Code","content":" \rLink\n public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = \u0026#34;\u0026#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) \u0026amp;\u0026amp; word.length() \u0026lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i \u0026lt; a1.length; i++) { if (a1[i] \u0026gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.toCharArray()) { if (Character.isLetter(c)) { c = Character.toUpperCase(c); tmp[c - \u0026#39;A\u0026#39;]++; } } return tmp; } "},{"id":58,"href":"/docs/leetcode/recursion/1492/","title":"1492nd","section":"Leet Code","content":" \rLink\n public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f \u0026gt;= n \u0026amp;\u0026amp; k \u0026gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); } "},{"id":59,"href":"/docs/leetcode/sorts/215/","title":"215th","section":"Leet Code","content":" \rLink\n 使用优先队列\n// Time Complexity: O(nlgn)  // Space Complexity: O(k)  public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int num : nums) { if (q.size() == k) { if (num \u0026gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); } "},{"id":60,"href":"/docs/leetcode/tree/102/","title":"102nd","section":"Leet Code","content":" \rLink\n 考虑当前层结束条件，即当前队列中的元素个数。\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); int count = q.size(); while (count \u0026gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; } "},{"id":61,"href":"/docs/leetcode/tree/559/","title":"559th","section":"Leet Code","content":" \rLink 一道简单的搜索\n public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i \u0026lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; } "},{"id":62,"href":"/docs/leetcode/tree/700/","title":"700th","section":"Leet Code","content":" \rLink\n 递归搜索\nclass Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val \u0026gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } } "},{"id":63,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/","title":"剑指 Offer","section":"Leet Code","content":" \r剑指 Offer 04. 二维数组中的查找(M) \r剑指 Offer 50. 第一个只出现一次的字符(E) \r剑指 Offer 32 - I. 从上到下打印二叉树(M) \r剑指 Offer 32 - II. 从上到下打印二叉树 II(E) \r剑指 Offer 32 - III. 从上到下打印二叉树 III(M) \r剑指 Offer 47. 礼物的最大价值(M) \r剑指 Offer 26. 树的子结构(M) \r剑指 Offer 18. 删除链表的节点(E) \r剑指 Offer 22. 链表中倒数第k个节点(E) \r剑指 Offer 48. 最长不含重复字符的子字符串(M) \r剑指 Offer 46. 把数字翻译成字符串(M) \r剑指 Offer 25. 合并两个排序的链表(M) \r剑指 Offer 57. 和为s的两个数字(E) \r剑指 Offer 21. 调整数组顺序使奇数位于偶数前面(E) \r剑指 Offer 58 - I. 翻转单词顺序(E) \r剑指 Offer 13. 机器人的运动范围(M) \r剑指 Offer 12. 矩阵中的路径(M) \r剑指 Offer 64. 求1+2+…+n(M) \r剑指 Offer 54. 二叉搜索树的第k大节点(M) \r剑指 Offer 55 - I. 二叉树的深度(E) \r剑指 Offer 55 - II. 平衡二叉树(E) \r剑指 Offer 68 - I. 二叉搜索树的最近公共祖先(E) \r剑指 Offer 68 - II. 二叉树的最近公共祖先(E) \r剑指 Offer 15. 二进制中1的个数(E)  "},{"id":64,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/","title":"4th","section":"剑指 Offer","content":" \rLink\n \r上图是从右上角，同理左下角\nclass Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] \u0026lt; target) { col++; } else { row--; } } return false; } } "},{"id":65,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/","title":"12th","section":"剑指 Offer","content":" \rLink\n public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || board[i][j] != word.charAt(idx)) { return false; } if (idx == word.length() - 1) { return true; } board[i][j] = \u0026#39;0\u0026#39;; boolean res = search(board, word, idx + 1, i + 1, j) || search(board, word, idx + 1, i - 1, j) || search(board, word, idx + 1, i, j + 1) || search(board, word, idx + 1, i, j - 1); board[i][j] = word.charAt(idx); return res; } 菜写法，超时\nclass Solution { private int m; private int n; private char[][] board; private String word; private boolean[][] visited; public boolean exist(char[][] board, String word) { this.m = board.length; this.n = board[0].length; this.visited = new boolean[m][n]; this.board = board; this.word = word; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dfs(sb, i, j)) return true; } } return false; } private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; private boolean dfs(StringBuilder cur, int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n) { return false; } if (visited[x][y]) { return false; } cur.append(board[x][y]); visited[x][y] = true; int cmp = cur.length() - word.length(); if (cmp == 0 \u0026amp;\u0026amp; word.equals(cur.toString())) { return true; } else if (cmp \u0026lt; 0) { for (int i = 0; i \u0026lt; 4; i++) { int tmpX = x + dirs[i][0]; int tmpY = y + dirs[i][1]; if (dfs(cur, tmpX, tmpY)) return true; } } visited[x][y] = false; cur.deleteCharAt(cur.length() - 1); return false; } } "},{"id":66,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/","title":"13th","section":"剑指 Offer","content":" \rLink\n 简单DFS\nclass Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x \u0026gt;= m || x \u0026lt; 0 || y \u0026gt;= n || y \u0026lt; 0) return 0; if (visited[x][y] || !isValid(x, y)) { return 0; } visited[x][y] = true; return 1 + dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1); } private boolean isValid(int x, int y) { int val = 0; while (x \u0026gt; 0) { val += (x % 10); x /= 10; } while (y \u0026gt; 0) { val += (y % 10); y /= 10; } return val \u0026lt;= k; } } "},{"id":67,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/","title":"15th","section":"剑指 Offer","content":" \rLink\n public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;\u0026gt;= 1; } return res; } "},{"id":68,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/","title":"18th","section":"剑指 Offer","content":" \rLink\n class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } } "},{"id":69,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/","title":"21st","section":"剑指 Offer","content":" \rLink\n public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i \u0026lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; } "},{"id":70,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/","title":"22nd","section":"剑指 Offer","content":" \rLink\n public ListNode getKthFromEnd(ListNode head, int k) { Stack\u0026lt;ListNode\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head); head = head.next; } if (k \u0026gt; s.size()) return null; ListNode res = null; while (k \u0026gt; 0) { k--; res = s.pop(); } return res; } "},{"id":71,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/","title":"25th","section":"剑指 Offer","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null \u0026amp;\u0026amp; cur2 != null) { if (cur1.val \u0026lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.next; } "},{"id":72,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/","title":"26th","section":"剑指 Offer","content":" \rLink\n class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) \u0026amp;\u0026amp; help(A.right, B.right); } } "},{"id":73,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/","title":"32 1","section":"剑指 Offer","content":" \rLink\n class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } } "},{"id":74,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/","title":"32 2","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null]  while (q.peek() != null) { TreeNode node; List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); } res.add(tmp); q.offer(null); } return res; } } "},{"id":75,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/","title":"32 3","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList\u0026lt;Integer\u0026gt; tmp = new LinkedList\u0026lt;\u0026gt;(); int n = res.size(); for (int i = q.size(); i \u0026gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } res.add(tmp); } return res; } } "},{"id":76,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/","title":"46th","section":"剑指 Offer","content":" \rLink\n DFS\npublic int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start \u0026gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - \u0026#39;0\u0026#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start \u0026lt; str.length() - 1) { // 06  if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - \u0026#39;0\u0026#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25; } 动态规划\npublic int translateNum(int num) { String str = String.valueOf(num); int n = str.length(); // 以i为结尾 不同翻译数  int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1]; int val = (str.charAt(i - 2) - \u0026#39;0\u0026#39;) * 10 + (str.charAt(i - 1) - \u0026#39;0\u0026#39;); if (10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25) { dp[i] = (dp[i - 2] + dp[i - 1]); } } return dp[n]; } "},{"id":77,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/","title":"47th","section":"剑指 Offer","content":" \rLink\n class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } } "},{"id":78,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/","title":"48th","section":"剑指 Offer","content":" \rLink\n 双指针\npublic int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (j \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; } "},{"id":79,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/","title":"50th","section":"剑指 Offer","content":" \rLink\n class Solution { public char firstUniqChar(String s) { Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - \u0026#39;a\u0026#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return \u0026#39; \u0026#39;; } } "},{"id":80,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/","title":"54th","section":"剑指 Offer","content":" \rLink\n DFS\nprivate int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack\npublic int kthLargest(TreeNode root, int k) { Queue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (q.size() \u0026lt; k) { q.offer(node.val); } else if (q.peek() \u0026lt; node.val) { q.poll(); q.offer(node.val); } if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } return q.peek(); } "},{"id":81,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/","title":"55 1","section":"剑指 Offer","content":" \rLink\n public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } "},{"id":82,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/","title":"55 2","section":"剑指 Offer","content":" \rLink\n public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) \u0026lt; 2 \u0026amp;\u0026amp; (isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; } "},{"id":83,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/","title":"57th","section":"剑指 Offer","content":" \rLink\n public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i \u0026lt; j) { if (nums[i] + nums[j] \u0026lt; target) { i++; } else if (nums[i] + nums[j] \u0026gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; } "},{"id":84,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/","title":"58th","section":"剑指 Offer","content":" \rLink\n public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i \u0026gt;= 0) { while(i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] != \u0026#39; \u0026#39;) i--; sb.append(s.substring(i + 1, j + 1) + \u0026#34; \u0026#34;); while (i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] == \u0026#39; \u0026#39;) i--; j = i; } return sb.toString().trim(); } "},{"id":85,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/","title":"64th","section":"剑指 Offer","content":" \rLink\n public int sumNums(int n) { boolean tmp = n \u0026gt; 1 \u0026amp;\u0026amp; (n += sumNums(n - 1)) \u0026gt; 0; return n; } "},{"id":86,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/","title":"68 1","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } } "},{"id":87,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/","title":"68 2","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left == null ? right : left; } 任意k个数的最近公共祖先\nprivate int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.val == p.val || node.val == q.val) { k--; } dfs(node.left, p, q); dfs(node.right, p, q); if (oldK == 2 \u0026amp;\u0026amp; k == 0 \u0026amp;\u0026amp; res == null) { res = node; } } "},{"id":88,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"面试题","section":"Leet Code","content":" \r面试题 08.05. 递归乘法(M)  "},{"id":89,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/","title":"805th","section":"面试题","content":" \rLink\n public int multiply(int A, int B) { if (B == 0) return 0; else if (B == 1) return A; else return A + multiply(A, B - 1); } "},{"id":90,"href":"/docs/cs/leetcode/994/","title":"LeetCode 994","section":"C S","content":" 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。  public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue\u0026lt;int[]\u0026gt; Q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count \u0026gt; 0 \u0026amp;\u0026amp; !Q.isEmpty()) { times++; int curSize = Q.size(); for (int j = 0; j \u0026lt; curSize; j ++) { int[] node = Q.poll(); for (int i = 0; i \u0026lt; 4; i++) { int[] neighbor = new int[]{node[0] + dir[i][0], node[1] + dir[i][1]}; if (neighbor[0] \u0026lt; 0 || neighbor[1] \u0026lt; 0 || neighbor[0] \u0026gt;= m || neighbor[1] \u0026gt;= n || grid[neighbor[0]][neighbor[1]] != 1) continue; grid[neighbor[0]][neighbor[1]] = 2; fresh_count--; Q.add(neighbor); } } } return fresh_count != 0 ? -1 : times; } "}]