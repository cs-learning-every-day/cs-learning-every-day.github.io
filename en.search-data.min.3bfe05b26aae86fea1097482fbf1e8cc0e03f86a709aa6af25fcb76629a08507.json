[{"id":0,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"ç›¸å…³èµ„æº\r#\r\r  \rNo Starch Press\n  \rThe Pragmatic Bookshelf\n  \rManning\n  \rO\u0026rsquo;Reilly\n  \rLet Me Read\n  \rLibrary Genesis\n  \rSaltTiger ç›®å‰æˆ‘ä¸»è¦åœ¨ä»¥ä¸‹ç½‘ç«™æ”¶é›†ç¼–ç¨‹ç±»ç”µå­ä¹¦ï¼Œå¤§å®¶å»è¿™ä¸Šé¢æ‰¾ä¹¦å°±å¥½ï¼Œä¸‹è½½æ–¹æ³•ä¹Ÿä¸€å¹¶ç»™å‡ºï¼š\n  \rCoderProgï¼Œç‚¹å‡»éªŒè¯ç ï¼Œè·³è½¬è‡³Rapidgatoræˆ–Turbobitç½‘ç›˜ï¼Œå°†ç½‘ç›˜é“¾æ¥å¤åˆ¶åˆ°\ræœ¨è–¯ç‰›ç½‘ç›˜ä¸­è½¬ç«™ï¼ˆ1Gæµé‡1.33å…ƒï¼‰è¿›è¡Œä¸­è½¬ï¼Œå³å¯ä¸‹è½½ã€‚\n  \rAvaxHomeï¼Œè·³è½¬è‡³icerboxç½‘ç›˜ï¼Œå°†ç½‘ç›˜é“¾æ¥å¤åˆ¶åˆ°\ræ€é£ç½‘ç›˜ä¸­è½¬ç«™ï¼ˆ1G icerboxæµé‡2.8å…ƒï¼‰è¿›è¡Œä¸­è½¬ï¼Œä¸­è½¬åè‡ªåŠ¨è½¬å­˜åˆ°ç»‘å®šçš„ç™¾åº¦ç½‘ç›˜ï¼Œå³å¯ä¸‹è½½ã€‚\n  \rFox eBookï¼Œè·³è½¬è‡³NitroFlareç½‘ç›˜ï¼Œå°†ç½‘ç›˜é“¾æ¥å¤åˆ¶åˆ°\ræœ¨è–¯ç‰›ç½‘ç›˜ä¸­è½¬ç«™è¿›è¡Œä¸­è½¬ï¼Œå³å¯ä¸‹è½½ã€‚\n  \rLibrary Genesisï¼Œç‚¹å‡»Mirrorsé“¾æ¥ç›´æ¥ä¸‹è½½ã€‚\n  \rLet Me Readï¼Œç‚¹å‡»éªŒè¯ç ï¼Œè·³è½¬DirectLinkç›´æ¥ä¸‹è½½ã€‚\n    \rZlibrary\n  \rLeanpub\n  \rThe best Programming books\n  "},{"id":1,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"è¯»ä¹¦\r#\r\r ä¹¦ç±æ˜¯äººç±»è¿›æ­¥çš„é˜¶æ¢¯\n  æ¸©æ•…è€ŒçŸ¥æ–°,å¯ä»¥ä¸ºå¸ˆçŸ£\n ã€ŠJavaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ã€‹\n 2021/10/9 P280 ~ P304 2021/10/30 finish  ã€Šæ“ä½œç³»ç»Ÿå¯¼è®ºã€‹\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40ã€41ã€42 2021/10/18 finish  ã€ŠBuild On Your Lispã€‹\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 finish  ã€ŠUNIXç¯å¢ƒé«˜çº§ç¼–ç¨‹ã€‹\n 2021/10/22 CH11 2021/10/31 CH12 2021/11/10 2021/11/20 Ch16 2021/11/24 Finish  "},{"id":2,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  "},{"id":3,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":"Basic\r#\r\rQuick Sort\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } Binary Search\r#\r\r// åŒºé—´[l,r]åˆ’åˆ†æˆ[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) { //check() æ£€æŸ¥midæ˜¯å¦æ»¡è¶³æ€§è´¨  r = mid; } else { l = mid + 1; } } } // åŒºé—´[l,r]åˆ’åˆ†æˆ[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1\u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } "},{"id":4,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Javaå¹¶å‘ç¼–ç¨‹è‰ºæœ¯","section":"C S","content":"11.2 å®šä½é—®é¢˜\r#\r\rçº¿ä¸Šä»£ç å®šä½é—®é¢˜\n11.3 æ€§èƒ½æµ‹è¯•\r#\r\rç›¸å…³çš„å‘½ä»¤\n"},{"id":5,"href":"/docs/cs/leetcode/206/","title":"206th","section":"C S","content":"public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; } "},{"id":6,"href":"/docs/cs/leetcode/21/","title":"21st","section":"C S","content":"ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = \u0026amp;dummy; while (p1 \u0026amp;\u0026amp; p2) { if (p1-\u0026gt;val \u0026gt; p2-\u0026gt;val) { cur-\u0026gt;next = p2; p2 = p2-\u0026gt;next; } else { cur-\u0026gt;next = p1; p1 = p1-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = p1 ? p1 : p2; return dummy.next; "},{"id":7,"href":"/docs/cs/leetcode/273/","title":"273rd","section":"C S","content":"class Solution { private final String[] LESS_THAN_20 = {\u0026#34;\u0026#34;, \u0026#34;One\u0026#34;, \u0026#34;Two\u0026#34;, \u0026#34;Three\u0026#34;, \u0026#34;Four\u0026#34;, \u0026#34;Five\u0026#34;, \u0026#34;Six\u0026#34;, \u0026#34;Seven\u0026#34;, \u0026#34;Eight\u0026#34;, \u0026#34;Nine\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Eleven\u0026#34;, \u0026#34;Twelve\u0026#34;, \u0026#34;Thirteen\u0026#34;, \u0026#34;Fourteen\u0026#34;, \u0026#34;Fifteen\u0026#34;, \u0026#34;Sixteen\u0026#34;, \u0026#34;Seventeen\u0026#34;, \u0026#34;Eighteen\u0026#34;, \u0026#34;Nineteen\u0026#34;}; private final String[] TENS = {\u0026#34;\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Twenty\u0026#34;, \u0026#34;Thirty\u0026#34;, \u0026#34;Forty\u0026#34;, \u0026#34;Fifty\u0026#34;, \u0026#34;Sixty\u0026#34;, \u0026#34;Seventy\u0026#34;, \u0026#34;Eighty\u0026#34;, \u0026#34;Ninety\u0026#34;}; private final String[] THOUSANDS = {\u0026#34;\u0026#34;, \u0026#34;Thousand\u0026#34;, \u0026#34;Million\u0026#34;, \u0026#34;Billion\u0026#34;}; public String numberToWords(int num) { if (num == 0) return \u0026#34;Zero\u0026#34;; int i = 0; String words = \u0026#34;\u0026#34;; while (num \u0026gt; 0) { if (num % 1000 != 0) words = helper(num % 1000) +THOUSANDS[i] + \u0026#34; \u0026#34; + words; num /= 1000; i++; } return words.trim(); } private String helper(int num) { if (num == 0) return \u0026#34;\u0026#34;; else if (num \u0026lt; 20) return LESS_THAN_20[num] + \u0026#34; \u0026#34;; else if (num \u0026lt; 100) return TENS[num / 10] + \u0026#34; \u0026#34; + helper(num % 10); else return LESS_THAN_20[num / 100] + \u0026#34; Hundred \u0026#34; + helper(num % 100); } } "},{"id":8,"href":"/docs/cs/leetcode/29/","title":"29th","section":"C S","content":"long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a \u0026lt; 0) sign *= -1; if (b \u0026lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a \u0026gt;= b) { long count = 1; long c = b; while ((c \u0026lt;\u0026lt; 1) \u0026lt;= a) { c \u0026lt;\u0026lt;= 1; count \u0026lt;\u0026lt;= 1; } quotient += count; a -= c; } if (sign * quotient \u0026gt; INT_MAX) { return INT_MAX; } return quotient*sign; "},{"id":9,"href":"/docs/cs/leetcode/46/","title":"46th","section":"C S","content":"public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;bool\u0026gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, vector\u0026lt;int\u0026gt;\u0026amp; cur, vector\u0026lt;bool\u0026gt;\u0026amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } } "},{"id":10,"href":"/docs/cs/leetcode/542/","title":"542nd","section":"C S","content":" çœ‹æˆå›¾ï¼Œ0ä¸ºèµ·ç‚¹\n vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; updateMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat) { int m = mat.size(), n = mat[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(m, vector\u0026lt;int\u0026gt;(n, -1)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (int i = 0 ; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!Q.empty()) { pair\u0026lt;int, int\u0026gt; node = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { pair\u0026lt;int, int\u0026gt; neighbor = {node.first + dx[i], node.second + dy[i]}; if (neighbor.first \u0026lt; 0 || neighbor.first \u0026gt;= m || neighbor.second \u0026lt; 0 || neighbor.second \u0026gt;= n || dist[neighbor.first][neighbor.second] != -1) continue; dist[neighbor.first][neighbor.second] = dist[node.first][node.second] + 1; Q.push(neighbor); } } return dist; } "},{"id":11,"href":"/docs/cs/leetcode/77/","title":"77th","section":"C S","content":"public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(ans, 1, k, n, new ArrayList\u0026lt;\u0026gt;()); return ans; } private void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans, int start, int k, int n, List\u0026lt;Integer\u0026gt; cur) { if (cur.size() == k) { ans.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = start; i \u0026lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } } "},{"id":12,"href":"/docs/cs/leetcode/784/","title":"784th","section":"C S","content":"public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List\u0026lt;String\u0026gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); } "},{"id":13,"href":"/docs/cs/leetcode/tips/","title":"Tips","section":"C S","content":"æ‘©å°”æŠ•ç¥¨ç®—æ³•\r#\r\r/* å¯¹äºnä¸ªå…ƒç´ ï¼Œè¶…è¿‡n/2çš„æ¬¡æ•°æœ€å¤šåªæœ‰ä¸€ä¸ªå…ƒç´ ã€‚åŒç†è¶…è¿‡n/3çš„æ¬¡æ•°æœ€å¤šåªæœ‰äºŒä¸ªå…ƒç´ ã€‚é€‰ä¸€ä¸ªcandidateï¼Œæ ‡è®°ä¸º1ï¼Œæ¯æ¬¡ä¸ä¸€æ ·æ ‡è®°å‡1ã€‚æ ‡è®°ä¸º0æ—¶ï¼Œå°†å½“å‰å…ƒç´ è®¾ä¸ºcandidateä¸”æ ‡è®°ä¸º1ã€‚(ç›¸å½“äºæ¶ˆé™¤ä¸ä¸€æ ·çš„å…ƒç´ )ï¼Œæœ€åéœ€è¦ç¡®å®šæ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚ */ "},{"id":14,"href":"/docs/cs/linux/gdb/","title":"G D B","section":"C S","content":"GCC\r#\r\r  -E è·å–é¢„å¤„ç†åçš„æ–‡ä»¶å†…å®¹\n  -V å°†ç¼–è¯‘ã€é“¾æ¥è¿‡ç¨‹æ‰“å°\n  -g ç”¨äºGDBè°ƒè¯•\n  ltrace å‘½ä»¤ç”¨æ¥è·Ÿè¸ªç¨‹åºè¿è¡Œæ—¶è°ƒç”¨çš„åº“å‡½æ•°\n -S æŸ¥çœ‹ç³»ç»Ÿè°ƒç”¨ -e trace=write åªçœ‹writeç³»ç»Ÿè°ƒç”¨  strace æŸ¥çœ‹ç³»ç»Ÿè°ƒç”¨çš„å°è£…å‡½æ•°\nGDB\r#\r\rSegment Faultå¿«é€Ÿå®šä½\né¦–å…ˆç”Ÿæˆcoreæ–‡ä»¶ ä½¿ç”¨ulimit -a æŸ¥çœ‹core file sizeä¸º0åˆ™æ˜¯ä¸ä¼šè¾“å‡º(æ”¹æˆä¸é™åˆ¶ ulimit -c unlimited) è¿è¡Œç¨‹åºå‡ºé”™åˆ™ä¼šè¾“å‡ºï¼Œè°ƒè¯•æ—¶gdb ./hello core  list start ctrl + x + a  "},{"id":15,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace è·Ÿè¸ªç³»ç»Ÿè°ƒç”¨ stat æ‰“å°æ–‡ä»¶ä¿¡æ¯ mount æŸ¥çœ‹æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿ grep telnet /etc/services åŒ…å«äº†ä¸€äº›ç†ŸçŸ¥çš„ç«¯å£å· ldd proc åˆ—å‡ºç¨‹åºçš„åŠ¨æ€ä¾èµ–æ€§ ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt xxd æŸ¥çœ‹æ–‡ä»¶äºŒè¿›åˆ¶  è¾“å‡ºå½“å‰ç”¨æˆ·æ˜¯ä¸æ˜¯ root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  æŸ¥çœ‹ç£ç›˜å¼•å¯¼æ‰‡åŒº (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  ç»Ÿè®¡æ‰€æœ‰ cpp æ–‡ä»¶çš„è¡Œæ•°\n find . | grep '\\.cpp$' | xargs cat | wc -l  ç»Ÿè®¡å‘½ä»¤è¡Œå‘½ä»¤çš„é¢‘ç‡\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  æ–‡ä»¶ç®¡ç† - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  æ–‡ä»¶æ£€ç´¢ - cat, more, less, head, tail, file, find\n  è¾“å…¥è¾“å‡ºæ§åˆ¶ - é‡å®šå‘, ç®¡é“, tee, xargs\n  æ–‡æœ¬å¤„ç† - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  æ­£åˆ™è¡¨è¾¾å¼\n  ç³»ç»Ÿç›‘æ§ - jobs, ps, top, kill, free, demsg, lsof\n   å¦‚ä½•æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶æ˜¯å¦å®Œå…¨ç›¸åŒ?   diff or md5sum\n  å¦‚ä½•åˆ—å‡ºä¸€ä¸ªCè¯­è¨€é¡¹ç›®ä¸­æ‰€æœ‰è¢«åŒ…å«è¿‡çš„å¤´æ–‡ä»¶?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n du -h -d 1 2\u0026gt;/dev/null | grep -v denied ç£ç›˜åˆ†æ\n\ré…ç½®linux\np@ssw0rd\n"},{"id":16,"href":"/docs/cs/linux/vim/","title":"Vim","section":"C S","content":" Vscodeæ’ä»¶ Learn Vim  "},{"id":17,"href":"/docs/cs/linux/wsl/","title":"W S L","section":"C S","content":"\rä¸ºWSL2åŠ å›¾å½¢åŒ–ç•Œé¢é…ç½®\nè¿è¡Œ startxfce4\n"},{"id":18,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"C S","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":19,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"C S","content":"Cargo\r#\r\r cargo new project-name  "},{"id":20,"href":"/docs/cs/resource/","title":"Resource","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \rğŸ“š List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCSå…¬å¼€è¯¾ç¨‹å­¦ä¹ ç¾¤è¯¾ç¨‹æ¨è \rå…‹è±ç™»å¤§å­¦CS(çƒ­å¿ƒç½‘å‹æ•´ç†) \rğŸ“ Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos \rå†™åœ¨20å¹´åˆçš„æ ¡æ‹›é¢è¯•å¿ƒå¾—ä¸è‡ªå­¦CSç»éªŒåŠæ‰¾å·¥ä½œåˆ†äº« \rTeach Yourself Programming in Ten Years \rCSè‡ªå­¦æŒ‡å— \rä»å°ç™½åˆ°BATåç«¯å·¥ç¨‹å¸ˆçš„è‡ªå­¦è·¯çº¿ \rA Self-Learning, Modern Computer Science Curriculum \råæ ¡å…¬å¼€è¯¾ç¨‹è¯„ä»·ç½‘  "},{"id":21,"href":"/docs/cs/tools/git/","title":"Git","section":"C S","content":"// åˆ é™¤æœ¬åœ°åˆ†æ”¯ git branch -d localBranchName\n// åˆ é™¤è¿œç¨‹åˆ†æ”¯ git push origin \u0026ndash;delete remoteBranchName\nä¿®æ”¹github æ—¥æœŸ\ngit commit\rgit cat-file -p HEAD \u0026gt; tmp.txt\r# at this point, edit the file to replace the timestamp\rgit hash-object -t commit -w tmp.txt\r#=\u0026gt; 2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rgit update-ref -m 'commit: foo' refs/heads/master \\\r2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rå–æ¶ˆè·Ÿè¸ª,åˆ é™¤è¿œç¨‹æ–‡ä»¶\ngit rm -r --cached .\rgit add .\rgit commit -m \u0026quot;update gitignore\u0026quot;\ré…ç½®å…¨å±€ä¿¡æ¯\n \u0026ndash;local\n git config \u0026ndash;global user.name \u0026ldquo;myname\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;test@gmail.com\u0026rdquo;\n"},{"id":22,"href":"/docs/cs/tools/vscode/","title":"Vscode","section":"C S","content":"WSLç›¸å…³\r#\r\rvscode server for wsl closed unexpectedly\nnetsh winsock reseté‡ç½®ç½‘ç»œ æˆ–ç§»é™¤wslä¸­çš„~/.vscode-server\n"},{"id":23,"href":"/docs/leetcode/","title":"Leet Code","section":"Docs","content":"ç›®å‰åˆ†ç±»ç›®å½•\r#\r\rå‰‘æŒ‡ Offer\r#\r\ré¢è¯•é¢˜ \r#\r\rå›½åŒºå‘¨å¯¨\r#\r\r  ç¬¬273åœº\n \r5963. åè½¬ä¸¤æ¬¡çš„æ•°å­—(E) \r5964. æ‰§è¡Œæ‰€æœ‰åç¼€æŒ‡ä»¤(M) \r5965. ç›¸åŒå…ƒç´ çš„é—´éš”ä¹‹å’Œ(M)    ç¬¬274åœº\n \r5967. æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ A éƒ½åœ¨ B ä¹‹å‰(E) \r5968. é“¶è¡Œä¸­çš„æ¿€å…‰æŸæ•°é‡(M) \r5969. æ‘§æ¯å°è¡Œæ˜Ÿ(M)    Dynamic Programming\r#\r\r \r122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II(M) \r123. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III(H) \r309. æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ(M) \r714. Best Time to Buy and Sell Stock with Transaction Fee(M) \r118. Pascal\u0026rsquo;s Triangle(E) \r119. Pascal\u0026rsquo;s Triangle II(E) \r264. Ugly Number II(E) \r91. Decode Ways(M) \r120. Triangle(M) \r62. Unique Paths(M) \r63. Unique Paths II(M) \r64. Minimum Path Sum(M) \r509. Fibonacci Number(M) \r198. æ‰“å®¶åŠ«èˆ(M) \r213. æ‰“å®¶åŠ«èˆ II(M)  Tree\r#\r\r \r559. Maximum Depth of N-ary Tree(E) \r700. Search in a Binary Search Tree(E) \r102. äºŒå‰æ ‘çš„å±‚åºéå†(M)  Heap\r#\r\r \r1046. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡(E) \r347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ (M) \r451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº(M)  Math\r#\r\r \r384. Shuffle an Array(E) \r519. Random Flip Matrix(M) \r1979. Find Greatest Common Divisor of Array(E) \r812. Largest Triangle Area(E)  DFS\r#\r\r \r139. Word Break(M)  Recursion\r#\r\r \r1492. The kth Factor of n(M)  BinarySearch\r#\r\rSorts\r#\r\r Quick Select  \r215. Kth Largest Element in an Array    Others\r#\r\r \r1005. Maximize Sum Of Array After K Negations(E) \r383. Ransom Note(E) \r748. Shortest Completing Word(E)  Design\r#\r\r \r355. è®¾è®¡æ¨ç‰¹(M) \r146. LRU ç¼“å­˜(M)  "},{"id":24,"href":"/docs/leetcode/design/146/","title":"146th","section":"Leet Code","content":" \rLink\n ä½¿ç”¨javaçš„åŒå‘é“¾è¡¨LinkedListæœ‰å‘å•Šï¼Œè¿‡ä¸äº†ã€‚\nclass LRUCache { private int capacity; private DoubleList list; private Map\u0026lt;Integer, Node\u0026gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap\u0026lt;\u0026gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.get(key); node.val = value; list.remove(node); } else { node = new Node(value, key); if (map.size() == capacity) { // full  Node last = list.removeLast(); map.remove(last.key); } } list.addFirst(node); map.put(key, node); } } class DoubleList { Node head, tail; public DoubleList() { this.head = null; this.tail = null; } public void addFirst(Node node) { if (head == null) { this.head = node; this.tail = node; } else { node.prev = null; node.next = head; head.prev = node; head = node; } } public void remove(Node node) { if (node == head) { this.head = node.next; if (this.head != null) { this.head.prev = null; } } else if (node == tail) { this.tail = node.prev; if (this.tail != null) { this.tail.next = null; } } else { Node prev = node.prev; prev.next = node.next; prev.next.prev = prev; } } public Node removeLast() { Node res = this.tail; if (this.head == this.tail) { res = this.head; this.head = this.tail = null; } else { Node node = this.tail.prev; node.next = null; this.tail = node; } return res; } } class Node { int val; int key; Node prev; Node next; public Node(int val, int key) { this.val = val; this.key = key; } } "},{"id":25,"href":"/docs/leetcode/design/355/","title":"355th","section":"Leet Code","content":" \rLink\n class Twitter { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; follows; private Map\u0026lt;Integer, PriorityQueue\u0026lt;Integer\u0026gt;\u0026gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map\u0026lt;Integer, Integer\u0026gt; orders = new HashMap\u0026lt;\u0026gt;(); public Twitter() { follows = new HashMap\u0026lt;\u0026gt;(); tweets = new HashMap\u0026lt;\u0026gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue\u0026lt;Integer\u0026gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue\u0026lt;Integer\u0026gt;((a, b) -\u0026gt; b - a); tweets.put(userId, tmp); } int key = ai.incrementAndGet(); orders.put(key, tweetId); tmp.offer(key); } public List\u0026lt;Integer\u0026gt; getNewsFeed(int userId) { List\u0026lt;Integer\u0026gt; followees = follows.get(userId); PriorityQueue\u0026lt;Integer\u0026gt; tmp = new PriorityQueue\u0026lt;\u0026gt;(); if (followees != null) { for (int followeeId : followees) { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(followeeId); if (t != null) { updateTop10Data(t, tmp); } } } else { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(userId); if (t != null) { updateTop10Data(t, tmp); } } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (tmp.size() \u0026gt; 0) { res.add(0, orders.get(tmp.poll())); } return res; } private void updateTop10Data(PriorityQueue\u0026lt;Integer\u0026gt; data, PriorityQueue\u0026lt;Integer\u0026gt; res) { for (int d : data) { if (res.size() \u0026gt;= 10) { if (res.peek() \u0026lt; d) { res.poll(); res.offer(d); } } else { res.offer(d); } } } public void follow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); tmp.add(followerId); follows.put(followerId, tmp); } if (tmp.contains(followeeId)) { return; } tmp.add(followeeId); } public void unfollow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { return; } tmp.remove(new Integer(followeeId)); } } "},{"id":26,"href":"/docs/leetcode/dfs/139/","title":"139th","section":"Leet Code","content":" \rLink\n éå†å­—ç¬¦ä¸²ï¼Œå°†å…¶åˆ†æˆä¸¤éƒ¨åˆ†leftå’Œrightï¼Œåˆ¤æ–­æ˜¯å¦éƒ½åœ¨wordListé‡Œã€‚\nåŠ ä¸Šè®°å¿†åŒ–\npublic boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(wordDict); Map\u0026lt;String, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set\u0026lt;String\u0026gt; set, Map\u0026lt;String, Boolean\u0026gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i \u0026lt; n; i++) { String left = s.substring(0, i); String right = s.substring(i, n); if (set.contains(left) \u0026amp;\u0026amp; dfs(right, set, map)) { map.put(s, true); return true; } } map.put(s, false); return false; } æœ€ä½³å®è·µï¼šä½¿ç”¨Trie\npublic class TreeNode { TreeNode[] children; boolean isWord; char value; TreeNode() { children = new TreeNode[26]; } } private TreeNode root = new TreeNode(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { TreeNode node = root; for (char c : word.toCharArray()) { if (node.children[c - \u0026#39;a\u0026#39;] == null) { node.children[c - \u0026#39;a\u0026#39;] = new TreeNode(); } node.children[c - \u0026#39;a\u0026#39;].value = c; node = node.children[c - \u0026#39;a\u0026#39;]; } node.isWord = true; } return dfs(s, 0); } private int[] memo = new int[301]; private boolean dfs(String s, int cur) { // s[cur:]  int n = s.length(); if (cur \u0026gt;= n) return true; if (memo[cur] == 1) return false; TreeNode node = root; for (int i = cur; i \u0026lt; n; i++) { TreeNode tmp = node.children[s.charAt(i) - \u0026#39;a\u0026#39;]; node = tmp; if (tmp != null) { if (tmp.isWord \u0026amp;\u0026amp; dfs(s, i + 1)) { return true; } } else { break; } } memo[cur] = 1; return false; } "},{"id":27,"href":"/docs/leetcode/dfs/5964/","title":"5964th","section":"Leet Code","content":" TODO: Link\n class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i \u0026lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i \u0026lt; len; i++) { if (checkAndRun(pos, s.charAt(i))) { res++; } else { break; } } return res; } private boolean checkAndRun(int[] pos, char c) { if (c == \u0026#39;U\u0026#39;) { if (pos[0] != 0) { pos[0]--; return true; } } else if (c == \u0026#39;R\u0026#39;) { if (pos[1] != (n - 1)) { pos[1]++; return true; } } else if (c == \u0026#39;L\u0026#39;) { if (pos[1] != 0) { pos[1]--; return true; } } else if (c == \u0026#39;D\u0026#39;) { if (pos[0] != (n - 1)) { pos[0]++; return true; } } return false; } } "},{"id":28,"href":"/docs/leetcode/dynamicprogramming/118/","title":"118th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i \u0026lt;= numRows; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= numRows; i++) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (int j = 1; j \u0026lt;= i; j++) { tmp.add(dp[i][j]); } ans.add(tmp); } return ans; } } "},{"id":29,"href":"/docs/leetcode/dynamicprogramming/119/","title":"119th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;Integer\u0026gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row \u0026lt;= rowIndex; row++) { for (int col = 1; col \u0026lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int col = 1; col \u0026lt;= rowIndex; col++) { ans.add(dp[rowIndex][col]); } return ans; } } è¿›é˜¶ä¼˜åŒ–ç©ºé—´ï¼šO(rowIndex)\nclass Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { vector\u0026lt;int\u0026gt; ans(rowIndex + 1, 1); for (int i = 0; i \u0026lt;= rowIndex; i++) { for (int j = i - 1; j \u0026gt;= 1; j--) { ans[j] = ans[j] + ans[j - 1]; } } return ans; } }; "},{"id":30,"href":"/docs/leetcode/dynamicprogramming/120/","title":"120th","section":"Leet Code","content":" \rLink\n DP è¦ä»ä¸‹å¾€ä¸Šæ‰¾ï¼Œå¦åˆ™ä¸ä¸€å®šæ˜¯å…¨å±€æœ€ä¼˜\n2 3 4 6 5 1 4 1 8 3\nclass Solution { public int minimumTotal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j \u0026lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt;= i; j++) { dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); } } return dp[0][0]; } } "},{"id":31,"href":"/docs/leetcode/dynamicprogramming/122/","title":"122nd","section":"Leet Code","content":" \rLink\n å¯ä»¥æŠŠæ•°æ®çœ‹æˆæŠ˜çº¿å›¾ï¼Œåˆ™æ‰€æœ‰ä¸Šå‡ä¹‹å’Œä¸ºè§£\npublic int maxProfit(int[] prices) { int res = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP\npublic int maxProfit(int[] prices) { int n = prices.length; // ç¬¬iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦  int[] dp1 = new int[n]; // ç¬¬iå¤©å–æ‰çš„æœ€å¤§åˆ©æ¶¦  int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i \u0026lt; n; i++) { // å¯ä»¥ä¸ä¹°æˆ–å–  dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] + prices[i]); } return dp2[n - 1]; } "},{"id":32,"href":"/docs/leetcode/dynamicprogramming/123/","title":"123rd","section":"Leet Code","content":" \rLink\n public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: æŒæœ‰ç¬¬ä¸€è‚¡çš„æœ€å¤§åˆ©ç›Š  // dp[0][1]: å”®å‡ºç¬¬ä¸€è‚¡çš„æœ€å¤§åˆ©ç›Š  // dp[0][2]: æŒæœ‰ç¬¬äºŒè‚¡çš„æœ€å¤§åˆ©ç›Š  // dp[0][3]: å”®å‡ºç¬¬äºŒè‚¡çš„æœ€å¤§åˆ©ç›Š  int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i \u0026lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i - 1]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i - 1]); } return Math.max(dp[n][1], dp[n][3]); } "},{"id":33,"href":"/docs/leetcode/dynamicprogramming/198/","title":"198th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: ç¬¬ä¸€ä¸ªæˆ¿é—´æŠ¢  // dp[0][1]: ç¬¬ä¸€ä¸ªæˆ¿é—´ä¸æŠ¢  int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } "},{"id":34,"href":"/docs/leetcode/dynamicprogramming/213/","title":"213th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j)  private int help(int[] nums, int i, int j) { // 0 : æŠ¢  // 1 : ä¸æŠ¢  int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i \u0026lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[j - 1][0], dp[j - 1][1]); } } "},{"id":35,"href":"/docs/leetcode/dynamicprogramming/264/","title":"264th","section":"Leet Code","content":" \rLink\n ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼Œä»é›†åˆ[1]å¼€å§‹ï¼Œæ¯æ¬¡é€‰å–é›†åˆå†…æœ€å°çš„å…ƒç´ x ç”Ÿæˆ[2x, 3x, 5x]\n[1] -\u0026gt; [2 3 5] -\u0026gt; [3 4 5 6 10] -\u0026gt; \u0026hellip;\nclass Solution { // Time Complexity: O(3N * lg3N)  // æ¯æ¬¡äº§ç”Ÿ æœ€å°æ•°çš„2ã€3ã€5å€æ•°  public int nthUglyNumber(int n) { PriorityQueue\u0026lt;Long\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); q.add(1L); long top = -1L; for (int i = 0; i \u0026lt; n; i++) { top = q.peek(); while (!q.isEmpty() \u0026amp;\u0026amp; q.peek() == top) { q.poll(); } q.add(top * 2); q.add(top * 3); q.add(top * 5); } return (int)top; } } dpæ€æƒ³ï¼Œå¯¹äºä»»ä½•ä¸‘æ•°ï¼Œå®ƒåªèƒ½ç”±æŸä¸€ä¸ªä¸‘æ•°x x2ã€x3ã€x*5é‡Œå¾—åˆ°ã€‚\nå®šä¹‰ä¸‰ä¸ªæŒ‡é’ˆiã€jã€kæ¥å®šè·Ÿè¸ªä¸‘æ•°çš„å¤§å°ã€‚\nnums X X X X X X idx2 ^\ridx3 ^\ridx5 ^\rclass Solution { // Time Complexity: O(n);  public int nthUglyNumber(int n) { int i = 0, j = 0, k = 0; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); res.add(1); for (int v = 0; v \u0026lt; n; v++) { int cur = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5)); res.add(cur); if (cur == res.get(i) * 2) i++; if (cur == res.get(j) * 3) j++; if (cur == res.get(k) * 5) k++; } return res.get(n - 1); } } "},{"id":36,"href":"/docs/leetcode/dynamicprogramming/309/","title":"309th","section":"Leet Code","content":" \rLink\n DP\npublic int maxProfit(int[] prices) { int n = prices.length; // iå¤©å–å‡ºçš„æœ€å¤§åˆ©æ¶¦  int[] dp1 = new int[n + 1]; // iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦  int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { // ç¬¬iå¤©å–å‡ºçš„æœ€å¤§åˆ©æ¶¦ = max(å‰å¤©ä¹°å…¥ä»Šå¤©å–å‡º, å‰å¤©å–å‡º)  dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // ç¬¬iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦ = max(å‰å¤©ä¹°å…¥, å‰ä¸¤å¤©å–å‡ºä»Šå¤©ä¹°å…¥)  dp2[i] = Math.max(dp2[i - 1], dp1[i - 2] - prices[i - 1]); } return dp1[n]; } "},{"id":37,"href":"/docs/leetcode/dynamicprogramming/509/","title":"509th","section":"Leet Code","content":" \rLink\n public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i \u0026lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; } "},{"id":38,"href":"/docs/leetcode/dynamicprogramming/62/","title":"62nd","section":"Leet Code","content":" \rLink\n DP\ndp[i][j] è¡¨ç¤ºèƒ½åˆ°iè¡Œjåˆ—ä¸åŒè·¯å¾„ä¸ªæ•°\nåˆå§‹åŒ–ç¬¬ä¸€è¡Œå’Œå’Œç¬¬ä¸€åˆ—ä¸º1\nclass Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j \u0026lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i \u0026lt;= m; i++) { for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+è®°å¿†åŒ–\nclass Solution { public int uniquePaths(int m, int n) { int[][] memo = new int[m][n]; return dfs(0, 0, m, n, memo); } private int dfs(int i, int j, int m, int n, int[][] memo) { if (i \u0026gt;= m || j \u0026gt;= n || i \u0026lt; 0 || j \u0026lt; 0) { return 0; } if (memo[i][j] != 0) { return memo[i][j]; } if (i == m - 1 \u0026amp;\u0026amp; j == n - 1) { return 1; } int res = dfs(i + 1, j, m, n, memo) + dfs(i, j + 1, m, n, memo); memo[i][j] = res; return res; } } "},{"id":39,"href":"/docs/leetcode/dynamicprogramming/63/","title":"63rd","section":"Leet Code","content":" \rLink\n åŒ\r62é¢˜é¢˜æ€è·¯ä¸€æ ·\nç›´æ¥çœ‹DPè§£æ³•ï¼Œæ³¨æ„åˆå§‹åŒ–ï¼Œæœ‰éšœç¢ç‰©æ—¶ï¼Œå°±ä¸èƒ½å¾€åèµ°äº†\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } "},{"id":40,"href":"/docs/leetcode/dynamicprogramming/64/","title":"64th","section":"Leet Code","content":" \rLink\n dp[i][j] è¡¨ç¤ºåˆ°iè¡Œjåˆ—æœ€å°æ€»å’Œ æ³¨æ„åˆå§‹åŒ–\nclass Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int k = i; k \u0026gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j \u0026lt; n; j++) { for (int k = j; k \u0026gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } "},{"id":41,"href":"/docs/leetcode/dynamicprogramming/714/","title":"714th","section":"Leet Code","content":" \rLink\n ç¬¬iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦buy[i]\nå–å‡ºçš„æœ€å¤§åˆ©æ¶¦sell[i]\nå–å‡ºçš„æ—¶å€™(å®Œæˆäº†ä¸€ç¬”äº¤æ˜“)å‡å»æ‰‹ç»­è´¹\nclass Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } } "},{"id":42,"href":"/docs/leetcode/dynamicprogramming/91/","title":"91st","section":"Leet Code","content":" \rLink\n DFSæœç´¢ + è®°å¿†åŒ– class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numDecodings(String s) { if (s == null ||ï½“.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i \u0026gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i \u0026lt; n - 1 \u0026amp;\u0026amp; isValid(s.substring(i, i + 2))) { res += dfs(s, i + 2); } memo.put(s.substring(i), res); return res; } private boolean isValid(String s) { int val = Integer.valueOf(s); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } private boolean isValid(char c) { int t = c - \u0026#39;0\u0026#39;; return 1 \u0026lt;= t \u0026amp;\u0026amp; t \u0026lt;= 26; } } DP\n\rclass Solution { public int numDecodings(String s) { s = \u0026#34;#\u0026#34; + s; int n = s.length(); // dp[i] = s[0]..s[i]è§£ç æ–¹å¼  int[] dp = new int[n]; dp[0] = 1; dp[1] = (s.charAt(1) == \u0026#39;0\u0026#39;) ? 0 : 1; for (int i = 2; i \u0026lt; n; i++) { if (!isValid(s.charAt(i)) \u0026amp;\u0026amp; !isValid(s.charAt(i - 1), s.charAt(i))) { return 0; } if (isValid(s.charAt(i))) { dp[i] = dp[i - 1]; } if (isValid(s.charAt(i - 1), s.charAt(i))) { dp[i] += dp[i - 2]; } } return dp[n - 1]; } private boolean isValid(char c) { return \u0026#39;1\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } private boolean isValid(char a, char b) { int val = (a - \u0026#39;0\u0026#39;) * 10 + (b - \u0026#39;0\u0026#39;); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } } "},{"id":43,"href":"/docs/leetcode/heap/1046/","title":"1046th","section":"Leet Code","content":" \rLink\n // Time Complexity: O(nlogn)  // Space Complexity: O(n)  public int lastStoneWeight(int[] stones) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() \u0026gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.poll(); } "},{"id":44,"href":"/docs/leetcode/heap/347/","title":"347th","section":"Leet Code","content":" \rLink\n public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() \u0026gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!pq.isEmpty()) { res[idx++] = pq.poll(); } return res; } "},{"id":45,"href":"/docs/leetcode/heap/451/","title":"451st","section":"Leet Code","content":" \rLink\n public String frequencySort(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue\u0026lt;Character\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i \u0026lt; n; i++) { sb.append(c); } } return sb.toString(); } "},{"id":46,"href":"/docs/leetcode/math/1979/","title":"1979th","section":"Leet Code","content":" \rLink\n public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a \u0026gt; b  private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); } "},{"id":47,"href":"/docs/leetcode/math/384/","title":"384th","section":"Leet Code","content":" \rLink\n å¸¸è§„æ´—ç‰Œç®—æ³•ï¼Œæ€è·¯ï¼šå¯¹nä¸ªæ•°éšæœºé€‰ä¸€ä¸ªä¸ç¬¬ä¸€ä¸ªæ•°äº¤æ¢ï¼Œé™¤å»ç¬¬ä¸€ä¸ªæ•°çš„n-1ä¸ªæ•°åŒæ ·æ“ä½œã€‚\nç¬¬ä¸€è½®ï¼š1/n\nç¬¬äºŒè½®ï¼š(n-1)/n * 1/(n-1)\nç¬¬ä¸‰è½®ï¼š(n-1)/n * (n-2)/(n-1) * 1/(n-2)\nâ€¦â€¦â€¦â€¦\nprivate int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i \u0026lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; } "},{"id":48,"href":"/docs/leetcode/math/519/","title":"519th","section":"Leet Code","content":" \rLink\n class Solution { private int m; private int n; private int count; private Map\u0026lt;Integer, Integer\u0026gt; map; /** è½¬æˆä¸€ç»´æ•°ç»„ ç´¢å¼•i ç›¸å½“äº=\u0026gt; [i/n][i%n]ï¼Œå¹¶ç”¨Mapåªè®°å½•è¢«é€‰ä¸­çš„ä¿¡æ¯ï¼ˆæ€è·¯ç±»ä¼¼384ï¼Œä½†æ˜¯ä¿å­˜æ‰€æœ‰æ•°ä¼šè¶…å‡ºå†…å­˜é™åˆ¶ï¼‰: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =\u0026gt; 5 =\u0026gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =\u0026gt; 6 =\u0026gt; 3 map[5] = 4 map[3] = map[4] = 5 ... ... */ public Solution(int m, int n) { this.m = m; this.n = n; this.count = 0; this.map = new HashMap\u0026lt;\u0026gt;(); } public int[] flip() { int k = (int)(Math.random() * (m * n - count)); int res = 0; if (map.get(k) == null) { res = k; } else { res = map.get(k); } int lastIdx = m * n - count - 1; if (map.get(lastIdx) != null) { map.put(k, map.get(lastIdx)); } else { map.put(k, lastIdx); } count++; return new int[]{res / n, res % n}; } public void reset() { map.clear(); count = 0; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(m, n); * int[] param_1 = obj.flip(); * obj.reset(); */ "},{"id":49,"href":"/docs/leetcode/math/812/","title":"812th","section":"Leet Code","content":" \rLink\n çœ‹è¯„è®ºåŒºéƒ½ç”¨çº¿æ€§ä»£æ•°ï¼Œæ²¡å­¦è¿‡çº¿æ€§ä»£æ•°çš„æˆ‘ï¼Œæ³ªç›®äº†å“­ï¼\npublic double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i \u0026lt; points.length; i++) { for (int j = i + 1; j \u0026lt; points.length; j++) { for (int k = j + 1; k \u0026lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp \u0026gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b \u0026gt; c) || (a + c \u0026gt; b) || (b + c) \u0026gt; a; } // æœæ–­æ‰¾ä¸ªå…¬å¼ï¼Œæµ·ä¼¦å…¬å¼  private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.sqrt(p * (p - a) * (p - b) * (p - c)); } private double length(int[] p1, int[] p2) { return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)); } "},{"id":50,"href":"/docs/leetcode/others/1005/","title":"1005th","section":"Leet Code","content":" \rLink\n å†™çš„å®åœ¨æ˜¯å¤ªä¸‘é™‹äº†, å¤ªå¤šè¾¹ç•Œæ¡ä»¶ä¸æ˜“å†™\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // æœ€å°\u0026gt;0çš„æ•°ç´¢å¼•  for (int n : nums) { if (n \u0026lt; 0) i++; else break; } int j = i - 1; // æœ€å¤§è´Ÿæ•°ç´¢å¼•  int negCount = i; int idx = negCount - i; while (k \u0026gt; 0) { if (negCount \u0026gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i \u0026lt; nums.length \u0026amp;\u0026amp; nums[i] == 0) break; if ( i \u0026gt;= nums.length || (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt; nums[j])) { nums[j] = -nums[j]; } else { nums[i] = -nums[i]; } } k--; } int sum = 0; for (int n : nums) { sum += n; } return sum; } } ä¼˜å…ˆé˜Ÿåˆ—è§£æ³•(æœ€å°å †)\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int n : nums) { q.add(n); } while (k \u0026gt; 0) { q.add(0 - q.poll()); k--; } int sum = 0; while (!q.isEmpty()) { sum += q.poll(); } return sum; } } "},{"id":51,"href":"/docs/leetcode/others/383/","title":"383rd","section":"Leet Code","content":" \rLink\n class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - \u0026#39;a\u0026#39;] \u0026lt;= 0) return false; count[c - \u0026#39;a\u0026#39;]--; } return true; } } "},{"id":52,"href":"/docs/leetcode/others/5963/","title":"5963rd","section":"Leet Code","content":" TODO: Link\n class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i) == \u0026#39;0\u0026#39;) { i--; } for ( ; i \u0026gt;= 0; i--) { sb.append(s.charAt(i)); } return sb.toString(); } } "},{"id":53,"href":"/docs/leetcode/others/5965/","title":"5965th","section":"Leet Code","content":" TODO: Link\n ç¨å¾®ä¼˜åŒ–ä¸‹è¿˜æ˜¯è¶…æ—¶ï¼Œæ”¾å¼ƒ\nclass Solution { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // if (i == begin) continue;  if (arr[begin] == arr[i]) { list.add(i); } } map.put(arr[begin], list); System.out.println(1); } else { System.out.println(2); } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } è¶…æ—¶\nclass Solution { public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (i == begin) continue; if (arr[begin] == arr[i]) { list.add(i); } } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } ``"},{"id":54,"href":"/docs/leetcode/others/5967/","title":"5967th","section":"Leet Code","content":" \rLink\n public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i \u0026lt; chs.length; i++) { if (chs[i] == \u0026#39;a\u0026#39;) { x = i; } else if (y == -1 \u0026amp;\u0026amp; chs[i] == \u0026#39;b\u0026#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x \u0026lt; y; } "},{"id":55,"href":"/docs/leetcode/others/5968/","title":"5968th","section":"Leet Code","content":" \rLink\n class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i \u0026lt; m - 1; i++) { if (!bank[i].contains(\u0026#34;1\u0026#34;)) { continue; } int t = calculate(bank, i); // è®¡ç®—è¿™ä¸€è¡Œç¬¦åˆçš„æ¿€å…‰æŸæ•°é‡  if (t \u0026gt; 0) { // update result  for (int j = 0; j \u0026lt; n; j++) { if (bank[i].charAt(j) == \u0026#39;1\u0026#39;) { res += t; } } } } return res; } private int calculate(String[] bank, int start) { int end = start; for (int i = end + 1; i \u0026lt; m; i++) { if (bank[i].contains(\u0026#34;1\u0026#34;)) { end = i; break; } } int result = 0; if (end != start) { for (int i = 0; i \u0026lt; n; i++) { if (bank[end].charAt(i) == \u0026#39;1\u0026#39;) { result++; } } } return result; } } "},{"id":56,"href":"/docs/leetcode/others/5969/","title":"5969th","section":"Leet Code","content":" [Link]\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t \u0026lt; a) { return false; } else { t += a; } } return true; } } "},{"id":57,"href":"/docs/leetcode/others/748/","title":"748th","section":"Leet Code","content":" \rLink\n public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = \u0026#34;\u0026#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) \u0026amp;\u0026amp; word.length() \u0026lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i \u0026lt; a1.length; i++) { if (a1[i] \u0026gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.toCharArray()) { if (Character.isLetter(c)) { c = Character.toUpperCase(c); tmp[c - \u0026#39;A\u0026#39;]++; } } return tmp; } "},{"id":58,"href":"/docs/leetcode/recursion/1492/","title":"1492nd","section":"Leet Code","content":" \rLink\n public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f \u0026gt;= n \u0026amp;\u0026amp; k \u0026gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); } "},{"id":59,"href":"/docs/leetcode/sorts/215/","title":"215th","section":"Leet Code","content":" \rLink\n ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—\n// Time Complexity: O(nlgn)  // Space Complexity: O(k)  public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int num : nums) { if (q.size() == k) { if (num \u0026gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); } "},{"id":60,"href":"/docs/leetcode/tree/102/","title":"102nd","section":"Leet Code","content":" \rLink\n è€ƒè™‘å½“å‰å±‚ç»“æŸæ¡ä»¶ï¼Œå³å½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); int count = q.size(); while (count \u0026gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; } "},{"id":61,"href":"/docs/leetcode/tree/559/","title":"559th","section":"Leet Code","content":" \rLink ä¸€é“ç®€å•çš„æœç´¢\n public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i \u0026lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; } "},{"id":62,"href":"/docs/leetcode/tree/700/","title":"700th","section":"Leet Code","content":" \rLink\n é€’å½’æœç´¢\nclass Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val \u0026gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } } "},{"id":63,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/","title":"å‰‘æŒ‡ Offer","section":"Leet Code","content":" \rå‰‘æŒ‡ Offer 04. äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾(M) \rå‰‘æŒ‡ Offer 50. ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦(E) \rå‰‘æŒ‡ Offer 32 - I. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘(M) \rå‰‘æŒ‡ Offer 32 - II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II(E) \rå‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III(M) \rå‰‘æŒ‡ Offer 47. ç¤¼ç‰©çš„æœ€å¤§ä»·å€¼(M) \rå‰‘æŒ‡ Offer 26. æ ‘çš„å­ç»“æ„(M) \rå‰‘æŒ‡ Offer 18. åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹(E) \rå‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹(E) \rå‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²(M) \rå‰‘æŒ‡ Offer 46. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²(M) \rå‰‘æŒ‡ Offer 25. åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨(M) \rå‰‘æŒ‡ Offer 57. å’Œä¸ºsçš„ä¸¤ä¸ªæ•°å­—(E) \rå‰‘æŒ‡ Offer 21. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢(E) \rå‰‘æŒ‡ Offer 58 - I. ç¿»è½¬å•è¯é¡ºåº(E) \rå‰‘æŒ‡ Offer 13. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´(M) \rå‰‘æŒ‡ Offer 12. çŸ©é˜µä¸­çš„è·¯å¾„(M) \rå‰‘æŒ‡ Offer 64. æ±‚1+2+â€¦+n(M) \rå‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹(M) \rå‰‘æŒ‡ Offer 55 - I. äºŒå‰æ ‘çš„æ·±åº¦(E) \rå‰‘æŒ‡ Offer 55 - II. å¹³è¡¡äºŒå‰æ ‘(E) \rå‰‘æŒ‡ Offer 68 - I. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ(E) \rå‰‘æŒ‡ Offer 68 - II. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ(E) \rå‰‘æŒ‡ Offer 15. äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°(E)  "},{"id":64,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/","title":"4th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n \rä¸Šå›¾æ˜¯ä»å³ä¸Šè§’ï¼ŒåŒç†å·¦ä¸‹è§’\nclass Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] \u0026lt; target) { col++; } else { row--; } } return false; } } "},{"id":65,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/","title":"12th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || board[i][j] != word.charAt(idx)) { return false; } if (idx == word.length() - 1) { return true; } board[i][j] = \u0026#39;0\u0026#39;; boolean res = search(board, word, idx + 1, i + 1, j) || search(board, word, idx + 1, i - 1, j) || search(board, word, idx + 1, i, j + 1) || search(board, word, idx + 1, i, j - 1); board[i][j] = word.charAt(idx); return res; } èœå†™æ³•ï¼Œè¶…æ—¶\nclass Solution { private int m; private int n; private char[][] board; private String word; private boolean[][] visited; public boolean exist(char[][] board, String word) { this.m = board.length; this.n = board[0].length; this.visited = new boolean[m][n]; this.board = board; this.word = word; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dfs(sb, i, j)) return true; } } return false; } private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; private boolean dfs(StringBuilder cur, int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n) { return false; } if (visited[x][y]) { return false; } cur.append(board[x][y]); visited[x][y] = true; int cmp = cur.length() - word.length(); if (cmp == 0 \u0026amp;\u0026amp; word.equals(cur.toString())) { return true; } else if (cmp \u0026lt; 0) { for (int i = 0; i \u0026lt; 4; i++) { int tmpX = x + dirs[i][0]; int tmpY = y + dirs[i][1]; if (dfs(cur, tmpX, tmpY)) return true; } } visited[x][y] = false; cur.deleteCharAt(cur.length() - 1); return false; } } "},{"id":66,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/","title":"13th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n ç®€å•DFS\nclass Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x \u0026gt;= m || x \u0026lt; 0 || y \u0026gt;= n || y \u0026lt; 0) return 0; if (visited[x][y] || !isValid(x, y)) { return 0; } visited[x][y] = true; return 1 + dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1); } private boolean isValid(int x, int y) { int val = 0; while (x \u0026gt; 0) { val += (x % 10); x /= 10; } while (y \u0026gt; 0) { val += (y % 10); y /= 10; } return val \u0026lt;= k; } } "},{"id":67,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/","title":"15th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;\u0026gt;= 1; } return res; } "},{"id":68,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/","title":"18th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } } "},{"id":69,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/","title":"21st","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i \u0026lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; } "},{"id":70,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/","title":"22nd","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public ListNode getKthFromEnd(ListNode head, int k) { Stack\u0026lt;ListNode\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head); head = head.next; } if (k \u0026gt; s.size()) return null; ListNode res = null; while (k \u0026gt; 0) { k--; res = s.pop(); } return res; } "},{"id":71,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/","title":"25th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null \u0026amp;\u0026amp; cur2 != null) { if (cur1.val \u0026lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.next; } "},{"id":72,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/","title":"26th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) \u0026amp;\u0026amp; help(A.right, B.right); } } "},{"id":73,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/","title":"32 1","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } } "},{"id":74,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/","title":"32 2","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null]  while (q.peek() != null) { TreeNode node; List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); } res.add(tmp); q.offer(null); } return res; } } "},{"id":75,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/","title":"32 3","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList\u0026lt;Integer\u0026gt; tmp = new LinkedList\u0026lt;\u0026gt;(); int n = res.size(); for (int i = q.size(); i \u0026gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } res.add(tmp); } return res; } } "},{"id":76,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/","title":"46th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n DFS\npublic int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start \u0026gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - \u0026#39;0\u0026#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start \u0026lt; str.length() - 1) { // 06  if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - \u0026#39;0\u0026#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25; } åŠ¨æ€è§„åˆ’\npublic int translateNum(int num) { String str = String.valueOf(num); int n = str.length(); // ä»¥iä¸ºç»“å°¾ ä¸åŒç¿»è¯‘æ•°  int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1]; int val = (str.charAt(i - 2) - \u0026#39;0\u0026#39;) * 10 + (str.charAt(i - 1) - \u0026#39;0\u0026#39;); if (10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25) { dp[i] = (dp[i - 2] + dp[i - 1]); } } return dp[n]; } "},{"id":77,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/","title":"47th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } } "},{"id":78,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/","title":"48th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n åŒæŒ‡é’ˆ\npublic int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (j \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; } "},{"id":79,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/","title":"50th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public char firstUniqChar(String s) { Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - \u0026#39;a\u0026#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return \u0026#39; \u0026#39;; } } "},{"id":80,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/","title":"54th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n DFS\nprivate int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack\npublic int kthLargest(TreeNode root, int k) { Queue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (q.size() \u0026lt; k) { q.offer(node.val); } else if (q.peek() \u0026lt; node.val) { q.poll(); q.offer(node.val); } if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } return q.peek(); } "},{"id":81,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/","title":"55 1","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } "},{"id":82,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/","title":"55 2","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) \u0026lt; 2 \u0026amp;\u0026amp; (isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; } "},{"id":83,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/","title":"57th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i \u0026lt; j) { if (nums[i] + nums[j] \u0026lt; target) { i++; } else if (nums[i] + nums[j] \u0026gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; } "},{"id":84,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/","title":"58th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i \u0026gt;= 0) { while(i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] != \u0026#39; \u0026#39;) i--; sb.append(s.substring(i + 1, j + 1) + \u0026#34; \u0026#34;); while (i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] == \u0026#39; \u0026#39;) i--; j = i; } return sb.toString().trim(); } "},{"id":85,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/","title":"64th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int sumNums(int n) { boolean tmp = n \u0026gt; 1 \u0026amp;\u0026amp; (n += sumNums(n - 1)) \u0026gt; 0; return n; } "},{"id":86,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/","title":"68 1","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } } "},{"id":87,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/","title":"68 2","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left == null ? right : left; } ä»»æ„kä¸ªæ•°çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ\nprivate int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.val == p.val || node.val == q.val) { k--; } dfs(node.left, p, q); dfs(node.right, p, q); if (oldK == 2 \u0026amp;\u0026amp; k == 0 \u0026amp;\u0026amp; res == null) { res = node; } } "},{"id":88,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"é¢è¯•é¢˜","section":"Leet Code","content":" \ré¢è¯•é¢˜ 08.05. é€’å½’ä¹˜æ³•(M)  "},{"id":89,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/","title":"805th","section":"é¢è¯•é¢˜","content":" \rLink\n public int multiply(int A, int B) { if (B == 0) return 0; else if (B == 1) return A; else return A + multiply(A, B - 1); } "},{"id":90,"href":"/docs/cs/leetcode/994/","title":"LeetCode 994","section":"C S","content":" ä¸€å¼€å§‹ï¼Œæˆ‘ä»¬æ‰¾å‡ºæ‰€æœ‰è…çƒ‚çš„æ©˜å­ï¼Œå°†å®ƒä»¬æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸ºç¬¬ 0 å±‚çš„ç»“ç‚¹ã€‚ ç„¶åè¿›è¡Œ BFS éå†ï¼Œæ¯ä¸ªç»“ç‚¹çš„ç›¸é‚»ç»“ç‚¹å¯èƒ½æ˜¯ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘çš„ç»“ç‚¹ï¼Œæ³¨æ„åˆ¤æ–­ç»“ç‚¹ä½äºç½‘æ ¼è¾¹ç•Œçš„ç‰¹æ®Šæƒ…å†µã€‚ ç”±äºå¯èƒ½å­˜åœ¨æ— æ³•è¢«æ±¡æŸ“çš„æ©˜å­ï¼Œæˆ‘ä»¬éœ€è¦è®°å½•æ–°é²œæ©˜å­çš„æ•°é‡ã€‚åœ¨ BFS ä¸­ï¼Œæ¯éå†åˆ°ä¸€ä¸ªæ©˜å­ï¼ˆæ±¡æŸ“äº†ä¸€ä¸ªæ©˜å­ï¼‰ï¼Œå°±å°†æ–°é²œæ©˜å­çš„æ•°é‡å‡ä¸€ã€‚å¦‚æœ BFS ç»“æŸåè¿™ä¸ªæ•°é‡ä»æœªå‡ä¸ºé›¶ï¼Œè¯´æ˜å­˜åœ¨æ— æ³•è¢«æ±¡æŸ“çš„æ©˜å­ã€‚  public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue\u0026lt;int[]\u0026gt; Q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count \u0026gt; 0 \u0026amp;\u0026amp; !Q.isEmpty()) { times++; int curSize = Q.size(); for (int j = 0; j \u0026lt; curSize; j ++) { int[] node = Q.poll(); for (int i = 0; i \u0026lt; 4; i++) { int[] neighbor = new int[]{node[0] + dir[i][0], node[1] + dir[i][1]}; if (neighbor[0] \u0026lt; 0 || neighbor[1] \u0026lt; 0 || neighbor[0] \u0026gt;= m || neighbor[1] \u0026gt;= n || grid[neighbor[0]][neighbor[1]] != 1) continue; grid[neighbor[0]][neighbor[1]] = 2; fresh_count--; Q.add(neighbor); } } } return fresh_count != 0 ? -1 : times; } "}]