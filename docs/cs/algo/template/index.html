<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Acwing模板 时间复杂度分析
 快速排序#void quick_sort(int q[], int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } 归并排序#void merge_sort(int q[], int l, int r) { if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i <= mid && j <= r) if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j]; } 二分#// 区间[l,r]划分成[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (check(mid)) { //check() 检查mid是否满足性质  r = mid; } else { l = mid + 1; } } } // 区间[l,r]划分成[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l < r) { int mid = l + r + 1>> 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } 双指针#常见问题分类：(1) 对于一个序列，用两个指针维护一段区间(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作for (int i = 0, j = 0; i < n; i ++ ) { while (j < i && check(i, j)) j ++ ; // 具体问题的逻辑 } 位运算#求n的第k位数字: n >> k & 1返回n的最后一位1：lowbit(n) = n & -n离散化#vector<int> alls; // 存储所有待离散化的值 sort(alls."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Acwing模板 时间复杂度分析
 快速排序#void quick_sort(int q[], int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } 归并排序#void merge_sort(int q[], int l, int r) { if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i <= mid && j <= r) if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j]; } 二分#// 区间[l,r]划分成[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (check(mid)) { //check() 检查mid是否满足性质  r = mid; } else { l = mid + 1; } } } // 区间[l,r]划分成[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l < r) { int mid = l + r + 1>> 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } 双指针#常见问题分类：(1) 对于一个序列，用两个指针维护一段区间(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作for (int i = 0, j = 0; i < n; i ++ ) { while (j < i && check(i, j)) j ++ ; // 具体问题的逻辑 } 位运算#求n的第k位数字: n >> k & 1返回n的最后一位1：lowbit(n) = n & -n离散化#vector<int> alls; // 存储所有待离散化的值 sort(alls."><meta property="og:type" content="article"><meta property="og:url" content="https://cs-learning-every-day.github.io/docs/cs/algo/template/"><title>Template | Day Day Up</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.d4dc77238886ba9b68049c5bf55f2cee407597ba579bac1c5c89e9faef0ed76c.css integrity="sha256-1Nx3I4iGuptoBJxb9V8s7kB1l7pXm6wcXInp+u8O12w=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.291adbd8f30dc5425a00fb9ce4cd226dc96149e3f7a73d3f02af1310fbd79f87.js integrity="sha256-KRrb2PMNxUJaAPuc5M0ibclhSeP3pz0/Aq8TEPvXn4c=" crossorigin=anonymous></script><script defer src=/sw.min.74a8bb07f0bee86d6bb9a2750f073f14d93c7e4512f28860370cfd879e9719b4.js integrity="sha256-dKi7B/C+6G1ruaJ1Dwc/FNk8fkUS8ohgNwz9h56XGbQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.jpg alt=Logo><span>Day Day Up</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><p><a href=/docs/cs/><strong>Computer Science</strong></a></p></li><li><ul><li><a href=/docs/cs/database/>Database</a></li></ul></li><li><ul><li><a href=/docs/cs/software/>Software</a></li></ul></li><li><ul><li><a href=/docs/cs/build/>Building</a></li></ul></li><li><ul><li><a href=/docs/cs/operatingsystem/>Operating System</a></li></ul></li><li><ul><li><a href=/docs/cs/distributedsystem/>Distributed System</a></li></ul></li><li><ul><li><a href=/docs/cs/network/>Network</a></li></ul></li><li><ul><li><a href=/docs/cs/programming/>Programming</a></li></ul></li><li><ul><li><a href=/docs/cs/algo/>Algorithm</a></li></ul></li><li><ul><li><a href=/docs/cs/tools/>Tools</a></li></ul></li><li><p><a href=/docs/book/><strong>Book</strong></a></p></li><li><ul><li><a href=/docs/book/resource/>Resource</a></li></ul></li></ul><p></p><ul><li><a href=/docs/english/><strong>English</strong></a></li></ul><p><a href=/docs/tools/><strong>工具</strong></a></p><p><a href=/docs/cs/interviews/><strong>Interviews</strong></a></p><ul><li><p><a href=/docs/leetcode/><strong>LeetCode</strong></a></p></li><li><p><a href=/docs/cs/resource/><strong>Resource</strong></a></p></li><li><p><a href=/docs/game/><strong>Game</strong></a></p></li></ul><ul><li><a href=/posts/>Blog</a></li><li><a href=https://github.com/cs-learning-every-day target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Template</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#快速排序>快速排序</a></li><li><a href=#归并排序>归并排序</a></li><li><a href=#二分>二分</a></li><li><a href=#双指针>双指针</a></li><li><a href=#位运算>位运算</a></li><li><a href=#离散化>离散化</a></li><li><a href=#区间合并>区间合并</a></li><li><a href=#单链表>单链表</a></li><li><a href=#双链表>双链表</a></li><li><a href=#队列>队列</a></li><li><a href=#单调栈>单调栈</a></li><li><a href=#单调队列>单调队列</a></li><li><a href=#kmp>KMP</a></li><li><a href=#trie树>Trie树</a></li><li><a href=#并查集>并查集</a></li><li><a href=#堆>堆</a></li><li><a href=#一般哈希>一般哈希</a></li><li><a href=#字符串哈希>字符串哈希</a></li><li><a href=#c-stl简介>C++ STL简介</a></li><li><a href=#树与图的存储>树与图的存储</a></li><li><a href=#树与图的遍历>树与图的遍历</a></li><li><a href=#拓扑排序>拓扑排序</a></li><li><a href=#朴素dijkstra算法>朴素dijkstra算法</a></li><li><a href=#堆优化版dijkstra>堆优化版dijkstra</a></li><li><a href=#bellman-ford算法>Bellman-Ford算法</a></li><li><a href=#spfa-算法队列优化的bellman-ford算法>spfa 算法（队列优化的Bellman-Ford算法）</a></li><li><a href=#spfa判断图中是否存在负环>spfa判断图中是否存在负环</a></li><li><a href=#floyd算法>floyd算法</a></li><li><a href=#朴素版prim算法>朴素版prim算法</a></li><li><a href=#kruskal算法>Kruskal算法</a></li><li><a href=#染色法判别二分图>染色法判别二分图</a></li><li><a href=#匈牙利算法>匈牙利算法</a></li><li><a href=#试除法判定质数>试除法判定质数</a></li><li><a href=#试除法分解质因数>试除法分解质因数</a></li><li><a href=#朴素筛法求素数>朴素筛法求素数</a></li><li><a href=#线性筛法求素数>线性筛法求素数</a></li><li><a href=#试除法求所有约数>试除法求所有约数</a></li><li><a href=#约数个数和约数之和>约数个数和约数之和</a></li><li><a href=#欧几里得算法>欧几里得算法</a></li><li><a href=#求欧拉函数>求欧拉函数</a></li><li><a href=#筛法求欧拉函数>筛法求欧拉函数</a></li><li><a href=#快速幂>快速幂</a></li><li><a href=#扩展欧几里得算法>扩展欧几里得算法</a></li><li><a href=#高斯消元>高斯消元</a></li><li><a href=#递归法求组合数>递归法求组合数</a></li><li><a href=#通过预处理逆元的方式求组合数>通过预处理逆元的方式求组合数</a></li><li><a href=#lucas定理>Lucas定理</a></li><li><a href=#分解质因数法求组合数>分解质因数法求组合数</a></li><li><a href=#卡特兰数>卡特兰数</a></li><li><a href=#nim游戏>NIM游戏</a></li><li><a href=#公平组合游戏icg>公平组合游戏ICG</a></li><li><a href=#有向图游戏>有向图游戏</a></li><li><a href=#mex运算>Mex运算</a></li><li><a href=#sg函数>SG函数</a></li><li><a href=#有向图游戏的和>有向图游戏的和</a></li><li><a href=#树状数组模板>树状数组模板</a></li></ul></li><li><a href=#dp>DP</a><ul><li><a href=#树形dp>树形DP</a></li></ul></li></ul></nav></aside></header><article class=markdown><blockquote><p><a href=https://www.acwing.com/activity/content/11/>Acwing模板</a>
<a href=https://www.acwing.com/blog/content/32/>时间复杂度分析</a></p></blockquote><h3 id=快速排序>快速排序
<a class=anchor href=#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>quick_sort</span>(<span style=color:#66d9ef>int</span> q[], <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r)
{
    <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&gt;=</span> r) <span style=color:#66d9ef>return</span>;

    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, x <span style=color:#f92672>=</span> q[l <span style=color:#f92672>+</span> r <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>];
    <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j)
    {
        <span style=color:#66d9ef>do</span> i <span style=color:#f92672>++</span> ; <span style=color:#66d9ef>while</span> (q[i] <span style=color:#f92672>&lt;</span> x);
        <span style=color:#66d9ef>do</span> j <span style=color:#f92672>--</span> ; <span style=color:#66d9ef>while</span> (q[j] <span style=color:#f92672>&gt;</span> x);
        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, r);
}
</code></pre></div><h3 id=归并排序>归并排序
<a class=anchor href=#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge_sort</span>(<span style=color:#66d9ef>int</span> q[], <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r)
{
    <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&gt;=</span> r) <span style=color:#66d9ef>return</span>;

    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> l <span style=color:#f92672>+</span> r <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>;
    merge_sort(q, l, mid);
    merge_sort(q, mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, r);

    <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, i <span style=color:#f92672>=</span> l, j <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> mid <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;=</span> r)
        <span style=color:#66d9ef>if</span> (q[i] <span style=color:#f92672>&lt;=</span> q[j]) tmp[k <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> q[i <span style=color:#f92672>++</span> ];
        <span style=color:#66d9ef>else</span> tmp[k <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> q[j <span style=color:#f92672>++</span> ];

    <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> mid) tmp[k <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> q[i <span style=color:#f92672>++</span> ];
    <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&lt;=</span> r) tmp[k <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> q[j <span style=color:#f92672>++</span> ];

    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> l, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> r; i <span style=color:#f92672>++</span>, j <span style=color:#f92672>++</span> ) q[i] <span style=color:#f92672>=</span> tmp[j];
}
</code></pre></div><h3 id=二分>二分
<a class=anchor href=#%e4%ba%8c%e5%88%86>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 区间[l,r]划分成[l, mid], [mid + 1, r]
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>binary_search1</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
    <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r) {
        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> l <span style=color:#f92672>+</span> r <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>if</span> (check(mid)) { <span style=color:#75715e>//check() 检查mid是否满足性质
</span><span style=color:#75715e></span>            r <span style=color:#f92672>=</span> mid;
        } <span style=color:#66d9ef>else</span> {
            l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
        }
    }
}
<span style=color:#75715e>// 区间[l,r]划分成[l, mid - 1], [mid, r]
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>binary_search2</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
    <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r) {
        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> l <span style=color:#f92672>+</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>if</span> (check(mid)) {
            l <span style=color:#f92672>=</span> mid;
        } <span style=color:#66d9ef>else</span> {
            r <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
        }
    }
}
</code></pre></div><h3 id=双指针>双指针
<a class=anchor href=#%e5%8f%8c%e6%8c%87%e9%92%88>#</a></h3><pre><code>常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span> )
{
    <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&lt;</span> i <span style=color:#f92672>&amp;&amp;</span> check(i, j)) j <span style=color:#f92672>++</span> ;

    <span style=color:#75715e>// 具体问题的逻辑
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=位运算>位运算
<a class=anchor href=#%e4%bd%8d%e8%bf%90%e7%ae%97>#</a></h3><pre><code>求n的第k位数字: n &gt;&gt; k &amp; 1
返回n的最后一位1：lowbit(n) = n &amp; -n
</code></pre><h3 id=离散化>离散化
<a class=anchor href=#%e7%a6%bb%e6%95%a3%e5%8c%96>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> alls; <span style=color:#75715e>// 存储所有待离散化的值
</span><span style=color:#75715e></span>sort(alls.begin(), alls.end()); <span style=color:#75715e>// 将所有值排序
</span><span style=color:#75715e></span>alls.erase(unique(alls.begin(), alls.end()), alls.end());   <span style=color:#75715e>// 去掉重复元素
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 二分求出x对应的离散化的值
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x) <span style=color:#75715e>// 找到第一个大于等于x的位置
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, r <span style=color:#f92672>=</span> alls.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r)
    {
        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> l <span style=color:#f92672>+</span> r <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>if</span> (alls[mid] <span style=color:#f92672>&gt;=</span> x) r <span style=color:#f92672>=</span> mid;
        <span style=color:#66d9ef>else</span> l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    }
    <span style=color:#66d9ef>return</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 映射到1, 2, ...n
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=区间合并>区间合并
<a class=anchor href=#%e5%8c%ba%e9%97%b4%e5%90%88%e5%b9%b6>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 将所有存在交集的区间合并
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(vector<span style=color:#f92672>&lt;</span>PII<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>segs)
{
    vector<span style=color:#f92672>&lt;</span>PII<span style=color:#f92672>&gt;</span> res;

    sort(segs.begin(), segs.end());

    <span style=color:#66d9ef>int</span> st <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2e9</span>, ed <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2e9</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> seg : segs)
        <span style=color:#66d9ef>if</span> (ed <span style=color:#f92672>&lt;</span> seg.first)
        {
            <span style=color:#66d9ef>if</span> (st <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2e9</span>) res.push_back({st, ed});
            st <span style=color:#f92672>=</span> seg.first, ed <span style=color:#f92672>=</span> seg.second;
        }
        <span style=color:#66d9ef>else</span> ed <span style=color:#f92672>=</span> max(ed, seg.second);

    <span style=color:#66d9ef>if</span> (st <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2e9</span>) res.push_back({st, ed});

    segs <span style=color:#f92672>=</span> res;
}
</code></pre></div><h3 id=单链表>单链表
<a class=anchor href=#%e5%8d%95%e9%93%be%e8%a1%a8>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> head, e[N], ne[N], idx;

<span style=color:#75715e>// 初始化
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>()
{
    head <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e>// 在链表头插入一个数a
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>int</span> a)
{
    e[idx] <span style=color:#f92672>=</span> a, ne[idx] <span style=color:#f92672>=</span> head, head <span style=color:#f92672>=</span> idx <span style=color:#f92672>++</span> ;
}

<span style=color:#75715e>// 将头结点删除，需要保证头结点存在
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>()
{
    head <span style=color:#f92672>=</span> ne[head];
}
</code></pre></div><h3 id=双链表>双链表
<a class=anchor href=#%e5%8f%8c%e9%93%be%e8%a1%a8>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> e[N], l[N], r[N], idx;

<span style=color:#75715e>// 初始化
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>()
{
    <span style=color:#75715e>//0是左端点，1是右端点
</span><span style=color:#75715e></span>    r[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, l[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
}

<span style=color:#75715e>// 在节点a的右边插入一个数x
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> x)
{
    e[idx] <span style=color:#f92672>=</span> x;
    l[idx] <span style=color:#f92672>=</span> a, r[idx] <span style=color:#f92672>=</span> r[a];
    l[r[a]] <span style=color:#f92672>=</span> idx, r[a] <span style=color:#f92672>=</span> idx <span style=color:#f92672>++</span> ;
}

<span style=color:#75715e>// 删除节点a
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>int</span> a)
{
    l[r[a]] <span style=color:#f92672>=</span> l[a];
    r[l[a]] <span style=color:#f92672>=</span> r[a];
}
</code></pre></div><p>栈</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// tt表示栈顶
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> stk[N], tt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>// 向栈顶插入一个数
</span><span style=color:#75715e></span>stk[ <span style=color:#f92672>++</span> tt] <span style=color:#f92672>=</span> x;

<span style=color:#75715e>// 从栈顶弹出一个数
</span><span style=color:#75715e></span>tt <span style=color:#f92672>--</span> ;

<span style=color:#75715e>// 栈顶的值
</span><span style=color:#75715e></span>stk[tt];

<span style=color:#75715e>// 判断栈是否为空
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (tt <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
{

}
</code></pre></div><h3 id=队列>队列
<a class=anchor href=#%e9%98%9f%e5%88%97>#</a></h3><ol><li>普通队列</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// hh 表示队头，tt表示队尾
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> q[N], hh <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, tt <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;

<span style=color:#75715e>// 向队尾插入一个数
</span><span style=color:#75715e></span>q[ <span style=color:#f92672>++</span> tt] <span style=color:#f92672>=</span> x;

<span style=color:#75715e>// 从队头弹出一个数
</span><span style=color:#75715e></span>hh <span style=color:#f92672>++</span> ;

<span style=color:#75715e>// 队头的值
</span><span style=color:#75715e></span>q[hh];

<span style=color:#75715e>// 判断队列是否为空
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (hh <span style=color:#f92672>&lt;=</span> tt)
{

}
</code></pre></div><ol start=2><li>循环队列</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// hh 表示队头，tt表示队尾的后一个位置
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> q[N], hh <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, tt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>// 向队尾插入一个数
</span><span style=color:#75715e></span>q[tt <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> x;
<span style=color:#66d9ef>if</span> (tt <span style=color:#f92672>==</span> N) tt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>// 从队头弹出一个数
</span><span style=color:#75715e></span>hh <span style=color:#f92672>++</span> ;
<span style=color:#66d9ef>if</span> (hh <span style=color:#f92672>==</span> N) hh <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>// 队头的值
</span><span style=color:#75715e></span>q[hh];

<span style=color:#75715e>// 判断队列是否为空
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (hh <span style=color:#f92672>!=</span> tt)
{

}
</code></pre></div><h3 id=单调栈>单调栈
<a class=anchor href=#%e5%8d%95%e8%b0%83%e6%a0%88>#</a></h3><p><code>常见模型：找出每个数左边离它最近的比它大/小的数</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> tt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
{
    <span style=color:#66d9ef>while</span> (tt <span style=color:#f92672>&amp;&amp;</span> check(stk[tt], i)) tt <span style=color:#f92672>--</span> ;
    stk[ <span style=color:#f92672>++</span> tt] <span style=color:#f92672>=</span> i;
}
</code></pre></div><h3 id=单调队列>单调队列
<a class=anchor href=#%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97>#</a></h3><p><code>常见模型：找出滑动窗口中的最大值/最小值</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> hh <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, tt <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span> )
{
    <span style=color:#66d9ef>while</span> (hh <span style=color:#f92672>&lt;=</span> tt <span style=color:#f92672>&amp;&amp;</span> check_out(q[hh])) hh <span style=color:#f92672>++</span> ;  <span style=color:#75715e>// 判断队头是否滑出窗口
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (hh <span style=color:#f92672>&lt;=</span> tt <span style=color:#f92672>&amp;&amp;</span> check(q[tt], i)) tt <span style=color:#f92672>--</span> ;
    q[ <span style=color:#f92672>++</span> tt] <span style=color:#f92672>=</span> i;
}
</code></pre></div><h3 id=kmp>KMP
<a class=anchor href=#kmp>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
</span><span style=color:#75715e>// 求模式串的Next数组：
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> m; i <span style=color:#f92672>++</span> )
{
    <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&amp;&amp;</span> p[i] <span style=color:#f92672>!=</span> p[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) j <span style=color:#f92672>=</span> ne[j];
    <span style=color:#66d9ef>if</span> (p[i] <span style=color:#f92672>==</span> p[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) j <span style=color:#f92672>++</span> ;
    ne[i] <span style=color:#f92672>=</span> j;
}

<span style=color:#75715e>// 匹配
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
{
    <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&amp;&amp;</span> s[i] <span style=color:#f92672>!=</span> p[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) j <span style=color:#f92672>=</span> ne[j];
    <span style=color:#66d9ef>if</span> (s[i] <span style=color:#f92672>==</span> p[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) j <span style=color:#f92672>++</span> ;
    <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>==</span> m)
    {
        j <span style=color:#f92672>=</span> ne[j];
        <span style=color:#75715e>// 匹配成功后的逻辑
</span><span style=color:#75715e></span>    }
}
</code></pre></div><h3 id=trie树>Trie树
<a class=anchor href=#trie%e6%a0%91>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> son[N][<span style=color:#ae81ff>26</span>], cnt[N], idx;
<span style=color:#75715e>// 0号点既是根节点，又是空节点
</span><span style=color:#75715e>// son[][]存储树中每个节点的子节点
</span><span style=color:#75715e>// cnt[]存储以每个节点结尾的单词数量
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 插入一个字符串
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str)
{
    <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; str[i]; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> str[i] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>son[p][u]) son[p][u] <span style=color:#f92672>=</span> <span style=color:#f92672>++</span> idx;
        p <span style=color:#f92672>=</span> son[p][u];
    }
    cnt[p] <span style=color:#f92672>++</span> ;
}

<span style=color:#75715e>// 查询字符串出现的次数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str)
{
    <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; str[i]; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> str[i] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>son[p][u]) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        p <span style=color:#f92672>=</span> son[p][u];
    }
    <span style=color:#66d9ef>return</span> cnt[p];
}
</code></pre></div><h3 id=并查集>并查集
<a class=anchor href=#%e5%b9%b6%e6%9f%a5%e9%9b%86>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// (1)朴素并查集：
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> p[N]; <span style=color:#75715e>//存储每个点的祖宗节点
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 返回x的祖宗节点
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x)
    {
        <span style=color:#66d9ef>if</span> (p[x] <span style=color:#f92672>!=</span> x) p[x] <span style=color:#f92672>=</span> find(p[x]);
        <span style=color:#66d9ef>return</span> p[x];
    }

    <span style=color:#75715e>// 初始化，假定节点编号是1~n
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> ) p[i] <span style=color:#f92672>=</span> i;

    <span style=color:#75715e>// 合并a和b所在的两个集合：
</span><span style=color:#75715e></span>    p[find(a)] <span style=color:#f92672>=</span> find(b);


<span style=color:#75715e>// (2)维护size的并查集：
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>int</span> p[N], size[N];
    <span style=color:#75715e>//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 返回x的祖宗节点
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x)
    {
        <span style=color:#66d9ef>if</span> (p[x] <span style=color:#f92672>!=</span> x) p[x] <span style=color:#f92672>=</span> find(p[x]);
        <span style=color:#66d9ef>return</span> p[x];
    }

    <span style=color:#75715e>// 初始化，假定节点编号是1~n
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
    {
        p[i] <span style=color:#f92672>=</span> i;
        size[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    }

    <span style=color:#75715e>// 合并a和b所在的两个集合：
</span><span style=color:#75715e></span>    size[find(b)] <span style=color:#f92672>+=</span> size[find(a)];
    p[find(a)] <span style=color:#f92672>=</span> find(b);


<span style=color:#75715e>// (3)维护到祖宗节点距离的并查集：
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>int</span> p[N], d[N];
    <span style=color:#75715e>//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 返回x的祖宗节点
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x)
    {
        <span style=color:#66d9ef>if</span> (p[x] <span style=color:#f92672>!=</span> x)
        {
            <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> find(p[x]);
            d[x] <span style=color:#f92672>+=</span> d[p[x]];
            p[x] <span style=color:#f92672>=</span> u;
        }
        <span style=color:#66d9ef>return</span> p[x];
    }

    <span style=color:#75715e>// 初始化，假定节点编号是1~n
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
    {
        p[i] <span style=color:#f92672>=</span> i;
        d[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    }

    <span style=color:#75715e>// 合并a和b所在的两个集合：
</span><span style=color:#75715e></span>    p[find(a)] <span style=color:#f92672>=</span> find(b);
    d[find(a)] <span style=color:#f92672>=</span> distance; <span style=color:#75715e>// 根据具体问题，初始化find(a)的偏移量
</span></code></pre></div><h3 id=堆>堆
<a class=anchor href=#%e5%a0%86>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
</span><span style=color:#75715e>// ph[k]存储第k个插入的点在堆中的位置
</span><span style=color:#75715e>// hp[k]存储堆中下标是k的点是第几个插入的
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> h[N], ph[N], hp[N], size;

<span style=color:#75715e>// 交换两个点，及其映射关系
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>heap_swap</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>down</span>(<span style=color:#66d9ef>int</span> u)
{
    <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> u;
    <span style=color:#66d9ef>if</span> (u <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&lt;=</span> size <span style=color:#f92672>&amp;&amp;</span> h[u <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;</span> h[t]) t <span style=color:#f92672>=</span> u <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>if</span> (u <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;=</span> size <span style=color:#f92672>&amp;&amp;</span> h[u <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;</span> h[t]) t <span style=color:#f92672>=</span> u <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>if</span> (u <span style=color:#f92672>!=</span> t)
    {
        heap_swap(u, t);
        down(t);
    }
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>up</span>(<span style=color:#66d9ef>int</span> u)
{
    <span style=color:#66d9ef>while</span> (u <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> h[u] <span style=color:#f92672>&lt;</span> h[u <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>])
    {
        heap_swap(u, u <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
        u <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>;
    }
}

<span style=color:#75715e>// O(n)建堆
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>; i; i <span style=color:#f92672>--</span> ) down(i);
</code></pre></div><h3 id=一般哈希>一般哈希
<a class=anchor href=#%e4%b8%80%e8%88%ac%e5%93%88%e5%b8%8c>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// (1) 拉链法
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> h[N], e[N], ne[N], idx;

    <span style=color:#75715e>// 向哈希表中插入一个数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>int</span> x)
    {
        <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> (x <span style=color:#f92672>%</span> N <span style=color:#f92672>+</span> N) <span style=color:#f92672>%</span> N;
        e[idx] <span style=color:#f92672>=</span> x;
        ne[idx] <span style=color:#f92672>=</span> h[k];
        h[k] <span style=color:#f92672>=</span> idx <span style=color:#f92672>++</span> ;
    }

    <span style=color:#75715e>// 在哈希表中查询某个数是否存在
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x)
    {
        <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> (x <span style=color:#f92672>%</span> N <span style=color:#f92672>+</span> N) <span style=color:#f92672>%</span> N;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[k]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
            <span style=color:#66d9ef>if</span> (e[i] <span style=color:#f92672>==</span> x)
                <span style=color:#66d9ef>return</span> true;

        <span style=color:#66d9ef>return</span> false;
    }

<span style=color:#75715e>// (2) 开放寻址法
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> h[N];

    <span style=color:#75715e>// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x)
    {
        <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> (x <span style=color:#f92672>%</span> N <span style=color:#f92672>+</span> N) <span style=color:#f92672>%</span> N;
        <span style=color:#66d9ef>while</span> (h[t] <span style=color:#f92672>!=</span> null <span style=color:#f92672>&amp;&amp;</span> h[t] <span style=color:#f92672>!=</span> x)
        {
            t <span style=color:#f92672>++</span> ;
            <span style=color:#66d9ef>if</span> (t <span style=color:#f92672>==</span> N) t <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        }
        <span style=color:#66d9ef>return</span> t;
    }
</code></pre></div><h3 id=字符串哈希>字符串哈希
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%93%88%e5%b8%8c>#</a></h3><p><code>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ULL;
ULL h[N], p[N]; <span style=color:#75715e>// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 初始化
</span><span style=color:#75715e></span>p[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
{
    h[i] <span style=color:#f92672>=</span> h[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> P <span style=color:#f92672>+</span> str[i];
    p[i] <span style=color:#f92672>=</span> p[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> P;
}

<span style=color:#75715e>// 计算子串 str[l ~ r] 的哈希值
</span><span style=color:#75715e></span>ULL <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r)
{
    <span style=color:#66d9ef>return</span> h[r] <span style=color:#f92672>-</span> h[l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> p[r <span style=color:#f92672>-</span> l <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
}
</code></pre></div><h3 id=c-stl简介>C++ STL简介
<a class=anchor href=#c-stl%e7%ae%80%e4%bb%8b>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>vector, 变长数组，倍增的思想
    size<span style=color:#f92672>()</span>  返回元素个数
    empty<span style=color:#f92672>()</span>  返回是否为空
    clear<span style=color:#f92672>()</span>  清空
    front<span style=color:#f92672>()</span>/back<span style=color:#f92672>()</span>
    push_back<span style=color:#f92672>()</span>/pop_back<span style=color:#f92672>()</span>
    begin<span style=color:#f92672>()</span>/end<span style=color:#f92672>()</span>
    <span style=color:#f92672>[]</span>
    支持比较运算，按字典序

pair&lt;int, int&gt;
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size<span style=color:#f92672>()</span>/length<span style=color:#f92672>()</span>  返回字符串长度
    empty<span style=color:#f92672>()</span>
    clear<span style=color:#f92672>()</span>
    substr<span style=color:#f92672>(</span>起始下标，<span style=color:#f92672>(</span>子串长度<span style=color:#f92672>))</span>  返回子串
    c_str<span style=color:#f92672>()</span>  返回字符串所在字符数组的起始地址

queue, 队列
    size<span style=color:#f92672>()</span>
    empty<span style=color:#f92672>()</span>
    push<span style=color:#f92672>()</span>  向队尾插入一个元素
    front<span style=color:#f92672>()</span>  返回队头元素
    back<span style=color:#f92672>()</span>  返回队尾元素
    pop<span style=color:#f92672>()</span>  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size<span style=color:#f92672>()</span>
    empty<span style=color:#f92672>()</span>
    push<span style=color:#f92672>()</span>  插入一个元素
    top<span style=color:#f92672>()</span>  返回堆顶元素
    pop<span style=color:#f92672>()</span>  弹出堆顶元素
    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;

stack, 栈
    size<span style=color:#f92672>()</span>
    empty<span style=color:#f92672>()</span>
    push<span style=color:#f92672>()</span>  向栈顶插入一个元素
    top<span style=color:#f92672>()</span>  返回栈顶元素
    pop<span style=color:#f92672>()</span>  弹出栈顶元素

deque, 双端队列
    size<span style=color:#f92672>()</span>
    empty<span style=color:#f92672>()</span>
    clear<span style=color:#f92672>()</span>
    front<span style=color:#f92672>()</span>/back<span style=color:#f92672>()</span>
    push_back<span style=color:#f92672>()</span>/pop_back<span style=color:#f92672>()</span>
    push_front<span style=color:#f92672>()</span>/pop_front<span style=color:#f92672>()</span>
    begin<span style=color:#f92672>()</span>/end<span style=color:#f92672>()</span>
    <span style=color:#f92672>[]</span>

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size<span style=color:#f92672>()</span>
    empty<span style=color:#f92672>()</span>
    clear<span style=color:#f92672>()</span>
    begin<span style=color:#f92672>()</span>/end<span style=color:#f92672>()</span>
    ++, -- 返回前驱和后继，时间复杂度 O<span style=color:#f92672>(</span>logn<span style=color:#f92672>)</span>

    set/multiset
        insert<span style=color:#f92672>()</span>  插入一个数
        find<span style=color:#f92672>()</span>  查找一个数
        count<span style=color:#f92672>()</span>  返回某一个数的个数
        erase<span style=color:#f92672>()</span>
            <span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> 输入是一个数x，删除所有x   O<span style=color:#f92672>(</span>k + logn<span style=color:#f92672>)</span>
            <span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> 输入一个迭代器，删除这个迭代器
        lower_bound<span style=color:#f92672>()</span>/upper_bound<span style=color:#f92672>()</span>
            lower_bound<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span>  返回大于等于x的最小的数的迭代器
            upper_bound<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span>  返回大于x的最小的数的迭代器
    map/multimap
        insert<span style=color:#f92672>()</span>  插入的数是一个pair
        erase<span style=color:#f92672>()</span>  输入的参数是pair或者迭代器
        find<span style=color:#f92672>()</span>
        <span style=color:#f92672>[]</span>  注意multimap不支持此操作。 时间复杂度是 O<span style=color:#f92672>(</span>logn<span style=color:#f92672>)</span>
        lower_bound<span style=color:#f92672>()</span>/upper_bound<span style=color:#f92672>()</span>

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
    不支持 lower_bound<span style=color:#f92672>()</span>/upper_bound<span style=color:#f92672>()</span>， 迭代器的++，--

bitset, 圧位
    bitset&lt;10000&gt; s;
    ~, &amp;, |, ^
    &gt;&gt;, &lt;&lt;
    <span style=color:#f92672>==</span>, !<span style=color:#f92672>=</span>
    <span style=color:#f92672>[]</span>

    count<span style=color:#f92672>()</span>  返回有多少个1

    any<span style=color:#f92672>()</span>  判断是否至少有一个1
    none<span style=color:#f92672>()</span>  判断是否全为0

    set<span style=color:#f92672>()</span>  把所有位置成1
    set<span style=color:#f92672>(</span>k, v<span style=color:#f92672>)</span>  将第k位变成v
    reset<span style=color:#f92672>()</span>  把所有位变成0
    flip<span style=color:#f92672>()</span>  等价于~
    flip<span style=color:#f92672>(</span>k<span style=color:#f92672>)</span> 把第k位取反
</code></pre></div><h3 id=树与图的存储>树与图的存储
<a class=anchor href=#%e6%a0%91%e4%b8%8e%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8>#</a></h3><p>树是一种特殊的图，与图的存储方式相同。</p><p>对于无向图中的边ab，存储两条有向边a->b, b->a。</p><p>因此我们可以只考虑有向图的存储。</p><p>(1) 邻接矩阵：g[a][b] 存储边a->b</p><p>(2) 邻接表：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> h[N], e[N], ne[N], idx;

<span style=color:#75715e>// 添加一条边a-&gt;b
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
{
    e[idx] <span style=color:#f92672>=</span> b, ne[idx] <span style=color:#f92672>=</span> h[a], h[a] <span style=color:#f92672>=</span> idx <span style=color:#f92672>++</span> ;
}

<span style=color:#75715e>// 初始化
</span><span style=color:#75715e></span>idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
memset(h, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span> h);
</code></pre></div><h3 id=树与图的遍历>树与图的遍历
<a class=anchor href=#%e6%a0%91%e4%b8%8e%e5%9b%be%e7%9a%84%e9%81%8d%e5%8e%86>#</a></h3><p>时间复杂度 O(n + m), n 表示点数，m 表示边数</p><p>(1) 深度优先遍历</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> u)
{
    st[u] <span style=color:#f92672>=</span> true; <span style=color:#75715e>// st[u] 表示点u已经被遍历过
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[u]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
    {
        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[j]) dfs(j);
    }
}
</code></pre></div><p>(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
st[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true; <span style=color:#75715e>// 表示1号点已经被遍历过
</span><span style=color:#75715e></span>q.push(<span style=color:#ae81ff>1</span>);

<span style=color:#66d9ef>while</span> (q.size())
{
   <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> q.front();
   q.pop();

   <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[t]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
   {
       <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
       <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>s[j])
       {
           st[j] <span style=color:#f92672>=</span> true; <span style=color:#75715e>// 表示点j已经被遍历过
</span><span style=color:#75715e></span>           q.push(j);
       }
   }
}
</code></pre></div><h3 id=拓扑排序>拓扑排序
<a class=anchor href=#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f>#</a></h3><p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>topsort</span>()
{
    <span style=color:#66d9ef>int</span> hh <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, tt <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
 
    <span style=color:#75715e>// d[i] 存储点i的入度
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>d[i])
            q[ <span style=color:#f92672>++</span> tt] <span style=color:#f92672>=</span> i;
 
    <span style=color:#66d9ef>while</span> (hh <span style=color:#f92672>&lt;=</span> tt)
    {
        <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> q[hh <span style=color:#f92672>++</span> ];
 
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[t]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
        {
            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--</span> d[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
                q[ <span style=color:#f92672>++</span> tt] <span style=color:#f92672>=</span> j;
        }
    }
 
    <span style=color:#75715e>// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> tt <span style=color:#f92672>==</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></div><h3 id=朴素dijkstra算法>朴素dijkstra算法
<a class=anchor href=#%e6%9c%b4%e7%b4%a0dijkstra%e7%ae%97%e6%b3%95>#</a></h3><p>时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> g[N][N];  <span style=color:#75715e>// 存储每条边
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dist[N];  <span style=color:#75715e>// 存储1号点到每个点的最短距离
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];   <span style=color:#75715e>// 存储每个点的最短路是否已经确定
</span><span style=color:#75715e></span> 
<span style=color:#75715e>// 求1号点到n号点的最短路，如果不存在则返回-1
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dijkstra</span>()
{
    memset(dist, <span style=color:#ae81ff>0x3f</span>, <span style=color:#66d9ef>sizeof</span> dist);
    dist[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
 
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;     <span style=color:#75715e>// 在还未确定最短路的点中，寻找距离最小的点
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>++</span> )
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[j] <span style=color:#f92672>&amp;&amp;</span> (t <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> dist[t] <span style=color:#f92672>&gt;</span> dist[j]))
                t <span style=color:#f92672>=</span> j;
 
        <span style=color:#75715e>// 用t更新其他点的距离
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>++</span> )
            dist[j] <span style=color:#f92672>=</span> min(dist[j], dist[t] <span style=color:#f92672>+</span> g[t][j]);
 
        st[t] <span style=color:#f92672>=</span> true;
    }
 
    <span style=color:#66d9ef>if</span> (dist[n] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x3f3f3f3f</span>) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>return</span> dist[n];
}
</code></pre></div><h3 id=堆优化版dijkstra>堆优化版dijkstra
<a class=anchor href=#%e5%a0%86%e4%bc%98%e5%8c%96%e7%89%88dijkstra>#</a></h3><p>时间复杂度 O(m logn), n 表示点数，m 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>typedef</span> pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> PII;
 
<span style=color:#66d9ef>int</span> n;      <span style=color:#75715e>// 点的数量
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> h[N], w[N], e[N], ne[N], idx;       <span style=color:#75715e>// 邻接表存储所有边
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dist[N];        <span style=color:#75715e>// 存储所有点到1号点的距离
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];     <span style=color:#75715e>// 存储每个点的最短距离是否已确定
</span><span style=color:#75715e></span> 
<span style=color:#75715e>// 求1号点到n号点的最短距离，如果不存在，则返回-1
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dijkstra</span>()
{
    memset(dist, <span style=color:#ae81ff>0x3f</span>, <span style=color:#66d9ef>sizeof</span> dist);
    dist[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    priority_queue<span style=color:#f92672>&lt;</span>PII, vector<span style=color:#f92672>&lt;</span>PII<span style=color:#f92672>&gt;</span>, greater<span style=color:#f92672>&lt;</span>PII<span style=color:#f92672>&gt;&gt;</span> heap;
    heap.push({<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>});      <span style=color:#75715e>// first存储距离，second存储节点编号
</span><span style=color:#75715e></span> 
    <span style=color:#66d9ef>while</span> (heap.size())
    {
        <span style=color:#66d9ef>auto</span> t <span style=color:#f92672>=</span> heap.top();
        heap.pop();
 
        <span style=color:#66d9ef>int</span> ver <span style=color:#f92672>=</span> t.second, distance <span style=color:#f92672>=</span> t.first;
 
        <span style=color:#66d9ef>if</span> (st[ver]) <span style=color:#66d9ef>continue</span>;
        st[ver] <span style=color:#f92672>=</span> true;
 
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[ver]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
        {
            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
            <span style=color:#66d9ef>if</span> (dist[j] <span style=color:#f92672>&gt;</span> distance <span style=color:#f92672>+</span> w[i])
            {
                dist[j] <span style=color:#f92672>=</span> distance <span style=color:#f92672>+</span> w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    <span style=color:#66d9ef>if</span> (dist[n] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x3f3f3f3f</span>) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>return</span> dist[n];
}
</code></pre></div><h3 id=bellman-ford算法>Bellman-Ford算法
<a class=anchor href=#bellman-ford%e7%ae%97%e6%b3%95>#</a></h3><p>时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数</p><p>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> n, m;       <span style=color:#75715e>// n表示点数，m表示边数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dist[N];        <span style=color:#75715e>// dist[x]存储1到x的最短路距离
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Edge</span>     <span style=color:#75715e>// 边，a表示出点，b表示入点，w表示边的权重
</span><span style=color:#75715e></span>{
   <span style=color:#66d9ef>int</span> a, b, w;
}edges[M];

<span style=color:#75715e>// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>bellman_ford</span>()
{
   memset(dist, <span style=color:#ae81ff>0x3f</span>, <span style=color:#66d9ef>sizeof</span> dist);
   dist[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

   <span style=color:#75715e>// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span> )
   {
       <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> m; j <span style=color:#f92672>++</span> )
       {
           <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> edges[j].a, b <span style=color:#f92672>=</span> edges[j].b, w <span style=color:#f92672>=</span> edges[j].w;
           <span style=color:#66d9ef>if</span> (dist[b] <span style=color:#f92672>&gt;</span> dist[a] <span style=color:#f92672>+</span> w)
               dist[b] <span style=color:#f92672>=</span> dist[a] <span style=color:#f92672>+</span> w;
       }
   }

   <span style=color:#66d9ef>if</span> (dist[n] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0x3f3f3f3f</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
   <span style=color:#66d9ef>return</span> dist[n];
}
</code></pre></div><h3 id=spfa-算法队列优化的bellman-ford算法>spfa 算法（队列优化的Bellman-Ford算法）
<a class=anchor href=#spfa-%e7%ae%97%e6%b3%95%e9%98%9f%e5%88%97%e4%bc%98%e5%8c%96%e7%9a%84bellman-ford%e7%ae%97%e6%b3%95>#</a></h3><p>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> n;      <span style=color:#75715e>// 总点数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> h[N], w[N], e[N], ne[N], idx;       <span style=color:#75715e>// 邻接表存储所有边
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dist[N];        <span style=color:#75715e>// 存储每个点到1号点的最短距离
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];     <span style=color:#75715e>// 存储每个点是否在队列中
</span><span style=color:#75715e></span> 
<span style=color:#75715e>// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>spfa</span>()
{
    memset(dist, <span style=color:#ae81ff>0x3f</span>, <span style=color:#66d9ef>sizeof</span> dist);
    dist[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
 
    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
    q.push(<span style=color:#ae81ff>1</span>);
    st[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
 
    <span style=color:#66d9ef>while</span> (q.size())
    {
        <span style=color:#66d9ef>auto</span> t <span style=color:#f92672>=</span> q.front();
        q.pop();
 
        st[t] <span style=color:#f92672>=</span> false;
 
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[t]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
        {
            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
            <span style=color:#66d9ef>if</span> (dist[j] <span style=color:#f92672>&gt;</span> dist[t] <span style=color:#f92672>+</span> w[i])
            {
                dist[j] <span style=color:#f92672>=</span> dist[t] <span style=color:#f92672>+</span> w[i];
                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[j])     <span style=color:#75715e>// 如果队列中已存在j，则不需要将j重复插入
</span><span style=color:#75715e></span>                {
                    q.push(j);
                    st[j] <span style=color:#f92672>=</span> true;
                }
            }
        }
    }
 
    <span style=color:#66d9ef>if</span> (dist[n] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x3f3f3f3f</span>) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>return</span> dist[n];
}
</code></pre></div><h3 id=spfa判断图中是否存在负环>spfa判断图中是否存在负环
<a class=anchor href=#spfa%e5%88%a4%e6%96%ad%e5%9b%be%e4%b8%ad%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e8%b4%9f%e7%8e%af>#</a></h3><p>时间复杂度是 O(nm), n 表示点数，m 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> n;      <span style=color:#75715e>// 总点数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> h[N], w[N], e[N], ne[N], idx;       <span style=color:#75715e>// 邻接表存储所有边
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dist[N], cnt[N];        <span style=color:#75715e>// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];     <span style=color:#75715e>// 存储每个点是否在队列中
</span><span style=color:#75715e></span> 
<span style=color:#75715e>// 如果存在负环，则返回true，否则返回false。
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>spfa</span>()
{
    <span style=color:#75715e>// 不需要初始化dist数组
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
</span><span style=color:#75715e></span> 
    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
    {
        q.push(i);
        st[i] <span style=color:#f92672>=</span> true;
    }
 
    <span style=color:#66d9ef>while</span> (q.size())
    {
        <span style=color:#66d9ef>auto</span> t <span style=color:#f92672>=</span> q.front();
        q.pop();
 
        st[t] <span style=color:#f92672>=</span> false;
 
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[t]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
        {
            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
            <span style=color:#66d9ef>if</span> (dist[j] <span style=color:#f92672>&gt;</span> dist[t] <span style=color:#f92672>+</span> w[i])
            {
                dist[j] <span style=color:#f92672>=</span> dist[t] <span style=color:#f92672>+</span> w[i];
                cnt[j] <span style=color:#f92672>=</span> cnt[t] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
                <span style=color:#66d9ef>if</span> (cnt[j] <span style=color:#f92672>&gt;=</span> n) <span style=color:#66d9ef>return</span> true;       <span style=color:#75715e>// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[j])
                {
                    q.push(j);
                    st[j] <span style=color:#f92672>=</span> true;
                }
            }
        }
    }
 
    <span style=color:#66d9ef>return</span> false;
}
</code></pre></div><h3 id=floyd算法>floyd算法
<a class=anchor href=#floyd%e7%ae%97%e6%b3%95>#</a></h3><p>时间复杂度是 O(n3), n 表示点数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#960050;background-color:#1e0010>初始化：</span>
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>++</span> )
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> j) d[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            <span style=color:#66d9ef>else</span> d[i][j] <span style=color:#f92672>=</span> INF;
 
<span style=color:#75715e>// 算法结束后，d[a][b]表示a到b的最短距离
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>floyd</span>()
{
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> n; k <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>++</span> )
                d[i][j] <span style=color:#f92672>=</span> min(d[i][j], d[i][k] <span style=color:#f92672>+</span> d[k][j]);
}
</code></pre></div><h3 id=朴素版prim算法>朴素版prim算法
<a class=anchor href=#%e6%9c%b4%e7%b4%a0%e7%89%88prim%e7%ae%97%e6%b3%95>#</a></h3><p>时间复杂度是 O(n^2 + m), n 表示点数，m 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> n;      <span style=color:#75715e>// n表示点数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> g[N][N];        <span style=color:#75715e>// 邻接矩阵，存储所有边
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dist[N];        <span style=color:#75715e>// 存储其他点到当前最小生成树的距离
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];     <span style=color:#75715e>// 存储每个点是否已经在生成树中
</span><span style=color:#75715e></span> 
 
<span style=color:#75715e>// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>prim</span>()
{
    memset(dist, <span style=color:#ae81ff>0x3f</span>, <span style=color:#66d9ef>sizeof</span> dist);
 
    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>++</span> )
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[j] <span style=color:#f92672>&amp;&amp;</span> (t <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> dist[t] <span style=color:#f92672>&gt;</span> dist[j]))
                t <span style=color:#f92672>=</span> j;
 
        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&amp;&amp;</span> dist[t] <span style=color:#f92672>==</span> INF) <span style=color:#66d9ef>return</span> INF;
 
        <span style=color:#66d9ef>if</span> (i) res <span style=color:#f92672>+=</span> dist[t];
        st[t] <span style=color:#f92672>=</span> true;
 
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>++</span> ) dist[j] <span style=color:#f92672>=</span> min(dist[j], g[t][j]);
    }
 
    <span style=color:#66d9ef>return</span> res;
}
</code></pre></div><h3 id=kruskal算法>Kruskal算法
<a class=anchor href=#kruskal%e7%ae%97%e6%b3%95>#</a></h3><p>时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> n, m;       <span style=color:#75715e>// n是点数，m是边数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> p[N];       <span style=color:#75715e>// 并查集的父节点数组
</span><span style=color:#75715e></span> 
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Edge</span>     <span style=color:#75715e>// 存储边
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>int</span> a, b, w;
 
    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>const</span> Edge <span style=color:#f92672>&amp;</span>W)<span style=color:#66d9ef>const</span>
    {
        <span style=color:#66d9ef>return</span> w <span style=color:#f92672>&lt;</span> W.w;
    }
}edges[M];
 
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x)     <span style=color:#75715e>// 并查集核心操作
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>if</span> (p[x] <span style=color:#f92672>!=</span> x) p[x] <span style=color:#f92672>=</span> find(p[x]);
    <span style=color:#66d9ef>return</span> p[x];
}
 
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>kruskal</span>()
{
    sort(edges, edges <span style=color:#f92672>+</span> m);
 
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> ) p[i] <span style=color:#f92672>=</span> i;    <span style=color:#75715e>// 初始化并查集
</span><span style=color:#75715e></span> 
    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> edges[i].a, b <span style=color:#f92672>=</span> edges[i].b, w <span style=color:#f92672>=</span> edges[i].w;
 
        a <span style=color:#f92672>=</span> find(a), b <span style=color:#f92672>=</span> find(b);
        <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>!=</span> b)     <span style=color:#75715e>// 如果两个连通块不连通，则将这两个连通块合并
</span><span style=color:#75715e></span>        {
            p[a] <span style=color:#f92672>=</span> b;
            res <span style=color:#f92672>+=</span> w;
            cnt <span style=color:#f92672>++</span> ;
        }
    }
 
    <span style=color:#66d9ef>if</span> (cnt <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> INF;
    <span style=color:#66d9ef>return</span> res;
}
</code></pre></div><h3 id=染色法判别二分图>染色法判别二分图
<a class=anchor href=#%e6%9f%93%e8%89%b2%e6%b3%95%e5%88%a4%e5%88%ab%e4%ba%8c%e5%88%86%e5%9b%be>#</a></h3><p>时间复杂度是 O(n+m), n 表示点数，m 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> n;      <span style=color:#75715e>// n表示点数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> h[N], e[M], ne[M], idx;     <span style=color:#75715e>// 邻接表存储图
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> color[N];       <span style=color:#75715e>// 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色
</span><span style=color:#75715e></span> 
<span style=color:#75715e>// 参数：u表示当前节点，c表示当前点的颜色
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> c)
{
    color[u] <span style=color:#f92672>=</span> c;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[u]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
    {
        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
        <span style=color:#66d9ef>if</span> (color[j] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
        {
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>dfs(j, <span style=color:#f92672>!</span>c)) <span style=color:#66d9ef>return</span> false;
        }
        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (color[j] <span style=color:#f92672>==</span> c) <span style=color:#66d9ef>return</span> false;
    }
 
    <span style=color:#66d9ef>return</span> true;
}
 
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>()
{
    memset(color, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span> color);
    <span style=color:#66d9ef>bool</span> flag <span style=color:#f92672>=</span> true;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>if</span> (color[i] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>dfs(i, <span style=color:#ae81ff>0</span>))
            {
                flag <span style=color:#f92672>=</span> false;
                <span style=color:#66d9ef>break</span>;
            }
    <span style=color:#66d9ef>return</span> flag;
}
</code></pre></div><h3 id=匈牙利算法>匈牙利算法
<a class=anchor href=#%e5%8c%88%e7%89%99%e5%88%a9%e7%ae%97%e6%b3%95>#</a></h3><p>时间复杂度是 O(nm), n 表示点数，m 表示边数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> n1, n2;     <span style=color:#75715e>// n1表示第一个集合中的点数，n2表示第二个集合中的点数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> h[N], e[M], ne[M], idx;     <span style=color:#75715e>// 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> match[N];       <span style=color:#75715e>// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];     <span style=color:#75715e>// 表示第二个集合中的每个点是否已经被遍历过
</span><span style=color:#75715e></span> 
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> x)
{
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h[x]; i <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>=</span> ne[i])
    {
        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> e[i];
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[j])
        {
            st[j] <span style=color:#f92672>=</span> true;
            <span style=color:#66d9ef>if</span> (match[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> find(match[j]))
            {
                match[j] <span style=color:#f92672>=</span> x;
                <span style=color:#66d9ef>return</span> true;
            }
        }
    }
 
    <span style=color:#66d9ef>return</span> false;
}
 
<span style=color:#75715e>// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n1; i <span style=color:#f92672>++</span> )
{
    memset(st, false, <span style=color:#66d9ef>sizeof</span> st);
    <span style=color:#66d9ef>if</span> (find(i)) res <span style=color:#f92672>++</span> ;
}
</code></pre></div><h3 id=试除法判定质数>试除法判定质数
<a class=anchor href=#%e8%af%95%e9%99%a4%e6%b3%95%e5%88%a4%e5%ae%9a%e8%b4%a8%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>is_prime</span>(<span style=color:#66d9ef>int</span> x)
{
    <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span> false;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>/</span> i; i <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> false;
    <span style=color:#66d9ef>return</span> true;
}
</code></pre></div><h3 id=试除法分解质因数>试除法分解质因数
<a class=anchor href=#%e8%af%95%e9%99%a4%e6%b3%95%e5%88%86%e8%a7%a3%e8%b4%a8%e5%9b%a0%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>divide</span>(<span style=color:#66d9ef>int</span> x)
{
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>/</span> i; i <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
        {
            <span style=color:#66d9ef>int</span> s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            <span style=color:#66d9ef>while</span> (x <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) x <span style=color:#f92672>/=</span> i, s <span style=color:#f92672>++</span> ;
            cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> s <span style=color:#f92672>&lt;&lt;</span> endl;
        }
    <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    cout <span style=color:#f92672>&lt;&lt;</span> endl;
}
</code></pre></div><h3 id=朴素筛法求素数>朴素筛法求素数
<a class=anchor href=#%e6%9c%b4%e7%b4%a0%e7%ad%9b%e6%b3%95%e6%b1%82%e7%b4%a0%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> primes[N], cnt;     <span style=color:#75715e>// primes[]存储所有素数
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];         <span style=color:#75715e>// st[x]存储x是否被筛掉
</span><span style=color:#75715e></span> 
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>get_primes</span>(<span style=color:#66d9ef>int</span> n)
{
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>if</span> (st[i]) <span style=color:#66d9ef>continue</span>;
        primes[cnt <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> i;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>+=</span> i)
            st[j] <span style=color:#f92672>=</span> true;
    }
}
</code></pre></div><h3 id=线性筛法求素数>线性筛法求素数
<a class=anchor href=#%e7%ba%bf%e6%80%a7%e7%ad%9b%e6%b3%95%e6%b1%82%e7%b4%a0%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> primes[N], cnt;     <span style=color:#75715e>// primes[]存储所有素数
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];         <span style=color:#75715e>// st[x]存储x是否被筛掉
</span><span style=color:#75715e></span> 
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>get_primes</span>(<span style=color:#66d9ef>int</span> n)
{
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[i]) primes[cnt <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> i;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; primes[j] <span style=color:#f92672>&lt;=</span> n <span style=color:#f92672>/</span> i; j <span style=color:#f92672>++</span> )
        {
            st[primes[j] <span style=color:#f92672>*</span> i] <span style=color:#f92672>=</span> true;
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>;
        }
    }
}
</code></pre></div><h3 id=试除法求所有约数>试除法求所有约数
<a class=anchor href=#%e8%af%95%e9%99%a4%e6%b3%95%e6%b1%82%e6%89%80%e6%9c%89%e7%ba%a6%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> get_divisors(<span style=color:#66d9ef>int</span> x)
{
    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>/</span> i; i <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
        {
            res.push_back(i);
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> x <span style=color:#f92672>/</span> i) res.push_back(x <span style=color:#f92672>/</span> i);
        }
    sort(res.begin(), res.end());
    <span style=color:#66d9ef>return</span> res;
}
</code></pre></div><h3 id=约数个数和约数之和>约数个数和约数之和
<a class=anchor href=#%e7%ba%a6%e6%95%b0%e4%b8%aa%e6%95%b0%e5%92%8c%e7%ba%a6%e6%95%b0%e4%b9%8b%e5%92%8c>#</a></h3><pre><code>如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
</code></pre><h3 id=欧几里得算法>欧几里得算法
<a class=anchor href=#%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>gcd</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
{
    <span style=color:#66d9ef>return</span> b <span style=color:#f92672>?</span> gcd(b, a <span style=color:#f92672>%</span> b) <span style=color:#f92672>:</span> a;
}
</code></pre></div><h3 id=求欧拉函数>求欧拉函数
<a class=anchor href=#%e6%b1%82%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>phi</span>(<span style=color:#66d9ef>int</span> x)
{
    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> x;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>/</span> i; i <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
        {
            res <span style=color:#f92672>=</span> res <span style=color:#f92672>/</span> i <span style=color:#f92672>*</span> (i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
            <span style=color:#66d9ef>while</span> (x <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) x <span style=color:#f92672>/=</span> i;
        }
    <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) res <span style=color:#f92672>=</span> res <span style=color:#f92672>/</span> x <span style=color:#f92672>*</span> (x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
 
    <span style=color:#66d9ef>return</span> res;
}
</code></pre></div><h3 id=筛法求欧拉函数>筛法求欧拉函数
<a class=anchor href=#%e7%ad%9b%e6%b3%95%e6%b1%82%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> primes[N], cnt;     <span style=color:#75715e>// primes[]存储所有素数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> euler[N];           <span style=color:#75715e>// 存储每个数的欧拉函数
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];         <span style=color:#75715e>// st[x]存储x是否被筛掉
</span><span style=color:#75715e></span> 
 
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>get_eulers</span>(<span style=color:#66d9ef>int</span> n)
{
    euler[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[i])
        {
            primes[cnt <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> i;
            euler[i] <span style=color:#f92672>=</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
        }
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; primes[j] <span style=color:#f92672>&lt;=</span> n <span style=color:#f92672>/</span> i; j <span style=color:#f92672>++</span> )
        {
            <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> primes[j] <span style=color:#f92672>*</span> i;
            st[t] <span style=color:#f92672>=</span> true;
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            {
                euler[t] <span style=color:#f92672>=</span> euler[i] <span style=color:#f92672>*</span> primes[j];
                <span style=color:#66d9ef>break</span>;
            }
            euler[t] <span style=color:#f92672>=</span> euler[i] <span style=color:#f92672>*</span> (primes[j] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
        }
    }
}
</code></pre></div><h3 id=快速幂>快速幂
<a class=anchor href=#%e5%bf%ab%e9%80%9f%e5%b9%82>#</a></h3><p>求 m^k mod p，时间复杂度 O(logk)。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>qmi</span>(<span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> k, <span style=color:#66d9ef>int</span> p)
{
    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>%</span> p, t <span style=color:#f92672>=</span> m;
    <span style=color:#66d9ef>while</span> (k)
    {
        <span style=color:#66d9ef>if</span> (k<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>) res <span style=color:#f92672>=</span> res <span style=color:#f92672>*</span> t <span style=color:#f92672>%</span> p;
        t <span style=color:#f92672>=</span> t <span style=color:#f92672>*</span> t <span style=color:#f92672>%</span> p;
        k <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>;
    }
    <span style=color:#66d9ef>return</span> res;
}
</code></pre></div><h3 id=扩展欧几里得算法>扩展欧几里得算法
<a class=anchor href=#%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95>#</a></h3><p>// 求x, y，使得ax + by = gcd(a, b)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>exgcd</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>x, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>y)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>b)
    {
        x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>return</span> a;
    }
    <span style=color:#66d9ef>int</span> d <span style=color:#f92672>=</span> exgcd(b, a <span style=color:#f92672>%</span> b, y, x);
    y <span style=color:#f92672>-=</span> (a<span style=color:#f92672>/</span>b) <span style=color:#f92672>*</span> x;
    <span style=color:#66d9ef>return</span> d;
}
</code></pre></div><h3 id=高斯消元>高斯消元
<a class=anchor href=#%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// a[N][N]是增广矩阵
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>gauss</span>()
{
    <span style=color:#66d9ef>int</span> c, r;
    <span style=color:#66d9ef>for</span> (c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; c <span style=color:#f92672>&lt;</span> n; c <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> r;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> r; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span> )   <span style=color:#75715e>// 找到绝对值最大的行
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (fabs(a[i][c]) <span style=color:#f92672>&gt;</span> fabs(a[t][c]))
                t <span style=color:#f92672>=</span> i;
 
        <span style=color:#66d9ef>if</span> (fabs(a[t][c]) <span style=color:#f92672>&lt;</span> eps) <span style=color:#66d9ef>continue</span>;
 
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> c; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> ) swap(a[t][i], a[r][i]);      <span style=color:#75715e>// 将绝对值最大的行换到最顶端
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> n; i <span style=color:#f92672>&gt;=</span> c; i <span style=color:#f92672>--</span> ) a[r][i] <span style=color:#f92672>/=</span> a[r][c];      <span style=color:#75715e>// 将当前上的首位变成1
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span> )       <span style=color:#75715e>// 用当前行将下面所有的列消成0
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (fabs(a[i][c]) <span style=color:#f92672>&gt;</span> eps)
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> n; j <span style=color:#f92672>&gt;=</span> c; j <span style=color:#f92672>--</span> )
                    a[i][j] <span style=color:#f92672>-=</span> a[r][j] <span style=color:#f92672>*</span> a[i][c];
 
        r <span style=color:#f92672>++</span> ;
    }
 
    <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&lt;</span> n)
    {
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> r; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span> )
            <span style=color:#66d9ef>if</span> (fabs(a[i][n]) <span style=color:#f92672>&gt;</span> eps)
                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// 无解
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 有无穷多组解
</span><span style=color:#75715e></span>    }
 
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>--</span> )
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; j <span style=color:#f92672>++</span> )
            a[i][n] <span style=color:#f92672>-=</span> a[i][j] <span style=color:#f92672>*</span> a[j][n];
 
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 有唯一解
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=递归法求组合数>递归法求组合数
<a class=anchor href=#%e9%80%92%e5%bd%92%e6%b3%95%e6%b1%82%e7%bb%84%e5%90%88%e6%95%b0>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// c[a][b] 表示从a个苹果中选b个的方案数
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; i <span style=color:#f92672>++</span> )
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;=</span> i; j <span style=color:#f92672>++</span> )
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>j) c[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>else</span> c[i][j] <span style=color:#f92672>=</span> (c[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> c[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>%</span> mod;
</code></pre></div><h3 id=通过预处理逆元的方式求组合数>通过预处理逆元的方式求组合数
<a class=anchor href=#%e9%80%9a%e8%bf%87%e9%a2%84%e5%a4%84%e7%90%86%e9%80%86%e5%85%83%e7%9a%84%e6%96%b9%e5%bc%8f%e6%b1%82%e7%bb%84%e5%90%88%e6%95%b0>#</a></h3><pre><code>首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)    // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k &amp; 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k &gt;&gt;= 1;
    }
    return res;
}
 
// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i &lt; N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
</code></pre><h3 id=lucas定理>Lucas定理
<a class=anchor href=#lucas%e5%ae%9a%e7%90%86>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#960050;background-color:#1e0010>若</span>p是质数<span style=color:#960050;background-color:#1e0010>，则对于任意整数</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;=</span> m <span style=color:#f92672>&lt;=</span> n<span style=color:#960050;background-color:#1e0010>，有：</span>
    C(n, m) <span style=color:#f92672>=</span> C(n <span style=color:#f92672>%</span> p, m <span style=color:#f92672>%</span> p) <span style=color:#f92672>*</span> C(n <span style=color:#f92672>/</span> p, m <span style=color:#f92672>/</span> p) (mod p)
 
<span style=color:#66d9ef>int</span> qmi(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> k)       <span style=color:#75715e>// 快速幂模板
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>while</span> (k)
    {
        <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) res <span style=color:#f92672>=</span> (LL)res <span style=color:#f92672>*</span> a <span style=color:#f92672>%</span> p;
        a <span style=color:#f92672>=</span> (LL)a <span style=color:#f92672>*</span> a <span style=color:#f92672>%</span> p;
        k <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>;
    }
    <span style=color:#66d9ef>return</span> res;
}
 
 
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>C</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)     <span style=color:#75715e>// 通过定理求组合数C(a, b)
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> a; i <span style=color:#f92672>&lt;=</span> b; i <span style=color:#f92672>++</span>, j <span style=color:#f92672>--</span> )
    {
        res <span style=color:#f92672>=</span> (LL)res <span style=color:#f92672>*</span> j <span style=color:#f92672>%</span> p;
        res <span style=color:#f92672>=</span> (LL)res <span style=color:#f92672>*</span> qmi(i, p <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>%</span> p;
    }
    <span style=color:#66d9ef>return</span> res;
}
 
 
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lucas</span>(LL a, LL b)
{
    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&lt;</span> p <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> p) <span style=color:#66d9ef>return</span> C(a, b);
    <span style=color:#66d9ef>return</span> (LL)C(a <span style=color:#f92672>%</span> p, b <span style=color:#f92672>%</span> p) <span style=color:#f92672>*</span> lucas(a <span style=color:#f92672>/</span> p, b <span style=color:#f92672>/</span> p) <span style=color:#f92672>%</span> p;
}
</code></pre></div><h3 id=分解质因数法求组合数>分解质因数法求组合数
<a class=anchor href=#%e5%88%86%e8%a7%a3%e8%b4%a8%e5%9b%a0%e6%95%b0%e6%b3%95%e6%b1%82%e7%bb%84%e5%90%88%e6%95%b0>#</a></h3><pre><code>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
    1. 筛法求出范围内的所有质数
    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
    3. 用高精度乘法将所有质因子相乘
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> primes[N], cnt;     <span style=color:#75715e>// 存储所有质数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> sum[N];     <span style=color:#75715e>// 存储每个质数的次数
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> st[N];     <span style=color:#75715e>// 存储每个数是否已被筛掉
</span><span style=color:#75715e></span> 
 
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>get_primes</span>(<span style=color:#66d9ef>int</span> n)      <span style=color:#75715e>// 线性筛法求素数
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>++</span> )
    {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>st[i]) primes[cnt <span style=color:#f92672>++</span> ] <span style=color:#f92672>=</span> i;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; primes[j] <span style=color:#f92672>&lt;=</span> n <span style=color:#f92672>/</span> i; j <span style=color:#f92672>++</span> )
        {
            st[primes[j] <span style=color:#f92672>*</span> i] <span style=color:#f92672>=</span> true;
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>;
        }
    }
}
 
 
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> p)       <span style=color:#75715e>// 求n！中的次数
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>while</span> (n)
    {
        res <span style=color:#f92672>+=</span> n <span style=color:#f92672>/</span> p;
        n <span style=color:#f92672>/=</span> p;
    }
    <span style=color:#66d9ef>return</span> res;
}
 
 
vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> mul(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> a, <span style=color:#66d9ef>int</span> b)       <span style=color:#75715e>// 高精度乘低精度模板
</span><span style=color:#75715e></span>{
    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> c;
    <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> a.size(); i <span style=color:#f92672>++</span> )
    {
        t <span style=color:#f92672>+=</span> a[i] <span style=color:#f92672>*</span> b;
        c.push_back(t <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>);
        t <span style=color:#f92672>/=</span> <span style=color:#ae81ff>10</span>;
    }
 
    <span style=color:#66d9ef>while</span> (t)
    {
        c.push_back(t <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>);
        t <span style=color:#f92672>/=</span> <span style=color:#ae81ff>10</span>;
    }
 
    <span style=color:#66d9ef>return</span> c;
}
 
get_primes(a);  <span style=color:#75715e>// 预处理范围内的所有质数
</span><span style=color:#75715e></span> 
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> cnt; i <span style=color:#f92672>++</span> )     <span style=color:#75715e>// 求每个质因数的次数
</span><span style=color:#75715e></span>{
    <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> primes[i];
    sum[i] <span style=color:#f92672>=</span> get(a, p) <span style=color:#f92672>-</span> get(b, p) <span style=color:#f92672>-</span> get(a <span style=color:#f92672>-</span> b, p);
}
 
vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
res.push_back(<span style=color:#ae81ff>1</span>);
 
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> cnt; i <span style=color:#f92672>++</span> )     <span style=color:#75715e>// 用高精度乘法将所有质因子相乘
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> sum[i]; j <span style=color:#f92672>++</span> )
        res <span style=color:#f92672>=</span> mul(res, primes[i]);
</code></pre></div><h3 id=卡特兰数>卡特兰数
<a class=anchor href=#%e5%8d%a1%e7%89%b9%e5%85%b0%e6%95%b0>#</a></h3><pre><code>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)
</code></pre><h3 id=nim游戏>NIM游戏
<a class=anchor href=#nim%e6%b8%b8%e6%88%8f>#</a></h3><pre><code>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。
 
我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。
所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。
NIM博弈不存在平局，只有先手必胜和先手必败两种情况。
 
定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0
</code></pre><h3 id=公平组合游戏icg>公平组合游戏ICG
<a class=anchor href=#%e5%85%ac%e5%b9%b3%e7%bb%84%e5%90%88%e6%b8%b8%e6%88%8ficg>#</a></h3><pre><code>若一个游戏满足：
 
由两名玩家交替行动；
在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；
不能行动的玩家判负；
则称该游戏为一个公平组合游戏。
NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。
</code></pre><h3 id=有向图游戏>有向图游戏
<a class=anchor href=#%e6%9c%89%e5%90%91%e5%9b%be%e6%b8%b8%e6%88%8f>#</a></h3><pre><code>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。
</code></pre><h3 id=mex运算>Mex运算
<a class=anchor href=#mex%e8%bf%90%e7%ae%97>#</a></h3><pre><code>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S
</code></pre><h3 id=sg函数>SG函数
<a class=anchor href=#sg%e5%87%bd%e6%95%b0>#</a></h3><pre><code>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：
SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})
特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。
</code></pre><h3 id=有向图游戏的和>有向图游戏的和
<a class=anchor href=#%e6%9c%89%e5%90%91%e5%9b%be%e6%b8%b8%e6%88%8f%e7%9a%84%e5%92%8c>#</a></h3><pre><code>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：
SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)
 
定理
有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。
</code></pre><h3 id=树状数组模板>树状数组模板
<a class=anchor href=#%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e6%a8%a1%e6%9d%bf>#</a></h3><blockquote><p><a href=https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-fenjue-ewfb/>解析</a>
<a href=https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/>模板</a></p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 上来先把三个方法写出来
</span><span style=color:#75715e></span><span style=color:#f92672>{</span>
    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> tree<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lowbit</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> x<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> x <span style=color:#f92672>&amp;</span> <span style=color:#f92672>-</span>x<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>// 查询前缀和的方法
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> x<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> x<span style=color:#f92672>;</span> i <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>-=</span> lowbit<span style=color:#f92672>(</span>i<span style=color:#f92672>))</span> ans <span style=color:#f92672>+=</span> tree<span style=color:#f92672>[</span>i<span style=color:#f92672>];</span>
        <span style=color:#66d9ef>return</span> ans<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>// 在树状数组 x 位置中增加值 u
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> x<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> u<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> x<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i <span style=color:#f92672>+=</span> lowbit<span style=color:#f92672>(</span>i<span style=color:#f92672>))</span> tree<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>+=</span> u<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>// 初始化「树状数组」，要默认数组是从 1 开始
</span><span style=color:#75715e></span><span style=color:#f92672>{</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> add<span style=color:#f92672>(</span>i <span style=color:#f92672>+</span> 1<span style=color:#f92672>,</span> nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]);</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>// 使用「树状数组」：
</span><span style=color:#75715e></span><span style=color:#f92672>{</span>   
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> val<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]
</span><span style=color:#75715e></span>        add<span style=color:#f92672>(</span>i <span style=color:#f92672>+</span> 1<span style=color:#f92672>,</span> val <span style=color:#f92672>-</span> nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]);</span> 
        nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> val<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sumRange</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> l<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> r<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> query<span style=color:#f92672>(</span>r <span style=color:#f92672>+</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>-</span> query<span style=color:#f92672>(</span>l<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

</code></pre></div><h2 id=dp>DP
<a class=anchor href=#dp>#</a></h2><h3 id=树形dp>树形DP
<a class=anchor href=#%e6%a0%91%e5%bd%a2dp>#</a></h3><blockquote><p><a href=https://leetcode-cn.com/problems/minimum-height-trees/solution/by-ac_oier-7xio/>解析</a></p></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/cs-learning-every-day/cs-learning-every-day/edit/main/content/docs/CS/Algo/Template.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function select(element){const selection=window.getSelection();const range=document.createRange();range.selectNodeContents(element);selection.removeAllRanges();selection.addRange(range);}
document.querySelectorAll("pre code").forEach(code=>{code.addEventListener("click",function(event){select(code.parentElement);if(navigator.clipboard){navigator.clipboard.writeText(code.parentElement.textContent);}});});})();</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#快速排序>快速排序</a></li><li><a href=#归并排序>归并排序</a></li><li><a href=#二分>二分</a></li><li><a href=#双指针>双指针</a></li><li><a href=#位运算>位运算</a></li><li><a href=#离散化>离散化</a></li><li><a href=#区间合并>区间合并</a></li><li><a href=#单链表>单链表</a></li><li><a href=#双链表>双链表</a></li><li><a href=#队列>队列</a></li><li><a href=#单调栈>单调栈</a></li><li><a href=#单调队列>单调队列</a></li><li><a href=#kmp>KMP</a></li><li><a href=#trie树>Trie树</a></li><li><a href=#并查集>并查集</a></li><li><a href=#堆>堆</a></li><li><a href=#一般哈希>一般哈希</a></li><li><a href=#字符串哈希>字符串哈希</a></li><li><a href=#c-stl简介>C++ STL简介</a></li><li><a href=#树与图的存储>树与图的存储</a></li><li><a href=#树与图的遍历>树与图的遍历</a></li><li><a href=#拓扑排序>拓扑排序</a></li><li><a href=#朴素dijkstra算法>朴素dijkstra算法</a></li><li><a href=#堆优化版dijkstra>堆优化版dijkstra</a></li><li><a href=#bellman-ford算法>Bellman-Ford算法</a></li><li><a href=#spfa-算法队列优化的bellman-ford算法>spfa 算法（队列优化的Bellman-Ford算法）</a></li><li><a href=#spfa判断图中是否存在负环>spfa判断图中是否存在负环</a></li><li><a href=#floyd算法>floyd算法</a></li><li><a href=#朴素版prim算法>朴素版prim算法</a></li><li><a href=#kruskal算法>Kruskal算法</a></li><li><a href=#染色法判别二分图>染色法判别二分图</a></li><li><a href=#匈牙利算法>匈牙利算法</a></li><li><a href=#试除法判定质数>试除法判定质数</a></li><li><a href=#试除法分解质因数>试除法分解质因数</a></li><li><a href=#朴素筛法求素数>朴素筛法求素数</a></li><li><a href=#线性筛法求素数>线性筛法求素数</a></li><li><a href=#试除法求所有约数>试除法求所有约数</a></li><li><a href=#约数个数和约数之和>约数个数和约数之和</a></li><li><a href=#欧几里得算法>欧几里得算法</a></li><li><a href=#求欧拉函数>求欧拉函数</a></li><li><a href=#筛法求欧拉函数>筛法求欧拉函数</a></li><li><a href=#快速幂>快速幂</a></li><li><a href=#扩展欧几里得算法>扩展欧几里得算法</a></li><li><a href=#高斯消元>高斯消元</a></li><li><a href=#递归法求组合数>递归法求组合数</a></li><li><a href=#通过预处理逆元的方式求组合数>通过预处理逆元的方式求组合数</a></li><li><a href=#lucas定理>Lucas定理</a></li><li><a href=#分解质因数法求组合数>分解质因数法求组合数</a></li><li><a href=#卡特兰数>卡特兰数</a></li><li><a href=#nim游戏>NIM游戏</a></li><li><a href=#公平组合游戏icg>公平组合游戏ICG</a></li><li><a href=#有向图游戏>有向图游戏</a></li><li><a href=#mex运算>Mex运算</a></li><li><a href=#sg函数>SG函数</a></li><li><a href=#有向图游戏的和>有向图游戏的和</a></li><li><a href=#树状数组模板>树状数组模板</a></li></ul></li><li><a href=#dp>DP</a><ul><li><a href=#树形dp>树形DP</a></li></ul></li></ul></nav></div></aside></main></body></html>