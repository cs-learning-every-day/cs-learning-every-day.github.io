<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Day Day Up</title><link>https://cs-learning-every-day.github.io/docs/leetcode/</link><description>Recent content on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/docs/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dfs/139/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dfs/139/</guid><description>Link
遍历字符串，将其分成两部分left和right，判断是否都在wordList里。
加上记忆化
public boolean wordBreak(String s, List&amp;lt;String&amp;gt; wordDict) { Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(wordDict); Map&amp;lt;String, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set&amp;lt;String&amp;gt; set, Map&amp;lt;String, Boolean&amp;gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i &amp;lt; n; i++) { String left = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i &amp;lt;= numRows; i++) { for (int j = 1; j &amp;lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i &amp;lt;= numRows; i++) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for (int j = 1; j &amp;lt;= i; j++) { tmp.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</guid><description>Link
class Solution { public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row &amp;lt;= rowIndex; row++) { for (int col = 1; col &amp;lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for (int col = 1; col &amp;lt;= rowIndex; col++) { ans.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</guid><description>Link
DP 要从下往上找，否则不一定是全局最优
2 3 4 6 5 1 4 1 8 3
class Solution { public int minimumTotal(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j &amp;lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt;= i; j++) { dp[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</guid><description>Link
可以把数据看成折线图，则所有上升之和为解
public int maxProfit(int[] prices) { int res = 0; for (int i = 0; i &amp;lt; prices.length - 1; i++) { if (prices[i + 1] &amp;gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP
public int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润 int[] dp1 = new int[n]; // 第i天卖掉的最大利润 int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i &amp;lt; n; i++) { // 可以不买或卖 dp1[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</guid><description>Link
使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]
[1] -&amp;gt; [2 3 5] -&amp;gt; [3 4 5 6 10] -&amp;gt; &amp;hellip;
class Solution { // Time Complexity: O(3N * lg3N) // 每次产生 最小数的2、3、5倍数 public int nthUglyNumber(int n) { PriorityQueue&amp;lt;Long&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); q.add(1L); long top = -1L; for (int i = 0; i &amp;lt; n; i++) { top = q.peek(); while (!q.isEmpty() &amp;amp;&amp;amp; q.peek() == top) { q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</guid><description>Link
DP
public int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润 int[] dp1 = new int[n + 1]; // i天买入的最大利润 int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出) dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入) dp2[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</guid><description>Link
DP
dp[i][j] 表示能到i行j列不同路径个数
初始化第一行和和第一列为1
class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &amp;lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j &amp;lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i &amp;lt;= m; i++) { for (int j = 2; j &amp;lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+记忆化</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</guid><description>
Link
第i天买入的最大利润buy[i]
卖出的最大利润sell[i]
卖出的时候(完成了一笔交易)减去手续费
class Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</guid><description>Link
DFS搜索 + 记忆化 class Solution { private Map&amp;lt;String, Integer&amp;gt; memo = new HashMap&amp;lt;&amp;gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i &amp;gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i &amp;lt; n - 1 &amp;amp;&amp;amp; isValid(s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</guid><description>
Link
常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。
第一轮：1/n
第二轮：(n-1)/n * 1/(n-1)
第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)
…………
private int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i &amp;lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</guid><description>Link
class Solution { private int m; private int n; private int count; private Map&amp;lt;Integer, Integer&amp;gt; map; /** 转成一维数组 索引i 相当于=&amp;gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =&amp;gt; 5 =&amp;gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =&amp;gt; 6 =&amp;gt; 3 map[5] = 4 map[3] = map[4] = 5 ... .</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</guid><description>
Link 一道简单的搜索
public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i &amp;lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</guid><description>
Link
递归搜索
class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val &amp;gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } }</description></item></channel></rss>