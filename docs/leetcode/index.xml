<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Day Day Up</title><link>https://cs-learning-every-day.github.io/docs/leetcode/</link><description>Recent content on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/docs/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/binarysearch/33/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/binarysearch/33/</guid><description>Link
public int search(int[] nums, int target) { // 找到分隔点, 一半区间满足性质，另一半则不满足 // 2 3 4 5 6 7, 1 // 6 7, 1 2 3 4 5 int l = 0, r = nums.length - 1; int mid; while (l &amp;lt; r) { mid = (l + r + 1) &amp;gt;&amp;gt; 1; if (nums[mid] &amp;gt;= nums[0]) { l = mid; } else { r = mid - 1; } } // 判断在左半边、右半边 if (target &amp;gt;= nums[0]) { l = 0; } else { l = r + 1; r = nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/binarysearch/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/binarysearch/34/</guid><description>Link
class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int l = 0, r = nums.length - 1; int mid; while (l &amp;lt; r) { mid = (l + r) &amp;gt;&amp;gt; 1; if (nums[mid] &amp;gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[l] != target) { return new int[]{-1, -1}; } int[] res = new int[2]; res[0] = l; l = 0; r = nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/binarysearch/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/binarysearch/35/</guid><description>
Link
public int searchInsert(int[] nums, int target) { int lo = 0, hi = nums.length, mid = 0; while (lo &amp;lt; hi) { mid = (lo + hi) &amp;gt;&amp;gt; 1; if (nums[mid] &amp;gt;= target) { hi = mid; } else { lo = mid + 1; } } return lo; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/design/146/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/design/146/</guid><description>Link
使用java的双向链表LinkedList有坑啊，过不了。
class LRUCache { private int capacity; private DoubleList list; private Map&amp;lt;Integer, Node&amp;gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap&amp;lt;&amp;gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/design/355/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/design/355/</guid><description>Link
class Twitter { private Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; follows; private Map&amp;lt;Integer, PriorityQueue&amp;lt;Integer&amp;gt;&amp;gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map&amp;lt;Integer, Integer&amp;gt; orders = new HashMap&amp;lt;&amp;gt;(); public Twitter() { follows = new HashMap&amp;lt;&amp;gt;(); tweets = new HashMap&amp;lt;&amp;gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue&amp;lt;Integer&amp;gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue&amp;lt;Integer&amp;gt;((a, b) -&amp;gt; b - a); tweets.put(userId, tmp); } int key = ai.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dfs/139/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dfs/139/</guid><description>Link
遍历字符串，将其分成两部分left和right，判断是否都在wordList里。
加上记忆化
public boolean wordBreak(String s, List&amp;lt;String&amp;gt; wordDict) { Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(wordDict); Map&amp;lt;String, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set&amp;lt;String&amp;gt; set, Map&amp;lt;String, Boolean&amp;gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i &amp;lt; n; i++) { String left = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dfs/17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dfs/17/</guid><description>Link
使用StringBuilder优化字符串copy
class Solution { List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); String[] keyboards = new String[]{ &amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;abc&amp;#34;, &amp;#34;def&amp;#34;, &amp;#34;ghi&amp;#34;, &amp;#34;jkl&amp;#34;, &amp;#34;mno&amp;#34;, &amp;#34;pqrs&amp;#34;, &amp;#34;tuv&amp;#34;, &amp;#34;wxyz&amp;#34;, }; public List&amp;lt;String&amp;gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), new StringBuilder()); return res; } private void dfs(String digits, int pos, int len, StringBuilder cur) { if (pos == len) { res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dfs/37/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dfs/37/</guid><description>Link
class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init for (int i = 0; i &amp;lt; 9; i++) for (int j = 0; j &amp;lt; 9; j++) { if (board[i][j] != &amp;#39;.&amp;#39;) { int t = board[i][j] - &amp;#39;1&amp;#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dfs/5964/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dfs/5964/</guid><description>TODO: Link
class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i &amp;lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i &amp;lt; len; i++) { if (checkAndRun(pos, s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/10/</guid><description>Link
public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // 表示 dp[i][j] = s[1..i] 和 p[1...j]是否相等 boolean[][] dp = new boolean[m + 1][n + 1]; s = &amp;#34; &amp;#34; + s; p = &amp;#34; &amp;#34; + p; dp[0][0] = true; for (int i = 0; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (j + 1 &amp;lt;= n &amp;amp;&amp;amp; p.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i &amp;lt;= numRows; i++) { for (int j = 1; j &amp;lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i &amp;lt;= numRows; i++) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for (int j = 1; j &amp;lt;= i; j++) { tmp.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</guid><description>Link
class Solution { public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row &amp;lt;= rowIndex; row++) { for (int col = 1; col &amp;lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for (int col = 1; col &amp;lt;= rowIndex; col++) { ans.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</guid><description>Link
DP 要从下往上找，否则不一定是全局最优
2 3 4 6 5 1 4 1 8 3
class Solution { public int minimumTotal(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j &amp;lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt;= i; j++) { dp[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</guid><description>Link
可以把数据看成折线图，则所有上升之和为解
public int maxProfit(int[] prices) { int res = 0; for (int i = 0; i &amp;lt; prices.length - 1; i++) { if (prices[i + 1] &amp;gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP
public int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润 int[] dp1 = new int[n]; // 第i天卖掉的最大利润 int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i &amp;lt; n; i++) { // 可以不买或卖 dp1[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/123/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/123/</guid><description>Link
public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: 持有第一股的最大利益 // dp[0][1]: 售出第一股的最大利益 // dp[0][2]: 持有第二股的最大利益 // dp[0][3]: 售出第二股的最大利益 int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/198/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/198/</guid><description>
Link
class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: 第一个房间抢 // dp[0][1]: 第一个房间不抢 int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i &amp;lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/213/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/213/</guid><description>Link
class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j) private int help(int[] nums, int i, int j) { // 0 : 抢 // 1 : 不抢 int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i &amp;lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</guid><description>Link
使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]
[1] -&amp;gt; [2 3 5] -&amp;gt; [3 4 5 6 10] -&amp;gt; &amp;hellip;
class Solution { // Time Complexity: O(3N * lg3N) // 每次产生 最小数的2、3、5倍数 public int nthUglyNumber(int n) { PriorityQueue&amp;lt;Long&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); q.add(1L); long top = -1L; for (int i = 0; i &amp;lt; n; i++) { top = q.peek(); while (!q.isEmpty() &amp;amp;&amp;amp; q.peek() == top) { q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</guid><description>Link
DP
public int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润 int[] dp1 = new int[n + 1]; // i天买入的最大利润 int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出) dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入) dp2[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/44/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/44/</guid><description>Link
f[i][j]：表示s[0..i]和p[0..j]是否匹配
public boolean isMatch(String s, String p) { int m = s.length(), n = p.length(); s = &amp;#34; &amp;#34; + s; p = &amp;#34; &amp;#34; + p; boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (p.charAt(j) == &amp;#39;*&amp;#39;) { f[i][j] = (i &amp;gt; 0 &amp;amp;&amp;amp; f[i - 1][j]) || f[i][j - 1]; } else { f[i][j] = i &amp;gt; 0 &amp;amp;&amp;amp; f[i - 1][j - 1] &amp;amp;&amp;amp; (s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/45/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/45/</guid><description>
Link
public int jump(int[] nums) { int n = nums.length; // f[i]: 最少的跳跃次数到达i int[] f = new int[n]; for (int i = 1, j = 0; i &amp;lt; n; i++) { while (j + nums[j] &amp;lt; i) j++; f[i] = f[j] + 1; } return f[n - 1]; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/509/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/509/</guid><description>
Link
public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i &amp;lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</guid><description>Link
DP
dp[i][j] 表示能到i行j列不同路径个数
初始化第一行和和第一列为1
class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &amp;lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j &amp;lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i &amp;lt;= m; i++) { for (int j = 2; j &amp;lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+记忆化</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/63/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/63/</guid><description>
Link
同
62题题思路一样
直接看DP解法，注意初始化，有障碍物时，就不能往后走了
class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &amp;lt; m &amp;amp;&amp;amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j &amp;lt; n &amp;amp;&amp;amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i &amp;lt; m; i++) { for (int j = 1; j &amp;lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/64/</guid><description>Link
dp[i][j] 表示到i行j列最小总和 注意初始化
class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int k = i; k &amp;gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j &amp;lt; n; j++) { for (int k = j; k &amp;gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i &amp;lt; m; i++) { for (int j = 1; j &amp;lt; n; j++) { dp[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</guid><description>
Link
第i天买入的最大利润buy[i]
卖出的最大利润sell[i]
卖出的时候(完成了一笔交易)减去手续费
class Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</guid><description>Link
DFS搜索 + 记忆化 class Solution { private Map&amp;lt;String, Integer&amp;gt; memo = new HashMap&amp;lt;&amp;gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i &amp;gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i &amp;lt; n - 1 &amp;amp;&amp;amp; isValid(s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/hashtable/49/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/hashtable/49/</guid><description>
Link
public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) { Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (String str : strs) { String oldStr = str; char[] chs = str.toCharArray(); Arrays.sort(chs); str = new String(chs); List&amp;lt;String&amp;gt; tmp = map.getOrDefault(str, null); if (tmp == null) { tmp = new ArrayList&amp;lt;&amp;gt;(); map.put(str, tmp); } tmp.add(oldStr); } List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for (var e : map.entrySet()) { res.add(e.getValue()); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/1046/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/1046/</guid><description>Link
// Time Complexity: O(nlogn) // Space Complexity: O(n) public int lastStoneWeight(int[] stones) { PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() &amp;gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/347/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/347/</guid><description>Link
public int[] topKFrequent(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() &amp;lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() &amp;gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/451/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/451/</guid><description>Link
public String frequencySort(String s) { Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue&amp;lt;Character&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i &amp;lt; n; i++) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/19/</guid><description>
Link
public ListNode removeNthFromEnd(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; int n = 0; while (head != null) { n++; head = head.next; } ListNode prev = dummy; for (int i = 0; i &amp;lt; (n - k); i++) { prev = prev.next; } prev.next = prev.next.next; return dummy.next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/2/</guid><description>Link
public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode curr = dummy; int t = 0; while (l1 != null || l2 != null || t != 0) { if (l1 != null) { t += l1.val; l1 = l1.next; } if (l2 != null) { t += l2.val; l2 = l2.next; } curr.next = new ListNode(t % 10); t /= 10; curr = curr.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/21/</guid><description>Link
public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode prev = dummy; while (l1 != null &amp;amp;&amp;amp; l2 != null) { if (l1.val &amp;lt; l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } if (l1 != null) { prev.next = l1; } if (l2 != null) { prev.next = l2; } return dummy.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/23/</guid><description>Link
class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode dummy = new ListNode(); PriorityQueue&amp;lt;ListNode&amp;gt; minHeap = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; a.val - b.val); for (var l : lists) { if (l != null) { // 示例3 特例 minHeap.offer(l); } } ListNode tail = dummy; while (!minHeap.isEmpty()) { ListNode cur = minHeap.poll(); tail.next = cur; tail = tail.next; cur = cur.next; if (cur != null) { minHeap.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/24/</guid><description>
Link
public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy; p.next != null &amp;amp;&amp;amp; p.next.next != null;) { ListNode a = p.next; ListNode b = p.next.next; p.next = b; a.next = b.next; b.next = a; p = a; } return dummy.next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/25/</guid><description>Link
public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy;;) { int n = 0; for (ListNode t = p.next; t != null; t = t.next) { n++; } if (n &amp;lt; k) { break; } // 翻转k个节点 ListNode a = p.next, b = p.next.next; for (int i = 0; i &amp;lt; k - 1; i++) { var c = b.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/1979/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/1979/</guid><description>
Link
public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a &amp;gt; b private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</guid><description>
Link
常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。
第一轮：1/n
第二轮：(n-1)/n * 1/(n-1)
第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)
…………
private int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i &amp;lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/39/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/39/</guid><description>Link
List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList&amp;lt;&amp;gt;(), 0); return res; } private void dfs(int[] candidates, int target, List&amp;lt;Integer&amp;gt; cur, int s) { if (target &amp;lt; 0) { return; } if (target == 0) { res.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = s; i &amp;lt; candidates.length; i++) { if (candidates[i] &amp;gt; target) break; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i); cur.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/40/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/40/</guid><description>Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList&amp;lt;&amp;gt;(), 0); return res; } private void dfs(int[] candidates, int target, List&amp;lt;Integer&amp;gt; cur, int s) { if (target == 0) { res.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = s; i &amp;lt; candidates.length; i++) { if (candidates[i] &amp;gt; target) break; if (i &amp;gt; s &amp;amp;&amp;amp; candidates[i] == candidates[i - 1]) continue; cur.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/43/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/43/</guid><description>Link
string multiply(string num1, string num2) { int n = num1.size(), m = num2.size(); vector&amp;lt;int&amp;gt; A, B; for (int i = n - 1; i &amp;gt;= 0; i--) A.push_back(num1[i] - &amp;#39;0&amp;#39;); for (int i = m - 1; i &amp;gt;= 0; i--) B.push_back(num2[i] - &amp;#39;0&amp;#39;); vector&amp;lt;int&amp;gt; C(n + m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) C[i + j] += A[i] * B[j]; for (int i = 0, t = 0; i &amp;lt; C.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/46/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/46/</guid><description>
Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); boolean[] st; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) { st = new boolean[nums.length]; dfs(new ArrayList&amp;lt;&amp;gt;(), nums); return res; } private void dfs(List&amp;lt;Integer&amp;gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } for (int i = 0; i &amp;lt; nums.length; i++) { if (st[i]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/47/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/47/</guid><description>Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); boolean[] st; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) { Arrays.sort(nums); st = new boolean[nums.length]; dfs(new ArrayList&amp;lt;&amp;gt;(), nums); return res; } private void dfs(List&amp;lt;Integer&amp;gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } for (int i = 0; i &amp;lt; nums.length; i++) { if (st[i]) continue; if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</guid><description>Link
class Solution { private int m; private int n; private int count; private Map&amp;lt;Integer, Integer&amp;gt; map; /** 转成一维数组 索引i 相当于=&amp;gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =&amp;gt; 5 =&amp;gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =&amp;gt; 6 =&amp;gt; 3 map[5] = 4 map[3] = map[4] = 5 ... .</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/812/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/812/</guid><description>Link
看评论区都用线性代数，没学过线性代数的我，泪目了哭！
public double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i &amp;lt; points.length; i++) { for (int j = i + 1; j &amp;lt; points.length; j++) { for (int k = j + 1; k &amp;lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp &amp;gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b &amp;gt; c) || (a + c &amp;gt; b) || (b + c) &amp;gt; a; } // 果断找个公式，海伦公式 private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/1/</guid><description>
Link
public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int another = target - nums[i]; if (map.containsKey(another)) { return new int[]{i, map.get(another)}; } map.put(nums[i], i); } return null; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/1005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/1005/</guid><description>Link
写的实在是太丑陋了, 太多边界条件不易写
class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // 最小&amp;gt;0的数索引 for (int n : nums) { if (n &amp;lt; 0) i++; else break; } int j = i - 1; // 最大负数索引 int negCount = i; int idx = negCount - i; while (k &amp;gt; 0) { if (negCount &amp;gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i &amp;lt; nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/22/</guid><description>
Link
class Solution { private List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;String&amp;gt; generateParenthesis(int n) { dfs(n, 0, 0, &amp;#34;&amp;#34;); return res; } private void dfs(int n, int open, int closed, String s) { if (open == n &amp;amp;&amp;amp; closed == n) { res.add(s); return; } if (open &amp;lt; n) { dfs(n, open + 1, closed, s + &amp;#34;(&amp;#34;); } if (closed &amp;lt; n &amp;amp;&amp;amp; closed &amp;lt; open) { dfs(n, open, closed + 1, s + &amp;#34;)&amp;#34;); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/29/</guid><description>Link
X / Y = K &amp;ndash;&amp;gt; X = YK &amp;ndash;&amp;gt; K假设K=(1110)2 则 X = Y * 2^3 + Y * 2^2 + Y * 2^1 即logK个数相加
class Solution { public int divide(int dividend, int divisor) { int flag = 1; if (dividend &amp;lt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0 || dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;lt; 0) { flag = -1; } long a = Math.abs((long)dividend), b = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/31/</guid><description>
Link
class Solution { // 从前往后找第一次降序的位置k // 从k开始找较k-1大的数，交换 // 反转(k, end) public void nextPermutation(int[] nums) { int n = nums.length; int k = n - 1; while (k &amp;gt; 0 &amp;amp;&amp;amp; nums[k - 1] &amp;gt;= nums[k]) k--; if (k &amp;lt;= 0) { reverse(nums, 0, n - 1); } else { int t = k; while (t &amp;lt; n &amp;amp;&amp;amp; nums[t] &amp;gt; nums[k - 1]) t++; swap(nums, k - 1, t - 1); reverse(nums, k, n - 1); } } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } // [begin, end] private void reverse(int[] nums, int begin, int end) { for (int i = 0; i &amp;lt; (end - begin + 1) / 2; i++) { swap(nums, begin + i, end - i); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/36/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/36/</guid><description>Link
class Solution { public boolean isValidSudoku(char[][] board) { boolean[] st = new boolean[10]; // 判断行 for (int i = 0; i &amp;lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j &amp;lt; 9; j++) { if (board[i][j] != &amp;#39;.&amp;#39;) { int t = board[i][j] - &amp;#39;0&amp;#39;; if (st[t]) return false; st[t] = true; } } } // 判断列 for (int i = 0; i &amp;lt; 9; i++) { Arrays.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/37/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/37/</guid><description>Link
class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init for (int i = 0; i &amp;lt; 9; i++) for (int j = 0; j &amp;lt; 9; j++) { if (board[i][j] != &amp;#39;.&amp;#39;) { int t = board[i][j] - &amp;#39;1&amp;#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/383/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/383/</guid><description>
Link
class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - &amp;#39;a&amp;#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - &amp;#39;a&amp;#39;] &amp;lt;= 0) return false; count[c - &amp;#39;a&amp;#39;]--; } return true; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/48/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/48/</guid><description>
Link
public void rotate(int[][] matrix) { int n = matrix.length; // 沿着对角线翻转 for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; i; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } // 沿着中心列翻转 for (int row = 0; row &amp;lt; n; row++) { for (int i = 0, j = n - 1; i &amp;lt; j; i++, j--) { int tmp = matrix[row][i]; matrix[row][i] = matrix[row][j]; matrix[row][j] = tmp; } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/50/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/50/</guid><description>
Link
public double myPow(double x, int n) { boolean isMinus = false; if (n &amp;lt; 0) { isMinus = true; } double res = 1; for (long k = (long)Math.abs((long)n); k != 0; k &amp;gt;&amp;gt;= 1) { if ((k &amp;amp; 0x1) == 0x1) { res *= x; } x *= x; } if (isMinus) { return 1 / res; } else { return res; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5963/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5963/</guid><description>TODO: Link
class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; s.charAt(i) == &amp;#39;0&amp;#39;) { i--; } for ( ; i &amp;gt;= 0; i--) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5965/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5965/</guid><description>TODO: Link
稍微优化下还是超时，放弃
class Solution { Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i &amp;lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List&amp;lt;Integer&amp;gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; arr.length; i++) { // if (i == begin) continue; if (arr[begin] == arr[i]) { list.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5967/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5967/</guid><description>
Link
public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i &amp;lt; chs.length; i++) { if (chs[i] == &amp;#39;a&amp;#39;) { x = i; } else if (y == -1 &amp;amp;&amp;amp; chs[i] == &amp;#39;b&amp;#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x &amp;lt; y; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5968/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5968/</guid><description>Link
class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i &amp;lt; m - 1; i++) { if (!bank[i].contains(&amp;#34;1&amp;#34;)) { continue; } int t = calculate(bank, i); // 计算这一行符合的激光束数量 if (t &amp;gt; 0) { // update result for (int j = 0; j &amp;lt; n; j++) { if (bank[i].</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5969/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5969/</guid><description> [Link]
class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t &amp;lt; a) { return false; } else { t += a; } } return true; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/7/</guid><description>
Link
public int reverse(int x) { // java 这里-11 % 10 = -1 数学上应该是 9 int flag = 1; if (x &amp;lt; 0) { flag = -1; x = -x; } int res = 0; while (x != 0) { if (res &amp;gt; ((Integer.MAX_VALUE - (x % 10)) / 10)) { return 0; } res = res * 10 + (x % 10); x /= 10; } return res * flag; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/748/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/748/</guid><description>Link
public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = &amp;#34;&amp;#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) &amp;amp;&amp;amp; word.length() &amp;lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i &amp;lt; a1.length; i++) { if (a1[i] &amp;gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/9/</guid><description>
Link
public boolean isPalindrome(int x) { if (x &amp;lt; 0) { return false; } int y = x; int res = 0; while (x &amp;gt; 0) { res = res * 10 + (x % 10); x /= 10; } return res == y; } public boolean isPalindrome(int x) { String s = String.valueOf(x); return s.equals(new StringBuilder(s).reverse().toString()); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/recursion/1492/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/recursion/1492/</guid><description>
Link
public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f &amp;gt;= n &amp;amp;&amp;amp; k &amp;gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/12/</guid><description>Link
public String intToRoman(int num) { int[] values = new int[]{ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; String[] chs = new String[]{ &amp;#34;I&amp;#34;, &amp;#34;IV&amp;#34;, &amp;#34;V&amp;#34;, &amp;#34;IX&amp;#34;, &amp;#34;X&amp;#34;, &amp;#34;XL&amp;#34;, &amp;#34;L&amp;#34;, &amp;#34;XC&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;CD&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;CM&amp;#34;, &amp;#34;M&amp;#34; }; StringBuilder sb = new StringBuilder(); for (int i = values.length - 1; i &amp;gt;= 0; i--) { while (num &amp;gt;= values[i]) { num -= values[i]; sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/13/</guid><description>Link
public int romanToInt(String s) { Map&amp;lt;Character, Integer&amp;gt; hash = new HashMap&amp;lt;&amp;gt;(); hash.put(&amp;#39;I&amp;#39;, 1); hash.put(&amp;#39;V&amp;#39;, 5); hash.put(&amp;#39;X&amp;#39;, 10); hash.put(&amp;#39;L&amp;#39;, 50); hash.put(&amp;#39;C&amp;#39;, 100); hash.put(&amp;#39;D&amp;#39;, 500); hash.put(&amp;#39;M&amp;#39;, 1000); int res = 0; int n = s.length(); for (int i = 0; i &amp;lt; n; i++) { if (i + 1 &amp;lt; n &amp;amp;&amp;amp; hash.get(s.charAt(i)) &amp;lt; hash.get(s.charAt(i + 1))) { res = res + (-hash.get(s.charAt(i))); } else { res = res + hash.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/38/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/38/</guid><description>
Link
public String countAndSay(int n) { String res = &amp;#34;1&amp;#34;; for (int i = 2; i &amp;lt;= n; i++) { StringBuilder t = new StringBuilder(); int m = res.length(); for (int j = 0; j &amp;lt; m; ) { int k = j + 1; while (k &amp;lt; m &amp;amp;&amp;amp; res.charAt(j) == res.charAt(k)) k++; t.append(k - j).append(res.charAt(j)); j = k; } res = t.toString(); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/sorts/215/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/sorts/215/</guid><description>
Link
使用优先队列
// Time Complexity: O(nlgn) // Space Complexity: O(k) public int findKthLargest(int[] nums, int k) { PriorityQueue&amp;lt;Integer&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); for (int num : nums) { if (q.size() == k) { if (num &amp;gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/sorts/41/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/sorts/41/</guid><description>Link
class Solution { public int firstMissingPositive(int[] nums) { for (int i = 0; i &amp;lt; nums.length; i++) { while (nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] != i + 1 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.length &amp;amp;&amp;amp; nums[i] != nums[nums[i] - 1]) { int tmp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = tmp; } } for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/stack/20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/stack/20/</guid><description>Link
查阅Ascii码表进行简化
public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int n = s.length(); for (int i = 0; i &amp;lt; n; i++) { if (s.charAt(i) == &amp;#39;(&amp;#39; || s.charAt(i) == &amp;#39;{&amp;#39; || s.charAt(i) == &amp;#39;[&amp;#39;) { st.push(s.charAt(i)); } else { if (st.size() &amp;gt; 0 &amp;amp;&amp;amp; Math.abs(st.peek() - s.charAt(i)) &amp;lt;= 2) { st.pop(); } else { return false; } } } return st.size() == 0; } public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int n = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/stack/32/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/stack/32/</guid><description>Link
public int longestValidParentheses(String s) { Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int n = s.length(); int result = 0; for (int i = 0, start = -1; i &amp;lt; n; i++) { if (s.charAt(i) == &amp;#39;(&amp;#39;) { st.push(i); } else { if (st.isEmpty()) { start = i; } else { st.pop(); if (st.isEmpty()) { result = Math.max(result, i - start); } else { result = Math.max(result, i - st.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/stack/42/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/stack/42/</guid><description>Link
Detail
public int trap(int[] height) { Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int ans = 0; for (int i = 0; i &amp;lt; height.length; i++) { while (!st.isEmpty() &amp;amp;&amp;amp; height[st.peek()] &amp;lt; height[i]) { int cur = st.pop(); if (st.isEmpty()) break; int l = st.peek(); int r = i; int h = Math.min(height[l], height[r]) - height[cur]; ans += (r - l - 1) * h; } st.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/14/</guid><description>
Link
public String longestCommonPrefix(String[] strs) { StringBuilder sb = new StringBuilder(); int n = strs[0].length(); for (int i = 0; i &amp;lt; n; i++) { char c = strs[0].charAt(i); for (int j = 1; j &amp;lt; strs.length; j++) { if (i &amp;gt;= strs[j].length() || c != strs[j].charAt(i)) { return sb.toString(); } } sb.append(c); } return sb.toString(); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/28/</guid><description>Link
public int strStr(String s, String p) { int m = p.length(); if (m == 0) return 0; int n = s.length(); s = &amp;#34; &amp;#34; + s; p = &amp;#34; &amp;#34; + p; int[] next = new int[m + 1]; for (int i = 2, j = 0; i &amp;lt;= m; i++) { while (j != 0 &amp;amp;&amp;amp; p.charAt(i) != p.charAt(j + 1)) j = next[j]; if ( p.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/5/</guid><description>Link
public String longestPalindrome(String s) { int n = s.length(); String res = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; n; i++) { int l = i - 1, r = i + 1; while (l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; n &amp;amp;&amp;amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() &amp;lt; (r - l - 1)) { res = s.substring(l + 1, r); } l = i; r = i + 1; while (l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; n &amp;amp;&amp;amp; s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/6/</guid><description>Link
转成索引排列，找出规律
public String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i &amp;lt; numRows; i++) { if (i == 0 || i == numRows - 1) { for (int j = i; j &amp;lt; n; j += 2 * numRows - 2) { sb.append(s.charAt(j)); } } else { for (int j = i, k = 2 * numRows - 2 - i; j &amp;lt; n || k &amp;lt; n; j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j &amp;lt; n) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/8/</guid><description>Link
class Solution { public int myAtoi(String s) { int k = 0; int n = s.length(); while (k &amp;lt; n &amp;amp;&amp;amp; s.charAt(k) == &amp;#39; &amp;#39;) { k++; } if (k == n) { return 0; } int minus = 1; if (s.charAt(k) == &amp;#39;-&amp;#39;) { minus = -1; k++; } else if (s.charAt(k) == &amp;#39;+&amp;#39;) { k++; } int res = 0; while (k &amp;lt; n &amp;amp;&amp;amp; s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tips/</guid><description>摩尔投票算法
#
/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/102/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/102/</guid><description>
Link
考虑当前层结束条件，即当前队列中的元素个数。
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); int count = q.size(); while (count &amp;gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</guid><description>
Link 一道简单的搜索
public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i &amp;lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</guid><description>
Link
递归搜索
class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val &amp;gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/11/</guid><description>
Link
public int maxArea(int[] height) { int res = 0; for (int i = 0, j = height.length - 1; i &amp;lt; j; ) { res = Math.max(res, Math.min(height[i], height[j]) * (j - i)); if (height[i] &amp;lt; height[j]) { i++; } else { j--; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/15/</guid><description>Link
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Arrays.sort(nums); for (int i = 0; i &amp;lt; nums.length; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1, k = nums.length - 1; j &amp;lt; k; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) { continue; } while (j &amp;lt; k - 1 &amp;amp;&amp;amp; nums[i] + nums[j] + nums[k - 1] &amp;gt;= 0) { // 找靠近左边第一个&amp;gt;=的k索引 k--; } if (nums[i] + nums[j] + nums[k] == 0) { res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/16/</guid><description>Link
public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i &amp;lt; nums.length; i++) { int j = i + 1, k = nums.length - 1; while (j &amp;lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum &amp;gt; target) { k--; } else { j++; } if (Math.abs(target - sum) &amp;lt; Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/18/</guid><description>Link
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i &amp;lt; n; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j &amp;lt; n; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) { continue; } for (int k = j + 1, u = n - 1; k &amp;lt; u; k++) { if (k &amp;gt; j + 1 &amp;amp;&amp;amp; nums[k] == nums[k - 1]) { continue; } while (k &amp;lt; u - 1 &amp;amp;&amp;amp; nums[i] + nums[j] + nums[k] + nums[u - 1] &amp;gt;= target) { u--; } if (nums[i] + nums[j] + nums[k] + nums[u] == target) { res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/26/</guid><description>
Link
public int removeDuplicates(int[] nums) { int j = 0; for (int i = 0; i &amp;lt; nums.length; i++) { if (i == 0 || nums[i] != nums[i - 1]) { nums[j++] = nums[i]; } } return j; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/27/</guid><description>
Link
public int removeElement(int[] nums, int val) { int j = 0; for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] != val) { nums[j++] = nums[i]; } } return j; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/3/</guid><description>Link
int lengthOfLongestSubstring(string s) { unordered_map&amp;lt;char, int&amp;gt; map{}; int res = 0; int n = s.length(); int j = 0; for (int i = 0; i &amp;lt; n; i++) { map[s[i]]++; if (map[s[i]] &amp;gt; 1) { while (map[s[i]] &amp;gt; 1) { map[s[j++]]--; } } res = max(res, i - j + 1); } return res; } public int lengthOfLongestSubstring(String s) { Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int res = 0; int n = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/30/</guid><description>Link
滑动窗口 + Hash
public List&amp;lt;Integer&amp;gt; findSubstring(String s, String[] words) { List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int n = s.length(), m = words.length; if (m == 0) { return res; } int w = words[0].length(); Map&amp;lt;String, Integer&amp;gt; tot = new HashMap&amp;lt;&amp;gt;(); for (String word : words) tot.put(word, tot.getOrDefault(word, 0) + 1); for (int i = 0; i &amp;lt; w; i++) { Map&amp;lt;String, Integer&amp;gt; wd = new HashMap&amp;lt;&amp;gt;(); int cnt = 0; for (int j = i; j + w &amp;lt;= n; j += w) { if (j &amp;gt;= i + m * w) { String word = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/4/</guid><description>Link
public double findMedianSortedArrays(int[] nums1, int[] nums2) { int k = nums1.length + nums2.length; if (k % 2 == 0) { int left = findKth(nums1, 0, nums2, 0, k / 2); int right = findKth(nums1, 0, nums2, 0, k / 2 + 1); return (left + right) / 2.0; } else { return findKth(nums1, 0, nums2, 0, k / 2 + 1); } } // 二分做法 private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { if (nums1.</description></item></channel></rss>