<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Day Day Up</title><link>https://cs-learning-every-day.github.io/docs/leetcode/</link><description>Recent content on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/docs/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/design/146/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/design/146/</guid><description>Link
class LRUCache { private: list&amp;lt;int&amp;gt; l; unordered_map&amp;lt;int, int&amp;gt; cache; unordered_map&amp;lt;int, list&amp;lt;int&amp;gt;::iterator&amp;gt; pos; int capacity; void update(int key) { if (pos.find(key) != pos.end()) { l.erase(pos[key]); } else if (cache.size() == capacity) { int rmK = l.back(); cache.erase(rmK); l.erase(pos[rmK]); pos.erase(rmK); } l.push_front(key); pos[key] = l.begin(); } public: LRUCache(int capacity) : capacity(capacity) { } int get(int key) { if (cache.find(key) == cache.end()) { return -1; } // 更新LRU update(key); return cache[key]; } void put(int key, int value) { update(key); cache[key] = value; } }; 使用java的双向链表LinkedList有坑啊，过不了。</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/design/355/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/design/355/</guid><description>Link
class Twitter { private Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; follows; private Map&amp;lt;Integer, PriorityQueue&amp;lt;Integer&amp;gt;&amp;gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map&amp;lt;Integer, Integer&amp;gt; orders = new HashMap&amp;lt;&amp;gt;(); public Twitter() { follows = new HashMap&amp;lt;&amp;gt;(); tweets = new HashMap&amp;lt;&amp;gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue&amp;lt;Integer&amp;gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue&amp;lt;Integer&amp;gt;((a, b) -&amp;gt; b - a); tweets.put(userId, tmp); } int key = ai.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/10/</guid><description>Link
public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // 表示 dp[i][j] = s[1..i] 和 p[1...j]是否相等 boolean[][] dp = new boolean[m + 1][n + 1]; s = &amp;#34; &amp;#34; + s; p = &amp;#34; &amp;#34; + p; dp[0][0] = true; for (int i = 0; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (j + 1 &amp;lt;= n &amp;amp;&amp;amp; p.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i &amp;lt;= numRows; i++) { for (int j = 1; j &amp;lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i &amp;lt;= numRows; i++) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for (int j = 1; j &amp;lt;= i; j++) { tmp.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</guid><description>Link
class Solution { public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row &amp;lt;= rowIndex; row++) { for (int col = 1; col &amp;lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for (int col = 1; col &amp;lt;= rowIndex; col++) { ans.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</guid><description>Link
DP 要从下往上找，否则不一定是全局最优
2 3 4 6 5 1 4 1 8 3
class Solution { public int minimumTotal(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j &amp;lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt;= i; j++) { dp[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</guid><description>Link
可以把数据看成折线图，则所有上升之和为解
public int maxProfit(int[] prices) { int res = 0; for (int i = 0; i &amp;lt; prices.length - 1; i++) { if (prices[i + 1] &amp;gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP
public int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润 int[] dp1 = new int[n]; // 第i天卖掉的最大利润 int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i &amp;lt; n; i++) { // 可以不买或卖 dp1[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/123/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/123/</guid><description>Link
public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: 持有第一股的最大利益 // dp[0][1]: 售出第一股的最大利益 // dp[0][2]: 持有第二股的最大利益 // dp[0][3]: 售出第二股的最大利益 int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/198/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/198/</guid><description>
Link
class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: 第一个房间抢 // dp[0][1]: 第一个房间不抢 int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i &amp;lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/213/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/213/</guid><description>Link
class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j) private int help(int[] nums, int i, int j) { // 0 : 抢 // 1 : 不抢 int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i &amp;lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</guid><description>Link
使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]
[1] -&amp;gt; [2 3 5] -&amp;gt; [3 4 5 6 10] -&amp;gt; &amp;hellip;
class Solution { // Time Complexity: O(3N * lg3N) // 每次产生 最小数的2、3、5倍数 public int nthUglyNumber(int n) { PriorityQueue&amp;lt;Long&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); q.add(1L); long top = -1L; for (int i = 0; i &amp;lt; n; i++) { top = q.peek(); while (!q.isEmpty() &amp;amp;&amp;amp; q.peek() == top) { q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</guid><description>Link
DP
public int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润 int[] dp1 = new int[n + 1]; // i天买入的最大利润 int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出) dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入) dp2[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/44/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/44/</guid><description>Link
f[i][j]：表示s[0..i]和p[0..j]是否匹配
public boolean isMatch(String s, String p) { int m = s.length(), n = p.length(); s = &amp;#34; &amp;#34; + s; p = &amp;#34; &amp;#34; + p; boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (p.charAt(j) == &amp;#39;*&amp;#39;) { f[i][j] = (i &amp;gt; 0 &amp;amp;&amp;amp; f[i - 1][j]) || f[i][j - 1]; } else { f[i][j] = i &amp;gt; 0 &amp;amp;&amp;amp; f[i - 1][j - 1] &amp;amp;&amp;amp; (s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/45/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/45/</guid><description>
Link
public int jump(int[] nums) { int n = nums.length; // f[i]: 最少的跳跃次数到达i int[] f = new int[n]; for (int i = 1, j = 0; i &amp;lt; n; i++) { while (j + nums[j] &amp;lt; i) j++; f[i] = f[j] + 1; } return f[n - 1]; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/509/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/509/</guid><description>
Link
public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i &amp;lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/53/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/53/</guid><description>Link
分治思想：分成两部分，求出左右两边的最大子数组和，在求出(左区间包含左区间里最后一个数的最大子数组和) + (右区间包含右区间里的第一个数的最大子数组和)，答案就是三者里的最大值。
// 分治思相：来自数据结构与算法C语言描述 class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { return help(nums, 0, nums.size() - 1); } int help(vector&amp;lt;int&amp;gt;&amp;amp; nums, int l, int r) { if (l == r) { return nums[l]; } int mid = (l + r) &amp;gt;&amp;gt; 1; int maxSubArrayLeft = help(nums, l, mid); int maxSubArrayRight = help(nums, mid + 1, r); int s1 = nums[mid], s2 = nums[mid]; for (int i = mid - 1; i &amp;gt;= l; i--) { s2 += nums[i]; if (s2 &amp;gt; s1) s1 = s2; } int maxCenterSum = s1; s2 = s1 = nums[mid + 1]; for (int i = mid + 2; i &amp;lt;= r; i++) { s2 += nums[i]; if (s2 &amp;gt; s1) s1 = s2; } maxCenterSum += s1; return max(maxSubArrayLeft, max(maxSubArrayRight, maxCenterSum)); } }; DP思想：f[i]表示0.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/55/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/55/</guid><description>
Link
class Solution { public boolean canJump(int[] nums) { for (int i = 0, j = 0; i &amp;lt; nums.length; i++) { if (j &amp;lt; i) return false; j = Math.max(j, i + nums[i]); } return true; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</guid><description>Link
DP
dp[i][j] 表示能到i行j列不同路径个数
初始化第一行和和第一列为1
public int uniquePaths(int m, int n) { int[][] f = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 || j == 0) { f[i][j] = 1; } else { f[i][j] = f[i - 1][j] + f[i][j - 1]; } } } return f[m - 1][n - 1]; } DFS+记忆化</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/63/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/63/</guid><description>Link
同
62题题思路一样
直接看DP解法，注意初始化，有障碍物时，就不能往后走了
class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &amp;lt; m &amp;amp;&amp;amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j &amp;lt; n &amp;amp;&amp;amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i &amp;lt; m; i++) { for (int j = 1; j &amp;lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } public int uniquePathsWithObstacles(int[][] o) { int m = o.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/64/</guid><description>Link
dp[i][j] 表示到i行j列最小总和 注意初始化
class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int k = i; k &amp;gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j &amp;lt; n; j++) { for (int k = j; k &amp;gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i &amp;lt; m; i++) { for (int j = 1; j &amp;lt; n; j++) { dp[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/70/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/70/</guid><description>
Link
public int climbStairs(int n) { int p1 = 1, p2 = 1; while (--n &amp;gt; 0) { int t = p1 + p2; p2 = p1; p1 = t; } return p1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</guid><description>
Link
第i天买入的最大利润buy[i]
卖出的最大利润sell[i]
卖出的时候(完成了一笔交易)减去手续费
class Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/72/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/72/</guid><description>Link
f[i][j]: 表示word1[0..i]和word2[0..j]最小操作数
考虑6种情况, 修改w1、插入w1、删除w1，最后合并修改和插入操作
public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); word1 = &amp;#34; &amp;#34; + word1; word2 = &amp;#34; &amp;#34; + word2; int[][] f = new int[m + 1][n + 1]; for (int i = 0; i &amp;lt;= m; i++) f[i][0] = i; for (int i = 0; i &amp;lt;= n; i++) f[0][i] = i; for (int i = 1; i &amp;lt;= m; i++) for (int j = 1; j &amp;lt;= n; j++) { f[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</guid><description>Link
DFS搜索 + 记忆化 class Solution { private Map&amp;lt;String, Integer&amp;gt; memo = new HashMap&amp;lt;&amp;gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i &amp;gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i &amp;lt; n - 1 &amp;amp;&amp;amp; isValid(s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/greedy/135/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/greedy/135/</guid><description>Link
int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; res(ratings.size(), 1); for (int i = 0; i &amp;lt; ratings.size() - 1; i++) { if (ratings[i + 1] &amp;gt; ratings[i]) { res[i + 1] = res[i] + 1; } } for (int i = ratings.size() - 1; i &amp;gt; 0; i--) { if (ratings[i - 1] &amp;gt; ratings[i]) { res[i - 1] = max(res[i - 1], res[i] + 1); } } return std::accumulate(res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/greedy/435/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/greedy/435/</guid><description>int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { if (intervals.empty()) return 0; std::sort(intervals.begin(), intervals.end(), [](vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { return a[1] &amp;lt; b[1]; }); int res = 0; int start = intervals[0][0], end = intervals[0][1]; for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i][0] &amp;lt; end) { res++; } else { end = intervals[i][1]; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/greedy/455/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/greedy/455/</guid><description>
Link
int findContentChildren(vector&amp;lt;int&amp;gt;&amp;amp; g, vector&amp;lt;int&amp;gt;&amp;amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int res = 0; for (int i = 0, j = 0; i &amp;lt; s.size() &amp;amp;&amp;amp; j &amp;lt; g.size(); i++) { if (s[i] &amp;gt;= g[j]) { res++; j++; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/hashtable/49/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/hashtable/49/</guid><description>
Link
public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) { Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (String str : strs) { String oldStr = str; char[] chs = str.toCharArray(); Arrays.sort(chs); str = new String(chs); List&amp;lt;String&amp;gt; tmp = map.getOrDefault(str, null); if (tmp == null) { tmp = new ArrayList&amp;lt;&amp;gt;(); map.put(str, tmp); } tmp.add(oldStr); } List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for (var e : map.entrySet()) { res.add(e.getValue()); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/1046/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/1046/</guid><description>Link
// Time Complexity: O(nlogn) // Space Complexity: O(n) public int lastStoneWeight(int[] stones) { PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() &amp;gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/347/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/347/</guid><description>Link
public int[] topKFrequent(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() &amp;lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() &amp;gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/451/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/451/</guid><description>Link
public String frequencySort(String s) { Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue&amp;lt;Character&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i &amp;lt; n; i++) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/19/</guid><description>
Link
public ListNode removeNthFromEnd(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; int n = 0; while (head != null) { n++; head = head.next; } ListNode prev = dummy; for (int i = 0; i &amp;lt; (n - k); i++) { prev = prev.next; } prev.next = prev.next.next; return dummy.next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/2/</guid><description>Link
public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode curr = dummy; int t = 0; while (l1 != null || l2 != null || t != 0) { if (l1 != null) { t += l1.val; l1 = l1.next; } if (l2 != null) { t += l2.val; l2 = l2.next; } curr.next = new ListNode(t % 10); t /= 10; curr = curr.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/21/</guid><description>Link
public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode prev = dummy; while (l1 != null &amp;amp;&amp;amp; l2 != null) { if (l1.val &amp;lt; l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } if (l1 != null) { prev.next = l1; } if (l2 != null) { prev.next = l2; } return dummy.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/23/</guid><description>Link
class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode dummy = new ListNode(); PriorityQueue&amp;lt;ListNode&amp;gt; minHeap = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; a.val - b.val); for (var l : lists) { if (l != null) { // 示例3 特例 minHeap.offer(l); } } ListNode tail = dummy; while (!minHeap.isEmpty()) { ListNode cur = minHeap.poll(); tail.next = cur; tail = tail.next; cur = cur.next; if (cur != null) { minHeap.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/24/</guid><description>
Link
public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy; p.next != null &amp;amp;&amp;amp; p.next.next != null;) { ListNode a = p.next; ListNode b = p.next.next; p.next = b; a.next = b.next; b.next = a; p = a; } return dummy.next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/25/</guid><description>Link
public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy;;) { int n = 0; for (ListNode t = p.next; t != null; t = t.next) { n++; } if (n &amp;lt; k) { break; } // 翻转k个节点 ListNode a = p.next, b = p.next.next; for (int i = 0; i &amp;lt; k - 1; i++) { var c = b.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/61/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/61/</guid><description>Link
public ListNode rotateRight(ListNode head, int k) { if (head == null) return head; int n = 0; ListNode tail = head; for (var p = head; p != null; p = p.next) { n++; tail = p; } k = k % n; if (k == 0) return head; ListNode p = head; for (int i = 0; i &amp;lt; n - 1 - k; i++) { p = p.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/83/</guid><description>Link
public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while (cur != null &amp;amp;&amp;amp; cur.next != null) { if (cur.val == cur.next.val) { cur.next = cur.next.next; } else { cur = cur.next; } } return head; } public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; ListNode dummy = new ListNode(-1, head); ListNode p = dummy.next; for (ListNode cur = head.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/linkedlist/86/</guid><description>
Link
ListNode* partition(ListNode* head, int x) { auto p1 = new ListNode(); auto c1 = p1; auto p2 = new ListNode(); auto c2 = p2; for (auto p = head; p; p = p-&amp;gt;next) { if (p-&amp;gt;val &amp;lt; x) { c1-&amp;gt;next = p; c1 = p; } else { c2-&amp;gt;next = p; c2 = p; } } c1-&amp;gt;next = p2-&amp;gt;next; c2-&amp;gt;next = nullptr; return p1-&amp;gt;next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/1979/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/1979/</guid><description>
Link
public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a &amp;gt; b private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</guid><description>
Link
常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。
第一轮：1/n
第二轮：(n-1)/n * 1/(n-1)
第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)
…………
private int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i &amp;lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/39/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/39/</guid><description>Link
List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList&amp;lt;&amp;gt;(), 0); return res; } private void dfs(int[] candidates, int target, List&amp;lt;Integer&amp;gt; cur, int s) { if (target &amp;lt; 0) { return; } if (target == 0) { res.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = s; i &amp;lt; candidates.length; i++) { if (candidates[i] &amp;gt; target) break; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i); cur.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/40/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/40/</guid><description>Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList&amp;lt;&amp;gt;(), 0); return res; } private void dfs(int[] candidates, int target, List&amp;lt;Integer&amp;gt; cur, int s) { if (target == 0) { res.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = s; i &amp;lt; candidates.length; i++) { if (candidates[i] &amp;gt; target) break; if (i &amp;gt; s &amp;amp;&amp;amp; candidates[i] == candidates[i - 1]) continue; cur.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/43/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/43/</guid><description>Link
string multiply(string num1, string num2) { int n = num1.size(), m = num2.size(); vector&amp;lt;int&amp;gt; A, B; for (int i = n - 1; i &amp;gt;= 0; i--) A.push_back(num1[i] - &amp;#39;0&amp;#39;); for (int i = m - 1; i &amp;gt;= 0; i--) B.push_back(num2[i] - &amp;#39;0&amp;#39;); vector&amp;lt;int&amp;gt; C(n + m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) C[i + j] += A[i] * B[j]; for (int i = 0, t = 0; i &amp;lt; C.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/46/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/46/</guid><description>
Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); boolean[] st; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) { st = new boolean[nums.length]; dfs(new ArrayList&amp;lt;&amp;gt;(), nums); return res; } private void dfs(List&amp;lt;Integer&amp;gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } for (int i = 0; i &amp;lt; nums.length; i++) { if (st[i]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/47/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/47/</guid><description>Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); boolean[] st; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) { Arrays.sort(nums); st = new boolean[nums.length]; dfs(new ArrayList&amp;lt;&amp;gt;(), nums); return res; } private void dfs(List&amp;lt;Integer&amp;gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } for (int i = 0; i &amp;lt; nums.length; i++) { if (st[i]) continue; if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</guid><description>Link
class Solution { private int m; private int n; private int count; private Map&amp;lt;Integer, Integer&amp;gt; map; /** 转成一维数组 索引i 相当于=&amp;gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =&amp;gt; 5 =&amp;gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =&amp;gt; 6 =&amp;gt; 3 map[5] = 4 map[3] = map[4] = 5 ... .</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/60/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/60/</guid><description>Link
当n=4, k=9时，从1-4按顺序选取一个数，剩下的数组合情况有 (n - 1)!
例: - 当选取1为第一位时，就有 3!=6种情况, k=9 &amp;gt; 6 显然第k位不是这种情况，此时减去这6种情况考虑下个数。
- 当选取2为第一位时，就 3!=6种情况, k=3 《 6 显然是这种情况，继续判断剩下的数。
class Solution { public String getPermutation(int n, int k) { boolean[] st = new boolean[10]; StringBuilder res = new StringBuilder(); for (int i = 0; i &amp;lt; n; i++) { int fact = 1; for (int j = 1; j &amp;lt;= n - i - 1; j++) fact *= j; for (int j = 1; j &amp;lt;= n; j++) { if (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/61/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/61/</guid><description>
Link
public int[] plusOne(int[] digits) { int[] res = new int[digits.length + 1]; int idx = digits.length; for (int i = digits.length - 1, t = 1; i &amp;gt;= 0 || t &amp;gt; 0; i--) { if (i &amp;gt;= 0) t += digits[i]; res[idx--] = t % 10; t /= 10; } return Arrays.copyOfRange(res, idx + 1, res.length); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/67/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/67/</guid><description>Link
public String addBinary(String a, String b) { StringBuilder sa = new StringBuilder(a); sa.reverse(); StringBuilder sb = new StringBuilder(b); sb.reverse(); StringBuilder res = new StringBuilder(); for (int i = 0, t = 0; i &amp;lt; a.length() || i &amp;lt; b.length() || t != 0; i++) { if (i &amp;lt; sa.length()) t += (sa.charAt(i) - &amp;#39;0&amp;#39;); if (i &amp;lt; sb.length()) t += (sb.charAt(i) - &amp;#39;0&amp;#39;); res.append(t % 2); t /= 2; } return res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/812/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/812/</guid><description>Link
看评论区都用线性代数，没学过线性代数的我，泪目了哭！
public double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i &amp;lt; points.length; i++) { for (int j = i + 1; j &amp;lt; points.length; j++) { for (int k = j + 1; k &amp;lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp &amp;gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b &amp;gt; c) || (a + c &amp;gt; b) || (b + c) &amp;gt; a; } // 果断找个公式，海伦公式 private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/1/</guid><description>
Link
public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int another = target - nums[i]; if (map.containsKey(another)) { return new int[]{i, map.get(another)}; } map.put(nums[i], i); } return null; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/1005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/1005/</guid><description>Link
写的实在是太丑陋了, 太多边界条件不易写
class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // 最小&amp;gt;0的数索引 for (int n : nums) { if (n &amp;lt; 0) i++; else break; } int j = i - 1; // 最大负数索引 int negCount = i; int idx = negCount - i; while (k &amp;gt; 0) { if (negCount &amp;gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i &amp;lt; nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/22/</guid><description>
Link
class Solution { private List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;String&amp;gt; generateParenthesis(int n) { dfs(n, 0, 0, &amp;#34;&amp;#34;); return res; } private void dfs(int n, int open, int closed, String s) { if (open == n &amp;amp;&amp;amp; closed == n) { res.add(s); return; } if (open &amp;lt; n) { dfs(n, open + 1, closed, s + &amp;#34;(&amp;#34;); } if (closed &amp;lt; n &amp;amp;&amp;amp; closed &amp;lt; open) { dfs(n, open, closed + 1, s + &amp;#34;)&amp;#34;); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/29/</guid><description>Link
X / Y = K &amp;ndash;&amp;gt; X = YK &amp;ndash;&amp;gt; K假设K=(1110)2 则 X = Y * 2^3 + Y * 2^2 + Y * 2^1 即logK个数相加
class Solution { public int divide(int dividend, int divisor) { int flag = 1; if (dividend &amp;lt; 0 &amp;amp;&amp;amp; divisor &amp;gt; 0 || dividend &amp;gt; 0 &amp;amp;&amp;amp; divisor &amp;lt; 0) { flag = -1; } long a = Math.abs((long)dividend), b = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/31/</guid><description>
Link
class Solution { // 从前往后找第一次降序的位置k // 从k开始找较k-1大的数，交换 // 反转(k, end) public void nextPermutation(int[] nums) { int n = nums.length; int k = n - 1; while (k &amp;gt; 0 &amp;amp;&amp;amp; nums[k - 1] &amp;gt;= nums[k]) k--; if (k &amp;lt;= 0) { reverse(nums, 0, n - 1); } else { int t = k; while (t &amp;lt; n &amp;amp;&amp;amp; nums[t] &amp;gt; nums[k - 1]) t++; swap(nums, k - 1, t - 1); reverse(nums, k, n - 1); } } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } // [begin, end] private void reverse(int[] nums, int begin, int end) { for (int i = 0; i &amp;lt; (end - begin + 1) / 2; i++) { swap(nums, begin + i, end - i); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/36/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/36/</guid><description>Link
class Solution { public boolean isValidSudoku(char[][] board) { boolean[] st = new boolean[10]; // 判断行 for (int i = 0; i &amp;lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j &amp;lt; 9; j++) { if (board[i][j] != &amp;#39;.&amp;#39;) { int t = board[i][j] - &amp;#39;0&amp;#39;; if (st[t]) return false; st[t] = true; } } } // 判断列 for (int i = 0; i &amp;lt; 9; i++) { Arrays.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/37/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/37/</guid><description>Link
class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init for (int i = 0; i &amp;lt; 9; i++) for (int j = 0; j &amp;lt; 9; j++) { if (board[i][j] != &amp;#39;.&amp;#39;) { int t = board[i][j] - &amp;#39;1&amp;#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/383/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/383/</guid><description>
Link
class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - &amp;#39;a&amp;#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - &amp;#39;a&amp;#39;] &amp;lt;= 0) return false; count[c - &amp;#39;a&amp;#39;]--; } return true; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/48/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/48/</guid><description>
Link
public void rotate(int[][] matrix) { int n = matrix.length; // 沿着对角线翻转 for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; i; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } // 沿着中心列翻转 for (int row = 0; row &amp;lt; n; row++) { for (int i = 0, j = n - 1; i &amp;lt; j; i++, j--) { int tmp = matrix[row][i]; matrix[row][i] = matrix[row][j]; matrix[row][j] = tmp; } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/50/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/50/</guid><description>
Link
public double myPow(double x, int n) { boolean isMinus = false; if (n &amp;lt; 0) { isMinus = true; } double res = 1; for (long k = (long)Math.abs((long)n); k != 0; k &amp;gt;&amp;gt;= 1) { if ((k &amp;amp; 0x1) == 0x1) { res *= x; } x *= x; } if (isMinus) { return 1 / res; } else { return res; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/56/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/56/</guid><description>Link
class Solution { public int[][] merge(int[][] intervals) { int n = intervals.length; int[][] res = new int[n][2]; Arrays.sort(intervals, (a, b) -&amp;gt; { if (a[0] == b[0]) { return a[1] - b[1]; } return a[0] - b[0]; }); int idx = 0; int l = intervals[0][0], r = intervals[0][1]; for (int i = 1; i &amp;lt; n; i++) { if (intervals[i][0] &amp;gt; r) { res[idx++] = new int[]{l, r}; l = intervals[i][0]; r = intervals[i][1]; } else { r = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/57/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/57/</guid><description>Link
class Solution { public int[][] insert(int[][] a, int[] b) { if (a.length == 0) return new int[][]{{b[0], b[1]}}; int n = a.length; int[][] res = new int[n + 1][2]; int idx = 0; int k = 0; // 处理左边完全没有交集的情况 while (k &amp;lt; n &amp;amp;&amp;amp; a[k][1] &amp;lt; b[0]) { res[idx++] = new int[]{a[k][0], a[k][1]}; k++; } // 处理交集 if (k &amp;lt; n) { b[0] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5963/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5963/</guid><description>TODO: Link
class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; s.charAt(i) == &amp;#39;0&amp;#39;) { i--; } for ( ; i &amp;gt;= 0; i--) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5965/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5965/</guid><description>TODO: Link
稍微优化下还是超时，放弃
class Solution { Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i &amp;lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List&amp;lt;Integer&amp;gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; arr.length; i++) { // if (i == begin) continue; if (arr[begin] == arr[i]) { list.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5967/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5967/</guid><description>
Link
public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i &amp;lt; chs.length; i++) { if (chs[i] == &amp;#39;a&amp;#39;) { x = i; } else if (y == -1 &amp;amp;&amp;amp; chs[i] == &amp;#39;b&amp;#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x &amp;lt; y; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5968/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5968/</guid><description>Link
class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i &amp;lt; m - 1; i++) { if (!bank[i].contains(&amp;#34;1&amp;#34;)) { continue; } int t = calculate(bank, i); // 计算这一行符合的激光束数量 if (t &amp;gt; 0) { // update result for (int j = 0; j &amp;lt; n; j++) { if (bank[i].</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5969/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5969/</guid><description> [Link]
class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t &amp;lt; a) { return false; } else { t += a; } } return true; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/7/</guid><description>
Link
public int reverse(int x) { // java 这里-11 % 10 = -1 数学上应该是 9 int flag = 1; if (x &amp;lt; 0) { flag = -1; x = -x; } int res = 0; while (x != 0) { if (res &amp;gt; ((Integer.MAX_VALUE - (x % 10)) / 10)) { return 0; } res = res * 10 + (x % 10); x /= 10; } return res * flag; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/748/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/748/</guid><description>Link
public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = &amp;#34;&amp;#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) &amp;amp;&amp;amp; word.length() &amp;lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i &amp;lt; a1.length; i++) { if (a1[i] &amp;gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/9/</guid><description>
Link
public boolean isPalindrome(int x) { if (x &amp;lt; 0) { return false; } int y = x; int res = 0; while (x &amp;gt; 0) { res = res * 10 + (x % 10); x /= 10; } return res == y; } public boolean isPalindrome(int x) { String s = String.valueOf(x); return s.equals(new StringBuilder(s).reverse().toString()); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/recursion/1492/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/recursion/1492/</guid><description>
Link
public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f &amp;gt;= n &amp;amp;&amp;amp; k &amp;gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/139/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/139/</guid><description>Link
遍历字符串，将其分成两部分left和right，判断是否都在wordList里。
加上记忆化
public boolean wordBreak(String s, List&amp;lt;String&amp;gt; wordDict) { Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(wordDict); Map&amp;lt;String, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set&amp;lt;String&amp;gt; set, Map&amp;lt;String, Boolean&amp;gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i &amp;lt; n; i++) { String left = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/17/</guid><description>Link
使用StringBuilder优化字符串copy
class Solution { List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); String[] keyboards = new String[]{ &amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;abc&amp;#34;, &amp;#34;def&amp;#34;, &amp;#34;ghi&amp;#34;, &amp;#34;jkl&amp;#34;, &amp;#34;mno&amp;#34;, &amp;#34;pqrs&amp;#34;, &amp;#34;tuv&amp;#34;, &amp;#34;wxyz&amp;#34;, }; public List&amp;lt;String&amp;gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), new StringBuilder()); return res; } private void dfs(String digits, int pos, int len, StringBuilder cur) { if (pos == len) { res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/216/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/216/</guid><description>Link
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; cur; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum3(int k, int n) { dfs(k, n, 1); return res; } void dfs(int k, int target, int s) { if (target &amp;lt; 0) return; if (cur.size() == k) { if (target == 0) res.push_back(cur); return; } for (int i = s; i &amp;lt;= 9; i++) { if (target - i &amp;lt; 0) continue; cur.push_back(i); dfs(k, target - i, i + 1); cur.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/37/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/37/</guid><description>Link
class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init for (int i = 0; i &amp;lt; 9; i++) for (int j = 0; j &amp;lt; 9; j++) { if (board[i][j] != &amp;#39;.&amp;#39;) { int t = board[i][j] - &amp;#39;1&amp;#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/51/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/51/</guid><description>Link
class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; int n; vector&amp;lt;bool&amp;gt; col, dg, udg; vector&amp;lt;string&amp;gt; path; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solveNQueens(int _n) { n = _n; col = vector&amp;lt;bool&amp;gt;(n); dg = vector&amp;lt;bool&amp;gt;(n * 2); udg = vector&amp;lt;bool&amp;gt;(n * 2); path = vector&amp;lt;string&amp;gt;(n, string(n, &amp;#39;.&amp;#39;)); dfs(0); return res; } void dfs(int u) { if (u == n) { res.push_back(path); return; } for (int i = 0; i &amp;lt; n; i++) { if (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/52/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/52/</guid><description>Link
class Solution { boolean[] col, dg, udg; int n; public int totalNQueens(int n) { this.n = n; col = new boolean[n]; dg = new boolean[n * 2]; udg = new boolean[n * 2]; return dfs(0); } private int dfs(int u) { if (u == n) { return 1; } int res = 0; for (int i = 0; i &amp;lt; n; i++) { if (!col[i] &amp;amp;&amp;amp; !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/5964/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/5964/</guid><description>TODO: Link
class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i &amp;lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i &amp;lt; len; i++) { if (checkAndRun(pos, s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/77/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/77/</guid><description>
Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); int n, k; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { this.n = n; this.k = k; dfs(1); return res; } private void dfs(int s) { if (cur.size() == k) { res.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = s; i &amp;lt;= n; i++) { cur.add(i); dfs(i + 1); cur.remove(cur.size() - 1); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/78/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/78/</guid><description>Link
集合的每个元素，都有可以选或不选。
例如二进制: 001 表示选择第一个元数, 011 选择第一个第二元素
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int n = nums.length; for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; n); i++) { List&amp;lt;Integer&amp;gt; path = new ArrayList&amp;lt;&amp;gt;(); for (int j = 0; j &amp;lt; n; j++) if (((i &amp;gt;&amp;gt; j) &amp;amp; 1) == 1) path.add(nums[j]); res.add(new ArrayList&amp;lt;&amp;gt;(path)); } return res; } DFS
class Solution { private List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) { res = new ArrayList&amp;lt;&amp;gt;(); dfs(nums, 0, new ArrayList&amp;lt;&amp;gt;()); return res; } private void dfs(int[] nums, int s, List&amp;lt;Integer&amp;gt; cur) { res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/79/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/79/</guid><description>Link
class Solution { public boolean exist(char[][] board, String word) { char[] chs = word.toCharArray(); for (int i = 0; i &amp;lt; board.length; i++) { for (int j = 0; j &amp;lt; board[i].length; j++) { if (dfs(board, chs, i, j, 0)) return true; } } return false; } private int[] dx = {0, 0, 1, -1}, dy = {1, -1, 0, 0}; private boolean dfs(char[][] board, char[] word, int x, int y, int u) { if (board[x][y] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/search/90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/search/90/</guid><description>Link
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; cur; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); dfs(nums, 0); return res; } void dfs(vector&amp;lt;int&amp;gt;&amp;amp; nums, int s) { res.push_back(cur); for (int i = s; i &amp;lt; nums.size(); i++) { if (i &amp;gt; s &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; cur.push_back(nums[i]); dfs(nums, i + 1); cur.pop_back(); } } }; class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/12/</guid><description>Link
public String intToRoman(int num) { int[] values = new int[]{ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; String[] chs = new String[]{ &amp;#34;I&amp;#34;, &amp;#34;IV&amp;#34;, &amp;#34;V&amp;#34;, &amp;#34;IX&amp;#34;, &amp;#34;X&amp;#34;, &amp;#34;XL&amp;#34;, &amp;#34;L&amp;#34;, &amp;#34;XC&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;CD&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;CM&amp;#34;, &amp;#34;M&amp;#34; }; StringBuilder sb = new StringBuilder(); for (int i = values.length - 1; i &amp;gt;= 0; i--) { while (num &amp;gt;= values[i]) { num -= values[i]; sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/13/</guid><description>Link
public int romanToInt(String s) { Map&amp;lt;Character, Integer&amp;gt; hash = new HashMap&amp;lt;&amp;gt;(); hash.put(&amp;#39;I&amp;#39;, 1); hash.put(&amp;#39;V&amp;#39;, 5); hash.put(&amp;#39;X&amp;#39;, 10); hash.put(&amp;#39;L&amp;#39;, 50); hash.put(&amp;#39;C&amp;#39;, 100); hash.put(&amp;#39;D&amp;#39;, 500); hash.put(&amp;#39;M&amp;#39;, 1000); int res = 0; int n = s.length(); for (int i = 0; i &amp;lt; n; i++) { if (i + 1 &amp;lt; n &amp;amp;&amp;amp; hash.get(s.charAt(i)) &amp;lt; hash.get(s.charAt(i + 1))) { res = res + (-hash.get(s.charAt(i))); } else { res = res + hash.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/38/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/38/</guid><description>
Link
public String countAndSay(int n) { String res = &amp;#34;1&amp;#34;; for (int i = 2; i &amp;lt;= n; i++) { StringBuilder t = new StringBuilder(); int m = res.length(); for (int j = 0; j &amp;lt; m; ) { int k = j + 1; while (k &amp;lt; m &amp;amp;&amp;amp; res.charAt(j) == res.charAt(k)) k++; t.append(k - j).append(res.charAt(j)); j = k; } res = t.toString(); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/54/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/54/</guid><description>
Link
class Solution { public List&amp;lt;Integer&amp;gt; spiralOrder(int[][] matrix) { List&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); int n = matrix.length, m = matrix[0].length; int[] dx = new int[]{0, 1, 0, -1}; int[] dy = new int[]{1, 0, -1, 0}; boolean[][] st = new boolean[n][m]; for (int i = 0, d = 0, x = 0, y = 0; i &amp;lt; n * m; i++) { ans.add(matrix[x][y]); st[x][y] = true; int a = x + dx[d], b = y + dy[d]; if (a &amp;lt; 0 || a &amp;gt;= n || b &amp;lt; 0 || b &amp;gt;= m || st[a][b]) { d = (d + 1) % 4; a = x + dx[d]; b = y + dy[d]; } x = a; y = b; } return ans; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/59/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/59/</guid><description>Link
class Solution { public int[][] generateMatrix(int n) { int[][] res = new int[n][n]; int[] dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0}; for (int i = 1, x = 0, y = 0, d = 0; i &amp;lt;= n * n; i++) { res[x][y] = i; int a = x + dx[d], b = y + dy[d]; if (a &amp;lt; 0 || a &amp;gt;= n || b &amp;lt; 0 || b &amp;gt;= n || res[a][b] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/simulation/73/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/simulation/73/</guid><description>
Link
public void setZeroes(int[][] matrix) { int m = matrix.length, n = matrix[0].length; // 将第一行和第一列看成 (m - 1) * (n - 1) 行和列为0的标识 // 再用两个变量标识第一行和第一列 int r1 = 1, c1 = 1; for (int i = 0; i &amp;lt; n; i++) { if (matrix[0][i] == 0) { r1 = 0; break; } } for (int i = 0; i &amp;lt; m; i++) { if (matrix[i][0] == 0) { c1 = 0; break; } } // 设置列 for (int i = 1; i &amp;lt; m; i++) for (int j = 0; j &amp;lt; n; j++) if (matrix[i][j] == 0) matrix[0][j] = 0; // 设置行 for (int i = 0; i &amp;lt; n; i++) for (int j = 1; j &amp;lt; m; j++) if (matrix[j][i] == 0) matrix[j][0] = 0; // 设置 (m - 1) * (n - 1) for (int i = 1; i &amp;lt; m; i++) if (matrix[i][0] == 0) for (int j = 1; j &amp;lt; n; j++) matrix[i][j] = 0; for (int i = 1; i &amp;lt; n; i++) if (matrix[0][i] == 0) for (int j = 1; j &amp;lt; m; j++) matrix[j][i] = 0; if (r1 == 0) for (int i = 0; i &amp;lt; n; i++) matrix[0][i] = 0; if (c1 == 0) for (int i = 0; i &amp;lt; m; i++) matrix[i][0] = 0; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/sorts/148/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/sorts/148/</guid><description>Link
TODO: 最佳实践归并排序
快速排序 Time Complexity: nlgn 最坏n^2 Space Complexity: O(n)
class Solution { private ListNode[] arr; private void quickSort(int l, int r) { if (l &amp;gt;= r) return; int i = l - 1, j = r + 1; int x = arr[(l + r) &amp;gt;&amp;gt; 1].val; while (i &amp;lt; j) { do i++; while (arr[i].val &amp;lt; x); do j--; while (arr[j].val &amp;gt; x); if (i &amp;lt; j) { int t = arr[i].</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/sorts/215/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/sorts/215/</guid><description>Link
快速选择
class Solution { public int findKthLargest(int[] nums, int k) { return quickSelect(nums, k, 0, nums.length - 1); } private int quickSelect(int[] nums, int k, int l, int r) { if (l &amp;gt;= r) return nums[l]; int i = l - 1, j = r + 1, x = nums[(l + r) &amp;gt;&amp;gt; 1]; while (i &amp;lt; j) { do i++; while(nums[i] &amp;lt; x); do j--; while(nums[j] &amp;gt; x); if (i &amp;lt; j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } // 右边区间元素个数 if (r - j &amp;gt;= k) { return quickSelect(nums, k, j + 1, r); } return quickSelect(nums, k - (r - j), l, j); } } 使用优先队列</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/sorts/41/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/sorts/41/</guid><description>Link
class Solution { public int firstMissingPositive(int[] nums) { for (int i = 0; i &amp;lt; nums.length; i++) { while (nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] != i + 1 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.length &amp;amp;&amp;amp; nums[i] != nums[nums[i] - 1]) { int tmp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = tmp; } } for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/stack/20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/stack/20/</guid><description>Link
查阅Ascii码表进行简化
public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int n = s.length(); for (int i = 0; i &amp;lt; n; i++) { if (s.charAt(i) == &amp;#39;(&amp;#39; || s.charAt(i) == &amp;#39;{&amp;#39; || s.charAt(i) == &amp;#39;[&amp;#39;) { st.push(s.charAt(i)); } else { if (st.size() &amp;gt; 0 &amp;amp;&amp;amp; Math.abs(st.peek() - s.charAt(i)) &amp;lt;= 2) { st.pop(); } else { return false; } } } return st.size() == 0; } public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int n = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/stack/32/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/stack/32/</guid><description>Link
public int longestValidParentheses(String s) { Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int n = s.length(); int result = 0; for (int i = 0, start = -1; i &amp;lt; n; i++) { if (s.charAt(i) == &amp;#39;(&amp;#39;) { st.push(i); } else { if (st.isEmpty()) { start = i; } else { st.pop(); if (st.isEmpty()) { result = Math.max(result, i - start); } else { result = Math.max(result, i - st.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/stack/42/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/stack/42/</guid><description>Link
Detail
public int trap(int[] height) { Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;&amp;gt;(); int ans = 0; for (int i = 0; i &amp;lt; height.length; i++) { while (!st.isEmpty() &amp;amp;&amp;amp; height[st.peek()] &amp;lt; height[i]) { int cur = st.pop(); if (st.isEmpty()) break; int l = st.peek(); int r = i; int h = Math.min(height[l], height[r]) - height[cur]; ans += (r - l - 1) * h; } st.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/14/</guid><description>
Link
public String longestCommonPrefix(String[] strs) { StringBuilder sb = new StringBuilder(); int n = strs[0].length(); for (int i = 0; i &amp;lt; n; i++) { char c = strs[0].charAt(i); for (int j = 1; j &amp;lt; strs.length; j++) { if (i &amp;gt;= strs[j].length() || c != strs[j].charAt(i)) { return sb.toString(); } } sb.append(c); } return sb.toString(); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/28/</guid><description>Link
public int strStr(String s, String p) { int m = p.length(); if (m == 0) return 0; int n = s.length(); s = &amp;#34; &amp;#34; + s; p = &amp;#34; &amp;#34; + p; int[] next = new int[m + 1]; for (int i = 2, j = 0; i &amp;lt;= m; i++) { while (j != 0 &amp;amp;&amp;amp; p.charAt(i) != p.charAt(j + 1)) j = next[j]; if ( p.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/5/</guid><description>Link
暴力
class Solution { public String longestPalindrome(String s) { int n = s.length(); if (n == 1) return s; String res = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; n; i++) { for (int j = i; j &amp;lt; n; j++) { if ((j - i + 1) &amp;gt; res.length() &amp;amp;&amp;amp; isPalindrome(s, i, j)) { res = s.substring(i, j + 1); } } } return res; } private boolean isPalindrome(String s, int i, int j) { while (i &amp;lt; j) { if (s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/58/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/58/</guid><description>
Link
public int lengthOfLastWord(String s) { int j = s.length() - 1; while (s.charAt(j) == &amp;#39; &amp;#39;) j--; int i = j; while (i &amp;gt;= 0 &amp;amp;&amp;amp; s.charAt(i) != &amp;#39; &amp;#39;) i--; return j - i; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/6/</guid><description>Link
转成索引排列，找出规律
public String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i &amp;lt; numRows; i++) { if (i == 0 || i == numRows - 1) { for (int j = i; j &amp;lt; n; j += 2 * numRows - 2) { sb.append(s.charAt(j)); } } else { for (int j = i, k = 2 * numRows - 2 - i; j &amp;lt; n || k &amp;lt; n; j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j &amp;lt; n) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/65/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/65/</guid><description>Link
public boolean isNumber(String s) { if (s.charAt(0) == &amp;#39;+&amp;#39; || s.charAt(0) == &amp;#39;-&amp;#39;) s = s.substring(1); // 空符号 if (s.length() == 0) return false; // 有效小数判断 if (s.charAt(0) == &amp;#39;.&amp;#39; &amp;amp;&amp;amp; (s.length() == 1 || s.charAt(1) == &amp;#39;e&amp;#39; || s.charAt(1) == &amp;#39;E&amp;#39;)) return false; int dot = 0, e = 0; for (int i = 0; i &amp;lt; s.length(); i++) { if (s.charAt(i) == &amp;#39;.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/68/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/68/</guid><description>Link
public List&amp;lt;String&amp;gt; fullJustify(String[] words, int maxWidth) { List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; words.length; i++) { int j = i + 1; int len = words[i].length(); // 判断下一个单词能否放下 while (j &amp;lt; words.length &amp;amp;&amp;amp; len + 1 + words[j].length() &amp;lt;= maxWidth) len += 1 + words[j++].length(); StringBuilder line = new StringBuilder(); // 已经没有单词能放了 if (j == words.length || j == i + 1) { // 左对齐 line.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/string/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/string/8/</guid><description>Link
class Solution { public int myAtoi(String s) { int k = 0; int n = s.length(); while (k &amp;lt; n &amp;amp;&amp;amp; s.charAt(k) == &amp;#39; &amp;#39;) { k++; } if (k == n) { return 0; } int minus = 1; if (s.charAt(k) == &amp;#39;-&amp;#39;) { minus = -1; k++; } else if (s.charAt(k) == &amp;#39;+&amp;#39;) { k++; } int res = 0; while (k &amp;lt; n &amp;amp;&amp;amp; s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tips/</guid><description>摩尔投票算法
#
/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/102/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/102/</guid><description>
Link
考虑当前层结束条件，即当前队列中的元素个数。
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); int count = q.size(); while (count &amp;gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/1305/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/1305/</guid><description>Link
中序遍历
vector&amp;lt;int&amp;gt; getAllElements(TreeNode* root1, TreeNode* root2) { vector&amp;lt;int&amp;gt; ans; vector&amp;lt;int&amp;gt; t1, t2; dfs(root1, t1); dfs(root2, t2); int i = 0, j = 0; for (; i &amp;lt; t1.size() &amp;amp;&amp;amp; j &amp;lt; t2.size(); ) { if (t1[i] &amp;lt; t2[j]) { ans.push_back(t1[i++]); } else { ans.push_back(t2[j++]); } } while (i &amp;lt; t1.size()) { ans.push_back(t1[i++]); } while (j &amp;lt; t2.size()) { ans.push_back(t2[j++]); } return ans; } void dfs(TreeNode *root, vector&amp;lt;int&amp;gt; &amp;amp;t) { if (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</guid><description>
Link 一道简单的搜索
public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i &amp;lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</guid><description>
Link
递归搜索
class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val &amp;gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/1011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/1011/</guid><description>class Solution { public: int shipWithinDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int days) { int max_weight = 0, total_weight = 0; for (auto w : weights) { if (w &amp;gt; max_weight) max_weight = w; total_weight += w; } int lo = max_weight, hi = total_weight; while (lo &amp;lt; hi) { int mid = (lo + hi) &amp;gt;&amp;gt; 1; if (check(weights, mid, days)) { hi = mid; } else { lo = mid + 1; } } return lo; } bool check(vector&amp;lt;int&amp;gt; &amp;amp;weights, int cap, int days) { int total = 0; int need_days = 1; for (auto w : weights) { if (total + w &amp;gt; cap) { total = w; need_days++; } else { total += w; } } // std::cout &amp;lt;&amp;lt; &amp;#34;cap: &amp;#34; &amp;lt;&amp;lt; cap &amp;lt;&amp;lt; need_days &amp;lt;&amp;lt; std::endl; return need_days &amp;lt;= days; } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/11/</guid><description>
Link
public int maxArea(int[] height) { int res = 0; for (int i = 0, j = height.length - 1; i &amp;lt; j; ) { res = Math.max(res, Math.min(height[i], height[j]) * (j - i)); if (height[i] &amp;lt; height[j]) { i++; } else { j--; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/15/</guid><description>Link
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Arrays.sort(nums); for (int i = 0; i &amp;lt; nums.length; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1, k = nums.length - 1; j &amp;lt; k; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) { continue; } while (j &amp;lt; k - 1 &amp;amp;&amp;amp; nums[i] + nums[j] + nums[k - 1] &amp;gt;= 0) { // 找靠近左边第一个&amp;gt;=的k索引 k--; } if (nums[i] + nums[j] + nums[k] == 0) { res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/16/</guid><description>Link
public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i &amp;lt; nums.length; i++) { int j = i + 1, k = nums.length - 1; while (j &amp;lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum &amp;gt; target) { k--; } else { j++; } if (Math.abs(target - sum) &amp;lt; Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/18/</guid><description>Link
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i &amp;lt; n; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j &amp;lt; n; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) { continue; } for (int k = j + 1, u = n - 1; k &amp;lt; u; k++) { if (k &amp;gt; j + 1 &amp;amp;&amp;amp; nums[k] == nums[k - 1]) { continue; } while (k &amp;lt; u - 1 &amp;amp;&amp;amp; nums[i] + nums[j] + nums[k] + nums[u - 1] &amp;gt;= target) { u--; } if (nums[i] + nums[j] + nums[k] + nums[u] == target) { res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/2226/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/2226/</guid><description>
Link
假设x为每个小孩分到的糖果数，当x变大时堆数变小(即可满足的小孩数), x变小时堆变大。
class Solution { typedef long long LL; public: int maximumCandies(vector&amp;lt;int&amp;gt;&amp;amp; candies, long long k) { LL total = 0; for (auto c : candies) total += c; LL lo = 0, hi = total / k; while (lo &amp;lt; hi) { LL x = lo + hi + 1 &amp;gt;&amp;gt; 1; // check LL sum = 0; for (auto c : candies) { sum += (c / x); } if (sum &amp;gt;= k) { lo = x; } else { hi = x - 1; } } return lo; } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/26/</guid><description>
Link
public int removeDuplicates(int[] nums) { int j = 0; for (int i = 0; i &amp;lt; nums.length; i++) { if (i == 0 || nums[i] != nums[i - 1]) { nums[j++] = nums[i]; } } return j; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/27/</guid><description>
Link
public int removeElement(int[] nums, int val) { int j = 0; for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] != val) { nums[j++] = nums[i]; } } return j; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/3/</guid><description>Link
int lengthOfLongestSubstring(string s) { int res = 0; unordered_map&amp;lt;char, int&amp;gt; m; int n = s.length(); for (int i = 0, j = 0; i &amp;lt; n; i++) { m[s[i]]++; while (m[s[i]] &amp;gt; 1) m[s[j++]]--; if (i - j + 1 &amp;gt; res) res = i - j + 1; } return res; } public int lengthOfLongestSubstring(String s) { Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int res = 0; int n = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/30/</guid><description>Link
滑动窗口 + Hash
public List&amp;lt;Integer&amp;gt; findSubstring(String s, String[] words) { List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int n = s.length(), m = words.length; if (m == 0) { return res; } int w = words[0].length(); Map&amp;lt;String, Integer&amp;gt; tot = new HashMap&amp;lt;&amp;gt;(); for (String word : words) tot.put(word, tot.getOrDefault(word, 0) + 1); for (int i = 0; i &amp;lt; w; i++) { Map&amp;lt;String, Integer&amp;gt; wd = new HashMap&amp;lt;&amp;gt;(); int cnt = 0; for (int j = i; j + w &amp;lt;= n; j += w) { if (j &amp;gt;= i + m * w) { String word = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/33/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/33/</guid><description>Link
public int search(int[] nums, int target) { // 找到分隔点, 一半区间满足性质，另一半则不满足 // 2 3 4 5 6 7, 1 // 6 7, 1 2 3 4 5 int l = 0, r = nums.length - 1; int mid; while (l &amp;lt; r) { mid = (l + r + 1) &amp;gt;&amp;gt; 1; if (nums[mid] &amp;gt;= nums[0]) { l = mid; } else { r = mid - 1; } } // 判断在左半边、右半边 if (target &amp;gt;= nums[0]) { l = 0; } else { l = r + 1; r = nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/34/</guid><description>Link
class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int l = 0, r = nums.length - 1; int mid; while (l &amp;lt; r) { mid = (l + r) &amp;gt;&amp;gt; 1; if (nums[mid] &amp;gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[l] != target) { return new int[]{-1, -1}; } int[] res = new int[2]; res[0] = l; l = 0; r = nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/35/</guid><description>
Link
public int searchInsert(int[] nums, int target) { int lo = 0, hi = nums.length, mid = 0; while (lo &amp;lt; hi) { mid = (lo + hi) &amp;gt;&amp;gt; 1; if (nums[mid] &amp;gt;= target) { hi = mid; } else { lo = mid + 1; } } return lo; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/4/</guid><description>Link
public double findMedianSortedArrays(int[] nums1, int[] nums2) { int k = nums1.length + nums2.length; if (k % 2 == 0) { int left = findKth(nums1, 0, nums2, 0, k / 2); int right = findKth(nums1, 0, nums2, 0, k / 2 + 1); return (left + right) / 2.0; } else { return findKth(nums1, 0, nums2, 0, k / 2 + 1); } } // 二分做法 private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { if (nums1.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/69/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/69/</guid><description>
Link
public int mySqrt(int x) { if (x == 0) return 0; int l = 1, r = x; while (l &amp;lt; r) { int mid = (int) ((l + 1L + r) &amp;gt;&amp;gt; 1); if (mid &amp;lt;= x / mid) { l = mid; } else { r = mid - 1; } } return l; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/74/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/74/</guid><description>Link
看成一个一维数组的二分搜索过程
public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int l = 0, r = m * n - 1; while (l &amp;lt; r) { int mid = l + r &amp;gt;&amp;gt; 1; if (matrix[mid / n][mid % n] &amp;gt;= target) r = mid; else l = mid + 1; } return matrix[r / n][r % n] == target; } 从右上角看成一个二分搜索树 O(m * n)</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/75/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/75/</guid><description>
Link
class Solution { public void sortColors(int[] nums) { for (int i = 0, j = 0, k = nums.length - 1; i &amp;lt;= k; ) { if (nums[i] == 0) { swap(nums, i, j); j++; i++; } else if (nums[i] == 2) { swap(nums, i, k); k--; } else { i++; } } } private void swap(int[] nums, int i, int j) { int t = nums[i]; nums[i] = nums[j]; nums[j] = t; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/76/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/76/</guid><description>Link
C++ map数组形式访问时会自动插入不存在的元数 值为默认
string minWindow(string s, string t) { unordered_map&amp;lt;char, int&amp;gt; hs, ht; for (auto c : t) ht[c]++; string res = &amp;#34;&amp;#34;; int cnt = 0; for (int i = 0, j = 0; i &amp;lt; s.size(); i++) { hs[s[i]]++; if (hs[s[i]] &amp;lt;= ht[s[i]]) { cnt++; } while (hs[s[j]] &amp;gt; ht[s[j]]) hs[s[j++]]--; if (cnt == t.size()) { if (!res.size() || i - j + 1 &amp;lt; res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/80/</guid><description>
Link
public int removeDuplicates(int[] nums) { int k = 0; for (int x : nums) { if (k &amp;lt; 2 || (nums[k - 1] != x || nums[k - 2] != x)) { nums[k++] = x; } } return k; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/twopointers/87/</guid><description>
Link
public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1, j = n - 1; int k = m + n - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;gt;= 0) { if (nums1[i] &amp;gt; nums2[j]) { nums1[k--] = nums1[i--]; } else { nums1[k--] = nums2[j--]; } } while (j &amp;gt;= 0) { nums1[k--] = nums2[j--]; } }</description></item></channel></rss>