<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Day Day Up</title><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/</link><description>Recent content on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</guid><description>
Link
上图是从右上角，同理左下角
class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] &amp;lt; target) { col++; } else { row--; } } return false; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</guid><description>
Link
class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if (root == null) return res; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null] while (q.peek() != null) { TreeNode node; List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList&amp;lt;Integer&amp;gt; tmp = new LinkedList&amp;lt;&amp;gt;(); int n = res.size(); for (int i = q.size(); i &amp;gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</guid><description>
Link
class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</guid><description>
Link
class Solution { public char firstUniqChar(String s) { Map&amp;lt;Character, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - &amp;#39;a&amp;#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return &amp;#39; &amp;#39;; } }</description></item></channel></rss>