<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Day Day Up</title><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/</link><description>Recent content on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/</guid><description>
Link
vector&amp;lt;int&amp;gt; reversePrint(ListNode* head) { vector&amp;lt;int&amp;gt; res; while (head) { res.push_back(head-&amp;gt;val); head = head-&amp;gt;next; } return vector&amp;lt;int&amp;gt;(res.rbegin(), res.rend()); } public int[] reversePrint(ListNode head) { Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;&amp;gt;(); while (head != null) { s.push(head.val); head = head.next; } int[] res = new int[s.size()]; int idx = 0; while (!s.isEmpty()) { res[idx++] = s.pop(); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/</guid><description>
Link
将元素放置到对应的位置。2代表下标为2的位置
int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0; i &amp;lt; nums.size(); i++) { while (nums[i] != i) { if (nums[i] == nums[nums[i]]) return nums[i]; swap(nums[i], nums[nums[i]]); } } return -1; } int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0; i &amp;lt; nums.size();) { if (nums[i] == i) { i++; continue; } if (nums[i] == nums[nums[i]]) return nums[i]; swap(nums[i], nums[nums[i]]); } return -1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</guid><description>Link
上图是从右上角，同理左下角
从右上角看成一个二分搜索树
bool searchArray(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; array, int target) { if (array.size() == 0) { return false; } int m = array.size(); int n = array[0].size(); int i = 0, j = n - 1; while (i &amp;lt; m &amp;amp;&amp;amp; j &amp;gt;= 0) { if (array[i][j] == target) { return true; } else if (array[i][j] &amp;lt; target) { i++; } else { j--; } } return false; } public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/</guid><description>
Link
C语言需要注意内存分配，先求出空格数量，在计算出需要的内存大小。
public String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i &amp;lt; n; i++) { if (s.charAt(i) == &amp;#39; &amp;#39;) { sb.append(&amp;#34;%20&amp;#34;); } else { sb.append(s.charAt(i)); } } return sb.toString(); } string replaceSpace(string s) { string res = &amp;#34;&amp;#34;; for (char c : s) { if (c == &amp;#39; &amp;#39;) res += &amp;#34;%20&amp;#34;; else res += c; } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/06/</guid><description>
Link
vector&amp;lt;int&amp;gt; reversePrint(ListNode* head) { vector&amp;lt;int&amp;gt; res; for (auto p = head; p != NULL; p = p-&amp;gt;next) { res.push_back(p-&amp;gt;val); } reverse(res.begin(), res.end()); return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/09/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/09/</guid><description>
Link
class CQueue { private: stack&amp;lt;int&amp;gt; s1, s2; public: CQueue() { } void appendTail(int value) { s1.push(value); } int deleteHead() { if (s1.empty()) return -1; while (s1.size() &amp;gt; 1) { s2.push(s1.top()); s1.pop(); } int res = s1.top(); s1.pop(); while (!s2.empty()) { s1.push(s2.top()); s2.pop(); } return res; } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/11/</guid><description>
Link
这个二分要按特定的格式？
int minArray(vector&amp;lt;int&amp;gt;&amp;amp; numbers) { int l = 0, r = numbers.size() - 1; while (l &amp;lt; r) { int m = (l + r) &amp;gt;&amp;gt; 1; if (numbers[m] &amp;lt; numbers[r]) r = m; else if (numbers[m] &amp;gt; numbers[r]) l = m + 1; else r--; } return numbers[l]; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/</guid><description>Link
public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i &amp;lt; 0 || i &amp;gt;= board.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/</guid><description>Link
简单DFS
class Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x &amp;gt;= m || x &amp;lt; 0 || y &amp;gt;= n || y &amp;lt; 0) return 0; if (visited[x][y] || !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/</guid><description>
Link
public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n &amp;amp; 0x1); n &amp;gt;&amp;gt;&amp;gt;= 1; } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/</guid><description>
Link
class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/</guid><description>
Link
public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i &amp;lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/</guid><description>
Link
public ListNode getKthFromEnd(ListNode head, int k) { Stack&amp;lt;ListNode&amp;gt; s = new Stack&amp;lt;&amp;gt;(); while (head != null) { s.push(head); head = head.next; } if (k &amp;gt; s.size()) return null; ListNode res = null; while (k &amp;gt; 0) { k--; res = s.pop(); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/24/</guid><description>
Link
ListNode* reverseList(ListNode* head) { auto dummy = new ListNode(-1); dummy-&amp;gt;next = NULL; auto p = dummy; while (head != NULL) { auto t = head-&amp;gt;next; head-&amp;gt;next = p-&amp;gt;next; p-&amp;gt;next = head; head = t; } return dummy-&amp;gt;next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/</guid><description>Link
public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null &amp;amp;&amp;amp; cur2 != null) { if (cur1.val &amp;lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/</guid><description>
Link
class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) &amp;amp;&amp;amp; help(A.right, B.right); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/30/</guid><description>
Link
class MinStack { private: stack&amp;lt;int&amp;gt; s1, s2; public: /** initialize your data structure here. */ MinStack() { } void push(int x) { if (s2.empty() || x &amp;lt;= s2.top()) { s2.push(x); } s1.push(x); } void pop() { if (s1.top() == s2.top()) { s2.pop(); } s1.pop(); } int top() { return s1.top(); } int min() { return s2.top(); } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</guid><description>Link
vector&amp;lt;int&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;int&amp;gt; res; queue&amp;lt;TreeNode*&amp;gt; q; if (root) q.push(root); while (!q.empty()) { auto n = q.size(); for (int i = 0; i &amp;lt; n; i++) { auto p = q.front(); q.pop(); res.push_back(p-&amp;gt;val); if (p-&amp;gt;left) q.push(p-&amp;gt;left); if (p-&amp;gt;right) q.push(p-&amp;gt;right); } } return res; } class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); while (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</guid><description>Link
vector&amp;lt;int&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;int&amp;gt; res; queue&amp;lt;TreeNode*&amp;gt; q; if (root) q.push(root); while (!q.empty()) { auto n = q.size(); for (int i = 0; i &amp;lt; n; i++) { auto p = q.front(); q.pop(); res.push_back(p-&amp;gt;val); if (p-&amp;gt;left) q.push(p-&amp;gt;left); if (p-&amp;gt;right) q.push(p-&amp;gt;right); } } return res; } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if (root == null) return res; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</guid><description>Link
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; queue&amp;lt;TreeNode*&amp;gt; q; if (root) q.push(root); int level = 0; while (q.size() &amp;gt; 0) { vector&amp;lt;int&amp;gt; tmp; int n = q.size(); for (int i = 0; i &amp;lt; n; i++) { auto p = q.front(); q.pop(); tmp.push_back(p-&amp;gt;val); if (p-&amp;gt;left) q.push(p-&amp;gt;left); if (p-&amp;gt;right) q.push(p-&amp;gt;right); } if (level % 2 == 1) reverse(tmp.begin(), tmp.end()); level++; res.push_back(tmp); } return res; } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); if (root !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/35/</guid><description>
Link
Node* copyRandomList(Node* head) { unordered_map&amp;lt;Node*, Node*&amp;gt; m; Node *dummy = new Node(-1); auto tail = dummy; for (auto p = head; p != nullptr; p = p-&amp;gt;next) { tail-&amp;gt;next = new Node(p-&amp;gt;val); tail = tail-&amp;gt;next; m[p] = tail; } for (auto p = head; p != nullptr; p = p-&amp;gt;next) { m[p]-&amp;gt;random = m[p-&amp;gt;random]; } return dummy-&amp;gt;next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/</guid><description>Link
DFS
public int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start &amp;gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - &amp;#39;0&amp;#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start &amp;lt; str.length() - 1) { // 06 if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - &amp;#39;0&amp;#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= 25; } 动态规划</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</guid><description>
Link
class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/</guid><description>
Link
双指针
public int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map&amp;lt;Character, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); while (j &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</guid><description>Link
char firstUniqChar(string s) { vector&amp;lt;int&amp;gt; count(26, 0); for (char c : s) { count[c - &amp;#39;a&amp;#39;]++; } for (char c : s) { if (count[c - &amp;#39;a&amp;#39;] == 1) return c; } return &amp;#39; &amp;#39;; } class Solution { public char firstUniqChar(String s) { Map&amp;lt;Character, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - &amp;#39;a&amp;#39;]++; map.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/53/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/53/</guid><description>Link
双指针
int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { if (nums.size() == 0) return 0; int l = 0, r = nums.size() - 1; while (l &amp;lt; r) { int m = (l + r) &amp;gt;&amp;gt; 1; if (nums[m] &amp;gt;= target) { r = m; } else { l = m + 1; } } if (nums[l] != target) return 0; int i = l; l = 0; r = nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/</guid><description>Link
DFS
private int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack
public int kthLargest(TreeNode root, int k) { Queue&amp;lt;Integer&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/</guid><description>
Link
public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/</guid><description>
Link
public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) &amp;lt; 2 &amp;amp;&amp;amp; (isBalanced(root.left) &amp;amp;&amp;amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/</guid><description>
Link
public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i &amp;lt; j) { if (nums[i] + nums[j] &amp;lt; target) { i++; } else if (nums[i] + nums[j] &amp;gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/</guid><description>
Link
public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i &amp;gt;= 0) { while(i &amp;gt;= 0 &amp;amp;&amp;amp; chs[i] != &amp;#39; &amp;#39;) i--; sb.append(s.substring(i + 1, j + 1) + &amp;#34; &amp;#34;); while (i &amp;gt;= 0 &amp;amp;&amp;amp; chs[i] == &amp;#39; &amp;#39;) i--; j = i; } return sb.toString().trim(); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58_2/</guid><description>
Link
string reverseLeftWords(string s, int k) { k = k % s.size(); return s.substr(k) + s.substr(0, k); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/</guid><description>
Link
public int sumNums(int n) { boolean tmp = n &amp;gt; 1 &amp;amp;&amp;amp; (n += sumNums(n - 1)) &amp;gt; 0; return n; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/</guid><description>
Link
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val &amp;lt; root.val &amp;amp;&amp;amp; q.val &amp;lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val &amp;gt; root.val &amp;amp;&amp;amp; q.val &amp;gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/</guid><description>Link
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;amp;&amp;amp; right != null) { return root; } return left == null ? right : left; } 任意k个数的最近公共祖先
private int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/</guid><description>
Link
通过二分查找，判断左右区间的个数
int duplicateInArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int l = 1, r = nums.size() - 1; while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; int cnt = 0; for (auto x : nums) { if (x &amp;gt;= l &amp;amp;&amp;amp; x &amp;lt;= mid) { cnt++; } } if (cnt &amp;gt; mid - l + 1) { r = mid; } else { l = mid + 1; } } return l; }</description></item></channel></rss>