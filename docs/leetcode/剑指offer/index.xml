<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Day Day Up</title><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/</link><description>Recent content on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/</guid><description>
Link
vector&amp;lt;int&amp;gt; reversePrint(ListNode* head) { vector&amp;lt;int&amp;gt; res; while (head) { res.push_back(head-&amp;gt;val); head = head-&amp;gt;next; } return vector&amp;lt;int&amp;gt;(res.rbegin(), res.rend()); } public int[] reversePrint(ListNode head) { Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;&amp;gt;(); while (head != null) { s.push(head.val); head = head.next; } int[] res = new int[s.size()]; int idx = 0; while (!s.isEmpty()) { res[idx++] = s.pop(); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/</guid><description>
Link
将元素放置到对应的位置。2代表下标为2的位置
int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0; i &amp;lt; nums.size(); i++) { while (nums[i] != i) { if (nums[i] == nums[nums[i]]) return nums[i]; swap(nums[i], nums[nums[i]]); } } return -1; } int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0; i &amp;lt; nums.size();) { if (nums[i] == i) { i++; continue; } if (nums[i] == nums[nums[i]]) return nums[i]; swap(nums[i], nums[nums[i]]); } return -1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</guid><description>Link
上图是从右上角，同理左下角
从右上角看成一个二分搜索树
bool searchArray(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; array, int target) { if (array.size() == 0) { return false; } int m = array.size(); int n = array[0].size(); int i = 0, j = n - 1; while (i &amp;lt; m &amp;amp;&amp;amp; j &amp;gt;= 0) { if (array[i][j] == target) { return true; } else if (array[i][j] &amp;lt; target) { i++; } else { j--; } } return false; } public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/</guid><description>
Link
C语言需要注意内存分配，先求出空格数量，在计算出需要的内存大小。
public String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i &amp;lt; n; i++) { if (s.charAt(i) == &amp;#39; &amp;#39;) { sb.append(&amp;#34;%20&amp;#34;); } else { sb.append(s.charAt(i)); } } return sb.toString(); } string replaceSpace(string s) { string res = &amp;#34;&amp;#34;; for (char c : s) { if (c == &amp;#39; &amp;#39;) res += &amp;#34;%20&amp;#34;; else res += c; } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/06/</guid><description>
Link
vector&amp;lt;int&amp;gt; reversePrint(ListNode* head) { vector&amp;lt;int&amp;gt; res; for (auto p = head; p != NULL; p = p-&amp;gt;next) { res.push_back(p-&amp;gt;val); } reverse(res.begin(), res.end()); return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/09/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/09/</guid><description>
Link
class CQueue { private: stack&amp;lt;int&amp;gt; s1, s2; public: CQueue() { } void appendTail(int value) { s1.push(value); } int deleteHead() { if (s1.empty()) return -1; while (s1.size() &amp;gt; 1) { s2.push(s1.top()); s1.pop(); } int res = s1.top(); s1.pop(); while (!s2.empty()) { s1.push(s2.top()); s2.pop(); } return res; } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/10/</guid><description>
Link
int fib(int n) { if (n &amp;lt;= 1) return n; int a = 0, b = 1; int k = 1e9 + 7; for (int i = 2; i &amp;lt;= n; i++) { int t = b; b = (a + b) % k; a = t % k; } return b; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/10_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/10_2/</guid><description>
Link
int numWays(int n) { if (n &amp;lt;= 1) return 1; int k = 1000000007; int a = 1, b = 1; for (int i = 2; i &amp;lt;= n; i++) { int t = b; b = (a + b) % k; a = t; } return b; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/11/</guid><description>
Link
这个二分要按特定的格式？
int minArray(vector&amp;lt;int&amp;gt;&amp;amp; numbers) { int l = 0, r = numbers.size() - 1; while (l &amp;lt; r) { int m = (l + r) &amp;gt;&amp;gt; 1; if (numbers[m] &amp;lt; numbers[r]) r = m; else if (numbers[m] &amp;gt; numbers[r]) l = m + 1; else r--; } return numbers[l]; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/</guid><description>Link
public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i &amp;lt; 0 || i &amp;gt;= board.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/</guid><description>Link
简单DFS
class Solution { private: int res_ = 0; int m_, n_, k_; public: int movingCount(int m, int n, int k) { vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; used(m, vector&amp;lt;bool&amp;gt;(n, false)); m_ = m; n_ = n; k_ = k; dfs(0, 0, used); return res_; } int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, 1, -1}; void dfs(int i, int j, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;used) { if (i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt;= m_ || j &amp;gt;= n_ || used[i][j]) return; if (calc(i, j) &amp;gt; k_) return; used[i][j] = true; res_++; for (int u = 0; u &amp;lt; 4; u++) { dfs(i + dx[u], j + dy[u], used); } } int calc(int x, int y) { int res = 0; while (x &amp;gt; 0) { res += x % 10; x /= 10; } while (y &amp;gt; 0) { res += y % 10; y /= 10; } return res; } }; class Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/</guid><description>
Link
public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n &amp;amp; 0x1); n &amp;gt;&amp;gt;&amp;gt;= 1; } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/</guid><description>Link
ListNode* deleteNode(ListNode* head, int val) { auto dummy = new ListNode(-1); auto p = dummy; while (head) { if (head-&amp;gt;val != val) { p-&amp;gt;next = head; p = head; } head = head-&amp;gt;next; } p-&amp;gt;next = nullptr; return dummy-&amp;gt;next; } class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/</guid><description>
Link
vector&amp;lt;int&amp;gt; exchange(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0, j = nums.size() - 1; i &amp;lt;= j;) { if (nums[i] % 2 == 1) { i++; } else { swap(nums[i], nums[j]); j--; } } return nums; } public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i &amp;lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/</guid><description>Link
ListNode* getKthFromEnd(ListNode* head, int k) { int n = 0; for (auto p = head; p != nullptr; p = p-&amp;gt;next) { n++; } k %= n; if (k == 0) return head; auto p1 = head, p2 = head; while (k-- &amp;gt; 0) { p1 = p1-&amp;gt;next; } while (p1) { p1 = p1-&amp;gt;next; p2 = p2-&amp;gt;next; } return p2; } public ListNode getKthFromEnd(ListNode head, int k) { Stack&amp;lt;ListNode&amp;gt; s = new Stack&amp;lt;&amp;gt;(); while (head !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/24/</guid><description>
Link
ListNode* reverseList(ListNode* head) { auto dummy = new ListNode(-1); dummy-&amp;gt;next = NULL; auto p = dummy; while (head != NULL) { auto t = head-&amp;gt;next; head-&amp;gt;next = p-&amp;gt;next; p-&amp;gt;next = head; head = t; } return dummy-&amp;gt;next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/</guid><description>Link
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { auto dummy = new ListNode(-1); auto p = dummy; for (; l1 &amp;amp;&amp;amp; l2; p = p-&amp;gt;next) { if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) { p-&amp;gt;next = l1; l1 = l1-&amp;gt;next; } else { p-&amp;gt;next = l2; l2 = l2-&amp;gt;next; } } if (l1) { p-&amp;gt;next = l1; } else if (l2) { p-&amp;gt;next = l2; } return dummy-&amp;gt;next; } public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/</guid><description>
Link
class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) &amp;amp;&amp;amp; help(A.right, B.right); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/27/</guid><description>
Link
TreeNode* mirrorTree(TreeNode* root) { if (!root) return root; TreeNode *leftRoot = mirrorTree(root-&amp;gt;left); TreeNode *rightRoot = mirrorTree(root-&amp;gt;right); root-&amp;gt;left = rightRoot; root-&amp;gt;right = leftRoot; return root; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/28/</guid><description>
Link
bool isSymmetric(TreeNode* root) { if (!root) return true; return help(root-&amp;gt;left, root-&amp;gt;right); } bool help(TreeNode *A, TreeNode *B) { if (!A &amp;amp;&amp;amp; !B) return true; if (!A || !B || A-&amp;gt;val != B-&amp;gt;val) return false; return help(A-&amp;gt;left, B-&amp;gt;right) &amp;amp;&amp;amp; help(A-&amp;gt;right, B-&amp;gt;left); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/30/</guid><description>
Link
class MinStack { private: stack&amp;lt;int&amp;gt; s1, s2; public: /** initialize your data structure here. */ MinStack() { } void push(int x) { if (s2.empty() || x &amp;lt;= s2.top()) { s2.push(x); } s1.push(x); } void pop() { if (s1.top() == s2.top()) { s2.pop(); } s1.pop(); } int top() { return s1.top(); } int min() { return s2.top(); } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</guid><description>Link
vector&amp;lt;int&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;int&amp;gt; res; queue&amp;lt;TreeNode*&amp;gt; q; if (root) q.push(root); while (!q.empty()) { auto n = q.size(); for (int i = 0; i &amp;lt; n; i++) { auto p = q.front(); q.pop(); res.push_back(p-&amp;gt;val); if (p-&amp;gt;left) q.push(p-&amp;gt;left); if (p-&amp;gt;right) q.push(p-&amp;gt;right); } } return res; } class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); while (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</guid><description>Link
vector&amp;lt;int&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;int&amp;gt; res; queue&amp;lt;TreeNode*&amp;gt; q; if (root) q.push(root); while (!q.empty()) { auto n = q.size(); for (int i = 0; i &amp;lt; n; i++) { auto p = q.front(); q.pop(); res.push_back(p-&amp;gt;val); if (p-&amp;gt;left) q.push(p-&amp;gt;left); if (p-&amp;gt;right) q.push(p-&amp;gt;right); } } return res; } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if (root == null) return res; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</guid><description>Link
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; queue&amp;lt;TreeNode*&amp;gt; q; if (root) q.push(root); int level = 0; while (q.size() &amp;gt; 0) { vector&amp;lt;int&amp;gt; tmp; int n = q.size(); for (int i = 0; i &amp;lt; n; i++) { auto p = q.front(); q.pop(); tmp.push_back(p-&amp;gt;val); if (p-&amp;gt;left) q.push(p-&amp;gt;left); if (p-&amp;gt;right) q.push(p-&amp;gt;right); } if (level % 2 == 1) reverse(tmp.begin(), tmp.end()); level++; res.push_back(tmp); } return res; } class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); if (root !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/34/</guid><description>
Link
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;int&amp;gt; cur; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; pathSum(TreeNode* root, int target) { dfs(root, target); return res; } void dfs(TreeNode *node, int target) { if (!node) return; int t = target - node-&amp;gt;val; cur.push_back(node-&amp;gt;val); if (t == 0 &amp;amp;&amp;amp; !node-&amp;gt;left &amp;amp;&amp;amp; !node-&amp;gt;right) { res.push_back(cur); } dfs(node-&amp;gt;left, t); dfs(node-&amp;gt;right, t); cur.pop_back(); } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/35/</guid><description>
Link
Node* copyRandomList(Node* head) { unordered_map&amp;lt;Node*, Node*&amp;gt; m; Node *dummy = new Node(-1); auto tail = dummy; for (auto p = head; p != nullptr; p = p-&amp;gt;next) { tail-&amp;gt;next = new Node(p-&amp;gt;val); tail = tail-&amp;gt;next; m[p] = tail; } for (auto p = head; p != nullptr; p = p-&amp;gt;next) { m[p]-&amp;gt;random = m[p-&amp;gt;random]; } return dummy-&amp;gt;next; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/36/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/36/</guid><description>
Link
记录前驱
class Solution { public: Node* treeToDoublyList(Node* root) { if (!root) return nullptr; prev = nullptr; head = nullptr; dfs(root); head-&amp;gt;left = prev; prev-&amp;gt;right = head; return head; } private: Node *prev, *head; void dfs(Node *node) { if (!node) return; dfs(node-&amp;gt;left); if (head == nullptr) { head = prev = node; } else { prev-&amp;gt;right = node; node-&amp;gt;left = prev; prev = node; } dfs(node-&amp;gt;right); } };</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/42/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/42/</guid><description>
Link
int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); int res = nums[0]; int prev = nums[0]; for (int i = 1; i &amp;lt; n; i++) { prev = max(prev + nums[i], nums[i]); res = max(res, prev); } return res; } int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; dp(n, 0); dp[0] = nums[0]; for (int i = 1; i &amp;lt; n; i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); } int res = dp[0]; for (int d : dp) res = max(d, res); return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/45/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/45/</guid><description>Link
public String minNumber(int[] nums) { String[] strs = new String[nums.length]; for (int i = 0; i &amp;lt; nums.length; ++i) { strs[i] = String.valueOf(nums[i]); } Arrays.sort(strs, (a, b) -&amp;gt; { return (a + b).compareTo(b + a); }); var sb = new StringBuilder(); for (var str : strs) { sb.append(str); } return sb.toString(); } class Solution { private void quickSort(String[] strs, int l, int r) { if (l &amp;gt;= r) return; int i = l - 1, j = r + 1; String x = strs[(l + r) &amp;gt;&amp;gt; 1]; while (i &amp;lt; j) { do i++; while ((strs[i] + x).</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/</guid><description>Link
int translateNum(int num) { string str = to_string(num); int n = str.size(); vector&amp;lt;int&amp;gt; dp(n + 1, 0); str = &amp;#34; &amp;#34; + str; dp[0] = 1; dp[1] = 1; for (int i = 2; i &amp;lt;= n; i++) { if (&amp;#39;1&amp;#39; == str[i - 1] || &amp;#39;2&amp;#39; == str[i - 1] &amp;amp;&amp;amp; str[i] &amp;lt;= &amp;#39;5&amp;#39;) { dp[i] = dp[i - 2] + dp[i - 1]; } else { dp[i] = dp[i - 1]; } } return dp[n]; } DFS</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</guid><description>Link
int maxValue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(), n = grid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { dp[i][j] = grid[i - 1][j - 1] + max(dp[i - 1][j], dp[i][j - 1]); } } return dp[m][n]; } class Solution { public int maxValue(int[][] grid) { int m = grid.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/</guid><description>Link
int lengthOfLongestSubstring(string s) { int res = 0; unordered_map&amp;lt;char, int&amp;gt; m; for (int i = 0, j = 0; i &amp;lt; s.size(); i++) { m[s[i]]++; while (m[s[i]] &amp;gt; 1) { m[s[j++]]--; } res = max(res, i - j + 1); } return res; } 双指针
public int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map&amp;lt;Character, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); while (j &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt; chs.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</guid><description>Link
char firstUniqChar(string s) { vector&amp;lt;int&amp;gt; count(26, 0); for (char c : s) { count[c - &amp;#39;a&amp;#39;]++; } for (char c : s) { if (count[c - &amp;#39;a&amp;#39;] == 1) return c; } return &amp;#39; &amp;#39;; } class Solution { public char firstUniqChar(String s) { Map&amp;lt;Character, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - &amp;#39;a&amp;#39;]++; map.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/52/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/52/</guid><description>
Link
注意没有公共节点可以看成，最后一个空节点为公共的
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { auto p = headA, q = headB; while (p != q) { p = (p == nullptr ? headB : p-&amp;gt;next); q = (q == nullptr ? headA : q-&amp;gt;next); } return p; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/53/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/53/</guid><description>Link
双指针
int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { if (nums.size() == 0) return 0; int l = 0, r = nums.size() - 1; while (l &amp;lt; r) { int m = (l + r) &amp;gt;&amp;gt; 1; if (nums[m] &amp;gt;= target) { r = m; } else { l = m + 1; } } if (nums[l] != target) return 0; int i = l; l = 0; r = nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/</guid><description>Link
中层遍历 的倒序
class Solution { private: int res_; int k_; public: int kthLargest(TreeNode* root, int k) { k_ = k; dfs(root); return res_; } void dfs(TreeNode *node) { if (!node) return; dfs(node-&amp;gt;right); if (-- k_ == 0) { res_ = node-&amp;gt;val; return; } dfs(node-&amp;gt;left); } }; DFS
private int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/</guid><description>
Link
public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/</guid><description>Link
bool isBalanced(TreeNode* root) { if (root == nullptr) return true; return abs(depth(root-&amp;gt;left) - depth(root-&amp;gt;right)) &amp;lt;= 1 &amp;amp;&amp;amp; isBalanced(root-&amp;gt;left) &amp;amp;&amp;amp; isBalanced(root-&amp;gt;right); } int depth(TreeNode *node) { if (node == nullptr) return 0; return max(depth(node-&amp;gt;left), depth(node-&amp;gt;right)) + 1; } public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) &amp;lt; 2 &amp;amp;&amp;amp; (isBalanced(root.left) &amp;amp;&amp;amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/</guid><description>
Link
vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int l = 0, r = nums.size() - 1; while (l &amp;lt; r) { auto t = nums[l] + nums[r]; if (t &amp;gt; target) { r--; } else if (t &amp;lt; target) { l++; } else { return {nums[l], nums[r]}; } } return {}; } public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i &amp;lt; j) { if (nums[i] + nums[j] &amp;lt; target) { i++; } else if (nums[i] + nums[j] &amp;gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/</guid><description>Link
string reverseWords(string s) { string res = &amp;#34;&amp;#34;; int i = 0; while (i &amp;lt; s.size()) { while (s[i] == &amp;#39; &amp;#39;) i++; int j = i; while (j &amp;lt; s.size() &amp;amp;&amp;amp; s[j] != &amp;#39; &amp;#39;) j++; auto t = s.substr(i, j - i); if (res == &amp;#34;&amp;#34;) res = t; else res = t + &amp;#34; &amp;#34; + res; i = j + 1; } i = 0; while (res[i] == &amp;#39; &amp;#39; &amp;amp;&amp;amp; i &amp;lt; res.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58_2/</guid><description>
Link
string reverseLeftWords(string s, int k) { k = k % s.size(); return s.substr(k) + s.substr(0, k); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/61/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/61/</guid><description>
Link
bool isStraight(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int min_ = 15, max_ = -1; unordered_set&amp;lt;int&amp;gt; set; for (auto n : nums) { if (n == 0) continue; min_ = min(n, min_); max_ = max(n, max_); if (set.find(n) != set.end()) return false; set.insert(n); } return max_ - min_ &amp;lt; 5; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/63/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/63/</guid><description>
Link
int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { if (prices.size() == 0) return 0; int res = 0; int minPrice = prices[0]; for (auto p : prices) { res = max(res, p - minPrice); minPrice = min(minPrice, p); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/</guid><description>
Link
public int sumNums(int n) { boolean tmp = n &amp;gt; 1 &amp;amp;&amp;amp; (n += sumNums(n - 1)) &amp;gt; 0; return n; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/</guid><description>
Link
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val &amp;lt; root.val &amp;amp;&amp;amp; q.val &amp;lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val &amp;gt; root.val &amp;amp;&amp;amp; q.val &amp;gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/</guid><description>Link
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;amp;&amp;amp; right != null) { return root; } return left == null ? right : left; } 任意k个数的最近公共祖先
private int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/</guid><description>
Link
通过二分查找，判断左右区间的个数
int duplicateInArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int l = 1, r = nums.size() - 1; while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; int cnt = 0; for (auto x : nums) { if (x &amp;gt;= l &amp;amp;&amp;amp; x &amp;lt;= mid) { cnt++; } } if (cnt &amp;gt; mid - l + 1) { r = mid; } else { l = mid + 1; } } return l; }</description></item></channel></rss>