[{"id":0,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"相关资源\r#\r\r  \rNo Starch Press\n  \rThe Pragmatic Bookshelf\n  \rManning\n  \rO\u0026rsquo;Reilly\n  \rLet Me Read\n  \rLibrary Genesis\n  \rSaltTiger 目前我主要在以下网站收集编程类电子书，大家去这上面找书就好，下载方法也一并给出：\n  \rCoderProg，点击验证码，跳转至Rapidgator或Turbobit网盘，将网盘链接复制到\r木薯牛网盘中转站（1G流量1.33元）进行中转，即可下载。\n  \rAvaxHome，跳转至icerbox网盘，将网盘链接复制到\r思飞网盘中转站（1G icerbox流量2.8元）进行中转，中转后自动转存到绑定的百度网盘，即可下载。\n  \rFox eBook，跳转至NitroFlare网盘，将网盘链接复制到\r木薯牛网盘中转站进行中转，即可下载。\n  \rLibrary Genesis，点击Mirrors链接直接下载。\n  \rLet Me Read，点击验证码，跳转DirectLink直接下载。\n    \rZlibrary\n  \rLeanpub\n  \rThe best Programming books\n  "},{"id":1,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"读书\r#\r\r 书籍是人类进步的阶梯\n 《Java并发编程的艺术》\n 2021/10/9 P280 ~ P304 2021/10/30 finish  《操作系统导论》\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 finish  《Build On Your Lisp》\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 finish  "},{"id":2,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  "},{"id":3,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":"Basic\r#\r\rQuick Sort\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } "},{"id":4,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Java并发编程艺术","section":"C S","content":"11.2 定位问题\r#\r\r线上代码定位问题\n11.3 性能测试\r#\r\r相关的命令\n"},{"id":5,"href":"/docs/cs/leetcode/206/","title":"206th","section":"C S","content":"public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; } "},{"id":6,"href":"/docs/cs/leetcode/21/","title":"21st","section":"C S","content":"ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = \u0026amp;dummy; while (p1 \u0026amp;\u0026amp; p2) { if (p1-\u0026gt;val \u0026gt; p2-\u0026gt;val) { cur-\u0026gt;next = p2; p2 = p2-\u0026gt;next; } else { cur-\u0026gt;next = p1; p1 = p1-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = p1 ? p1 : p2; return dummy.next; "},{"id":7,"href":"/docs/cs/leetcode/273/","title":"273rd","section":"C S","content":"class Solution { private final String[] LESS_THAN_20 = {\u0026#34;\u0026#34;, \u0026#34;One\u0026#34;, \u0026#34;Two\u0026#34;, \u0026#34;Three\u0026#34;, \u0026#34;Four\u0026#34;, \u0026#34;Five\u0026#34;, \u0026#34;Six\u0026#34;, \u0026#34;Seven\u0026#34;, \u0026#34;Eight\u0026#34;, \u0026#34;Nine\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Eleven\u0026#34;, \u0026#34;Twelve\u0026#34;, \u0026#34;Thirteen\u0026#34;, \u0026#34;Fourteen\u0026#34;, \u0026#34;Fifteen\u0026#34;, \u0026#34;Sixteen\u0026#34;, \u0026#34;Seventeen\u0026#34;, \u0026#34;Eighteen\u0026#34;, \u0026#34;Nineteen\u0026#34;}; private final String[] TENS = {\u0026#34;\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Twenty\u0026#34;, \u0026#34;Thirty\u0026#34;, \u0026#34;Forty\u0026#34;, \u0026#34;Fifty\u0026#34;, \u0026#34;Sixty\u0026#34;, \u0026#34;Seventy\u0026#34;, \u0026#34;Eighty\u0026#34;, \u0026#34;Ninety\u0026#34;}; private final String[] THOUSANDS = {\u0026#34;\u0026#34;, \u0026#34;Thousand\u0026#34;, \u0026#34;Million\u0026#34;, \u0026#34;Billion\u0026#34;}; public String numberToWords(int num) { if (num == 0) return \u0026#34;Zero\u0026#34;; int i = 0; String words = \u0026#34;\u0026#34;; while (num \u0026gt; 0) { if (num % 1000 != 0) words = helper(num % 1000) +THOUSANDS[i] + \u0026#34; \u0026#34; + words; num /= 1000; i++; } return words.trim(); } private String helper(int num) { if (num == 0) return \u0026#34;\u0026#34;; else if (num \u0026lt; 20) return LESS_THAN_20[num] + \u0026#34; \u0026#34;; else if (num \u0026lt; 100) return TENS[num / 10] + \u0026#34; \u0026#34; + helper(num % 10); else return LESS_THAN_20[num / 100] + \u0026#34; Hundred \u0026#34; + helper(num % 100); } } "},{"id":8,"href":"/docs/cs/leetcode/29/","title":"29th","section":"C S","content":"long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a \u0026lt; 0) sign *= -1; if (b \u0026lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a \u0026gt;= b) { long count = 1; long c = b; while ((c \u0026lt;\u0026lt; 1) \u0026lt;= a) { c \u0026lt;\u0026lt;= 1; count \u0026lt;\u0026lt;= 1; } quotient += count; a -= c; } if (sign * quotient \u0026gt; INT_MAX) { return INT_MAX; } return quotient*sign; "},{"id":9,"href":"/docs/cs/leetcode/46/","title":"46th","section":"C S","content":"public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;bool\u0026gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, vector\u0026lt;int\u0026gt;\u0026amp; cur, vector\u0026lt;bool\u0026gt;\u0026amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } } "},{"id":10,"href":"/docs/cs/leetcode/542/","title":"542nd","section":"C S","content":" 看成图，0为起点\n vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; updateMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat) { int m = mat.size(), n = mat[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(m, vector\u0026lt;int\u0026gt;(n, -1)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (int i = 0 ; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!Q.empty()) { pair\u0026lt;int, int\u0026gt; node = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { pair\u0026lt;int, int\u0026gt; neighbor = {node.first + dx[i], node.second + dy[i]}; if (neighbor.first \u0026lt; 0 || neighbor.first \u0026gt;= m || neighbor.second \u0026lt; 0 || neighbor.second \u0026gt;= n || dist[neighbor.first][neighbor.second] != -1) continue; dist[neighbor.first][neighbor.second] = dist[node.first][node.second] + 1; Q.push(neighbor); } } return dist; } "},{"id":11,"href":"/docs/cs/leetcode/77/","title":"77th","section":"C S","content":"public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(ans, 1, k, n, new ArrayList\u0026lt;\u0026gt;()); return ans; } private void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans, int start, int k, int n, List\u0026lt;Integer\u0026gt; cur) { if (cur.size() == k) { ans.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = start; i \u0026lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } } "},{"id":12,"href":"/docs/cs/leetcode/784/","title":"784th","section":"C S","content":"public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List\u0026lt;String\u0026gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); } "},{"id":13,"href":"/docs/cs/leetcode/tips/","title":"Tips","section":"C S","content":"摩尔投票算法\r#\r\r/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */ "},{"id":14,"href":"/docs/cs/linux/gdb/","title":"G D B","section":"C S","content":"GCC\r#\r\r  -E 获取预处理后的文件内容\n  -V 将编译、链接过程打印\n  -g 用于GDB调试\n  ltrace 命令用来跟踪程序运行时调用的库函数\n -S 查看系统调用 -e trace=write 只看write系统调用  strace 查看系统调用的封装函数\nGDB\r#\r\rSegment Fault快速定位\n首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core  list start ctrl + x + a  "},{"id":15,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt  输出当前用户是不是 root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  查看磁盘引导扇区 (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  统计所有 cpp 文件的行数\n find . | grep '\\.cpp$' | xargs cat | wc -l  统计命令行命令的频率\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  文件检索 - cat, more, less, head, tail, file, find\n  输入输出控制 - 重定向, 管道, tee, xargs\n  文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  正则表达式\n  系统监控 - jobs, ps, top, kill, free, demsg, lsof\n   如何比较两个文件是否完全相同?   diff or md5sum\n  如何列出一个C语言项目中所有被包含过的头文件?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n p@ssw0rd\n"},{"id":16,"href":"/docs/cs/linux/vim/","title":"Vim","section":"C S","content":" Vscode插件 Learn Vim  "},{"id":17,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"C S","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":18,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"C S","content":"Cargo\r#\r\r cargo new project-name  "},{"id":19,"href":"/docs/cs/referrals/","title":"Referrals","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \r📚 List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCS公开课程学习群课程推荐 \r克莱登大学CS(热心网友整理) \r🎓 Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos  "},{"id":20,"href":"/docs/leetcode/","title":"Leet Code","section":"Docs","content":"目前分类目录\r#\r\rDynamic Programming\r#\r\r \r122. Best Time to Buy and Sell Stock II(M) \r309. Best Time to Buy and Sell Stock with Cooldown(M) \r714. Best Time to Buy and Sell Stock with Transaction Fee(M)  Tree\r#\r\r \r559. Maximum Depth of N-ary Tree(E)  Math\r#\r\r \r384. Shuffle an Array(E)  DFS\r#\r\r \r139. Word Break(M)  "},{"id":21,"href":"/docs/leetcode/dfs/139/","title":"139th","section":"Leet Code","content":" \rLink\n 遍历字符串，将其分成两部分left和right，判断是否都在wordList里。\n加上记忆化\npublic boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(wordDict); Map\u0026lt;String, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set\u0026lt;String\u0026gt; set, Map\u0026lt;String, Boolean\u0026gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i \u0026lt; n; i++) { String left = s.substring(0, i); String right = s.substring(i, n); if (set.contains(left) \u0026amp;\u0026amp; dfs(right, set, map)) { map.put(s, true); return true; } } map.put(s, false); return false; } 最佳实践：使用Trie\npublic class TreeNode { TreeNode[] children; boolean isWord; char value; TreeNode() { children = new TreeNode[26]; } } private TreeNode root = new TreeNode(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { TreeNode node = root; for (char c : word.toCharArray()) { if (node.children[c - \u0026#39;a\u0026#39;] == null) { node.children[c - \u0026#39;a\u0026#39;] = new TreeNode(); } node.children[c - \u0026#39;a\u0026#39;].value = c; node = node.children[c - \u0026#39;a\u0026#39;]; } node.isWord = true; } return dfs(s, 0); } private int[] memo = new int[301]; private boolean dfs(String s, int cur) { // s[cur:]  int n = s.length(); if (cur \u0026gt;= n) return true; if (memo[cur] == 1) return false; TreeNode node = root; for (int i = cur; i \u0026lt; n; i++) { TreeNode tmp = node.children[s.charAt(i) - \u0026#39;a\u0026#39;]; node = tmp; if (tmp != null) { if (tmp.isWord \u0026amp;\u0026amp; dfs(s, i + 1)) { return true; } } else { break; } } memo[cur] = 1; return false; } "},{"id":22,"href":"/docs/leetcode/dynamicprogramming/122/","title":"122nd","section":"Leet Code","content":" \rLink\n 可以把数据看成折线图，则所有上升之和为解\npublic int maxProfit(int[] prices) { int res = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP\npublic int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润  int[] dp1 = new int[n]; // 第i天卖掉的最大利润  int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i \u0026lt; n; i++) { // 可以不买或卖  dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] + prices[i]); } return dp2[n - 1]; } "},{"id":23,"href":"/docs/leetcode/dynamicprogramming/309/","title":"309th","section":"Leet Code","content":" \rLink\n DP\npublic int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润  int[] dp1 = new int[n + 1]; // i天买入的最大利润  int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出)  dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入)  dp2[i] = Math.max(dp2[i - 1], dp1[i - 2] - prices[i - 1]); } return dp1[n]; } "},{"id":24,"href":"/docs/leetcode/dynamicprogramming/714/","title":"714th","section":"Leet Code","content":" \rLink\n 第i天买入的最大利润buy[i]\n卖出的最大利润sell[i]\n卖出的时候(完成了一笔交易)减去手续费\nclass Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } } "},{"id":25,"href":"/docs/leetcode/math/384/","title":"384th","section":"Leet Code","content":" \rLink\n 常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。\n第一轮：1/n\n第二轮：(n-1)/n * 1/(n-1)\n第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)\n…………\nprivate int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i \u0026lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; } "},{"id":26,"href":"/docs/leetcode/tree/559/","title":"559th","section":"Leet Code","content":" \rLink 一道简单的搜索\n public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i \u0026lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; } "},{"id":27,"href":"/docs/cs/leetcode/994/","title":"LeetCode 994","section":"C S","content":" 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。  public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue\u0026lt;int[]\u0026gt; Q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count \u0026gt; 0 \u0026amp;\u0026amp; !Q.isEmpty()) { times++; int curSize = Q.size(); for (int j = 0; j \u0026lt; curSize; j ++) { int[] node = Q.poll(); for (int i = 0; i \u0026lt; 4; i++) { int[] neighbor = new int[]{node[0] + dir[i][0], node[1] + dir[i][1]}; if (neighbor[0] \u0026lt; 0 || neighbor[1] \u0026lt; 0 || neighbor[0] \u0026gt;= m || neighbor[1] \u0026gt;= n || grid[neighbor[0]][neighbor[1]] != 1) continue; grid[neighbor[0]][neighbor[1]] = 2; fresh_count--; Q.add(neighbor); } } } return fresh_count != 0 ? -1 : times; } "}]