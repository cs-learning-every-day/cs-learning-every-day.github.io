[{"id":0,"href":"/docs/acwing/","title":"Acwing","section":"Docs","content":" \r786. 第k个数 \r788. 求逆序对的个数 \r791. 高精度加法 \r792. 高精度减法 \r793. 高精度乘法 \r794. 高精度除法 \r795. 前缀和 \r796. 子矩阵的和 \r797. 差分 \r798. 差分矩阵  "},{"id":1,"href":"/docs/acwing/basic/786/","title":"786th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int q[100001]; int quick_sort(int l, int r, int k) { if (l == r) { return q[l]; } int x = q[l], i = l - 1, j = r + 1; while (i \u0026lt; j) { while (q[++i] \u0026lt; x); while (q[--j] \u0026gt; x); if (i \u0026lt; j) { swap(q[i], q[j]); } } int sl = j - l + 1; if (k \u0026lt;= sl) return quick_sort(l, j, k); return quick_sort(j + 1, r, k - sl); } int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; q[i]; } cout \u0026lt;\u0026lt; quick_sort(0, n - 1, k); return 0; } "},{"id":2,"href":"/docs/acwing/basic/788/","title":"788th","section":"Acwing","content":" \rLink\n class Solution { private int[] tmp; public int reversePairs(int[] nums) { tmp = new int[nums.length]; return mergeSort(nums, 0, nums.length - 1); } private int mergeSort(int[] nums, int l, int r) { if (l \u0026gt;= r) { return 0; } int mid = (l + r) \u0026gt;\u0026gt; 1; int res = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r); // 归并  int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (nums[i] \u0026lt;= nums[j]) { tmp[k++] = nums[i++]; } else { tmp[k++] = nums[j++]; res += (mid - i + 1); } } while (i \u0026lt;= mid) { tmp[k++] = nums[i++]; } while (j \u0026lt;= r) { tmp[k++] = nums[j++]; } for (i = l, j = 0; i \u0026lt;= r; i++, j++) { nums[i] = tmp[j]; } return res; } } "},{"id":3,"href":"/docs/acwing/basic/791/","title":"791st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e6 + 10; vecotr\u0026lt;int\u0026gt; add(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i++) { if (i \u0026lt; A.size()) { t += A[i]; } if (i \u0026lt; B.size()) { t += B[i]; } C.push_back(t % 10); t /= 10; } if (t) { C.push_back(1); } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } auto C = add(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":4,"href":"/docs/acwing/basic/792/","title":"792nd","section":"Acwing","content":"两个正整数相减 A - B 考虑A \u0026lt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = -(|A| + |B|) 考虑A \u0026gt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = |A| + |B|\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; // 判断A\u0026gt;=B bool cmp(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() != B.size()) { return A.size() \u0026gt; B.size(); } for (int i = A.size() - 1; i \u0026gt;= 0; i--) { if (A[i] != B[i]) { return A[i] \u0026gt; B[i]; } } // 去掉前导0  while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return true; } vecotr\u0026lt;int\u0026gt; sub(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vecotr\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i++) { t = A[i] - t; if (i \u0026lt; B.size()) { t -= B[i]; } c.push_back((t + 10) % 10); if (t \u0026lt; 0) { t = 1; } else { t = 0; } } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B, C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } if (cmp(A, B)) { C = sub(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } else { C = sub(B, A); printf(\u0026#34;-\u0026#34;); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } return 0; } "},{"id":5,"href":"/docs/acwing/basic/793/","title":"793rd","section":"Acwing","content":"两个正整数相乘 大*小\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; mul(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b) { vecotr\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t != 0; i++) { if (i \u0026lt; A.size()) { t += A[i] * b; } C.push_back(t % 10); t /= 10; } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } C = mul(A, b); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":6,"href":"/docs/acwing/basic/794/","title":"794th","section":"Acwing","content":"两个正整数相除 大/小\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; mul(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vecotr\u0026lt;int\u0026gt; C; int t = 0; r = 0; for (int i = A.size(); i \u0026gt;= 0; i--) { r = r * 10 + A[i]; C.push_back(r / b); r = r % b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } int r C = div(A, b, r); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } "},{"id":7,"href":"/docs/acwing/basic/795/","title":"795th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], s[N]; int main() { a[0] = 0; s[0] = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { s[i] = s[i - 1] + a[i]; } while (m--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;r, \u0026amp;l); printf(\u0026#34;%d\\n\u0026#34;, s[r] - s[l - 1]); } return 0; } "},{"id":8,"href":"/docs/acwing/basic/796/","title":"796th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; const int N = 1010; int n, m, q; int a[N][N], s[N][N]; int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } } while (q--) { int x1, y1, x2, y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); printf(\u0026#34;%d\\n\u0026#34;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 -1] + s[x1 - 1][y1 -1]); } return 0; } "},{"id":9,"href":"/docs/acwing/basic/797/","title":"797th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { insert(i, i, a[i]); } while (m--) { int l, r, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;c); insert(l, r, c); } for (int i = 1; i \u0026lt;= n; i++) { b[i] += b[i - 1]; } for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;%d \u0026#34;, b[i]); } return 0; } "},{"id":10,"href":"/docs/acwing/basic/798/","title":"798th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 1010; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { insert(i, j, i, j, a[i][j]); } } while (q--) { int x1, y1, x2, y2, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;c); insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { printf(\u0026#34;%d \u0026#34;, b[i][j]); } puts(\u0026#34;\u0026#34;); } return 0; } "},{"id":11,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"相关资源\r#\r\r  \r藏经阁\n  \rNo Starch Press\n  \rThe Pragmatic Bookshelf\n  \rManning\n  \rO\u0026rsquo;Reilly\n  \rLet Me Read\n  \rLibrary Genesis\n  \rSaltTiger 目前我主要在以下网站收集编程类电子书，大家去这上面找书就好，下载方法也一并给出：\n  \rCoderProg，点击验证码，跳转至Rapidgator或Turbobit网盘，将网盘链接复制到\r木薯牛网盘中转站（1G流量1.33元）进行中转，即可下载。\n  \rAvaxHome，跳转至icerbox网盘，将网盘链接复制到\r思飞网盘中转站（1G icerbox流量2.8元）进行中转，中转后自动转存到绑定的百度网盘，即可下载。\n  \rFox eBook，跳转至NitroFlare网盘，将网盘链接复制到\r木薯牛网盘中转站进行中转，即可下载。\n  \rLibrary Genesis，点击Mirrors链接直接下载。\n  \rLet Me Read，点击验证码，跳转DirectLink直接下载。\n    \rZlibrary\n  \rLeanpub\n  \rThe best Programming books\n  "},{"id":12,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"读书\r#\r\r 书籍是人类进步的阶梯。\n  温故而知新,可以为师矣。\n TODO:\r#\r\r《精通Spring 4.x 企业应用开发实战》\n Todo 18、19、20  Done:\r#\r\r《Java性能权威指南》\n 2021/12/16 Ch1  《自己动手写Java虚拟机》\n 2021/12/21 Ch1 2021/12/23 Ch2 2021/12/31 Ch3.3 2022/1/1 Ch3 2022/2/6 Finish  《如何科学学外语 语言习得的真相与方法》\n 2022/2/2 Ch1~Ch4 2022/2/3 Finish  《软件开发实践：项目驱动式的Java开发指南》\n 2022/2/2 Ch1~Ch3 2022/2/3 Finish  《JAVA解惑》\n 2022/2/6 Finish  《算法4》\n 2022/1/25 Finish  《编程珠玑》\n 2021/11/27 Ch1 2021/12/14 Ch2 2022/1/3 Ch3 2022/1/25 Finish  《Java工程师修炼之道》\n 2022/1/11 1.1 2022/1/23 Finish  《The Little Schemer》\n 2021/11/15 Ch5 2021/11/25 Ch6 2022/1/15 Ch7 2022/1/22 Finish  《代码整洁之道》\n 2021/11/15 Ch3 2021/12/14 Ch4、Ch5、Ch6 2022/1/21 Ch7、8、9、10、11 2022/1/22 Finish  《Java并发编程的艺术》\n 2021/10/9 P280 ~ P304 2021/10/30 Finish  《操作系统导论》\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 Finish  《Build On Your Lisp》\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 Finish  《UNIX环境高级编程》\n 2021/10/22 CH11 2021/10/31 CH12 2021/11/10 2021/11/20 Ch16 2021/11/24 Finish  "},{"id":13,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  "},{"id":14,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":"Basic\r#\r\rQuick Sort\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } Binary Search\r#\r\r// 区间[l,r]划分成[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) { //check() 检查mid是否满足性质  r = mid; } else { l = mid + 1; } } } // 区间[l,r]划分成[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1\u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } "},{"id":15,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Java并发编程艺术","section":"C S","content":"11.2 定位问题\r#\r\r线上代码定位问题\n11.3 性能测试\r#\r\r相关的命令\n"},{"id":16,"href":"/docs/cs/courses/","title":"Courses","section":"C S","content":"Study Path\r#\r\rCourses\r#\r\rDone:\n [MIT 6.Null The Missing Semester of Your CS Education]  Todo:\n MIT 6.S081 Operating System Engineering UCB CS61A Structure and Interpretation of Computer Programs UCB CS61B Data Structures UCB CS61C Great Ideas in Computer Architecture (Machine Structures) Standford CS106L C++ Programming Standford CS106B Programming Abstractions  Backlog:\n MIT 6.001 Introduction to Computer Science and Programming in Python UCB Data8 The Foundations of Data Science UCB Data100 Principles and Techniques of Data Science UCB CS161 Computer Security Standford CS149 Parallel Computing UCB CS164 Programming Languages and Compilers    UCB CS189 Introduction to Machine Learning UCB CS170 Efficient Algorithms and Intractable Problems UCB CS168 Operation System UCB CS186 Introduction to Database Systems MIT 6.824 Distributed Systems CMU 15-721 Advanced Database Systems MIT 6.172 Performance Engineering of Software Systems UCB CS169 Software Engineering  Data Structure and Algorithm\r#\r\r UCB CS61B Data Structures UCB CS170 Efficient Algorithms and Intractable Problems  Computer Architecture\r#\r\r UCB CS61C Great Ideas in Computer Architecture (Machine Structures)  Computer System\r#\r\r1. Operating System\r#\r\r MIT 6.S081 Operating System Engineering UCB CS168 Operation System  2. Complier\r#\r\r UCB cs164 Programming Languages and Compilers MIT 6.035 Computer Language Engineering  3. Computer Networking\r#\r\r Standford CS144 Computer Networking  4. Parallel Computing\r#\r\r Standford CS149 Parallel Computing  5. Distributed System\r#\r\r MIT 6.824 Distributed Systems  Data Science\r#\r\r UCB Data8 The Foundations of Data Science UCB Data100 Principles and Techniques of Data Science UCB CS189 Introduction to Machine Learning  "},{"id":17,"href":"/docs/cs/interviews/","title":"Interviews","section":"C S","content":" \r整理it资料的百科全库  Java\r#\r\r \rbugstack 虫洞栈 \rJava 全栈知识体系 \rJavaGuide \rJavaFamily \rJavaTutorial \rlearning-note \rJavaKeeper \r互联网 Java 工程师进阶知识完全扫盲 \rJavaHome \rJavaSourceCodeLearning \rDocs \rJavaYouth  Others\r#\r\r \r互联网公司常用框架源码赏析 \rTech Interview Handbook \rCS-Notes  "},{"id":18,"href":"/docs/cs/leetcode/206/","title":"206th","section":"C S","content":"public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; } "},{"id":19,"href":"/docs/cs/leetcode/21/","title":"21st","section":"C S","content":"ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = \u0026amp;dummy; while (p1 \u0026amp;\u0026amp; p2) { if (p1-\u0026gt;val \u0026gt; p2-\u0026gt;val) { cur-\u0026gt;next = p2; p2 = p2-\u0026gt;next; } else { cur-\u0026gt;next = p1; p1 = p1-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = p1 ? p1 : p2; return dummy.next; "},{"id":20,"href":"/docs/cs/leetcode/273/","title":"273rd","section":"C S","content":"class Solution { private final String[] LESS_THAN_20 = {\u0026#34;\u0026#34;, \u0026#34;One\u0026#34;, \u0026#34;Two\u0026#34;, \u0026#34;Three\u0026#34;, \u0026#34;Four\u0026#34;, \u0026#34;Five\u0026#34;, \u0026#34;Six\u0026#34;, \u0026#34;Seven\u0026#34;, \u0026#34;Eight\u0026#34;, \u0026#34;Nine\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Eleven\u0026#34;, \u0026#34;Twelve\u0026#34;, \u0026#34;Thirteen\u0026#34;, \u0026#34;Fourteen\u0026#34;, \u0026#34;Fifteen\u0026#34;, \u0026#34;Sixteen\u0026#34;, \u0026#34;Seventeen\u0026#34;, \u0026#34;Eighteen\u0026#34;, \u0026#34;Nineteen\u0026#34;}; private final String[] TENS = {\u0026#34;\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Twenty\u0026#34;, \u0026#34;Thirty\u0026#34;, \u0026#34;Forty\u0026#34;, \u0026#34;Fifty\u0026#34;, \u0026#34;Sixty\u0026#34;, \u0026#34;Seventy\u0026#34;, \u0026#34;Eighty\u0026#34;, \u0026#34;Ninety\u0026#34;}; private final String[] THOUSANDS = {\u0026#34;\u0026#34;, \u0026#34;Thousand\u0026#34;, \u0026#34;Million\u0026#34;, \u0026#34;Billion\u0026#34;}; public String numberToWords(int num) { if (num == 0) return \u0026#34;Zero\u0026#34;; int i = 0; String words = \u0026#34;\u0026#34;; while (num \u0026gt; 0) { if (num % 1000 != 0) words = helper(num % 1000) +THOUSANDS[i] + \u0026#34; \u0026#34; + words; num /= 1000; i++; } return words.trim(); } private String helper(int num) { if (num == 0) return \u0026#34;\u0026#34;; else if (num \u0026lt; 20) return LESS_THAN_20[num] + \u0026#34; \u0026#34;; else if (num \u0026lt; 100) return TENS[num / 10] + \u0026#34; \u0026#34; + helper(num % 10); else return LESS_THAN_20[num / 100] + \u0026#34; Hundred \u0026#34; + helper(num % 100); } } "},{"id":21,"href":"/docs/cs/leetcode/29/","title":"29th","section":"C S","content":"long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a \u0026lt; 0) sign *= -1; if (b \u0026lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a \u0026gt;= b) { long count = 1; long c = b; while ((c \u0026lt;\u0026lt; 1) \u0026lt;= a) { c \u0026lt;\u0026lt;= 1; count \u0026lt;\u0026lt;= 1; } quotient += count; a -= c; } if (sign * quotient \u0026gt; INT_MAX) { return INT_MAX; } return quotient*sign; "},{"id":22,"href":"/docs/cs/leetcode/46/","title":"46th","section":"C S","content":"public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;bool\u0026gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, vector\u0026lt;int\u0026gt;\u0026amp; cur, vector\u0026lt;bool\u0026gt;\u0026amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } } "},{"id":23,"href":"/docs/cs/leetcode/542/","title":"542nd","section":"C S","content":" 看成图，0为起点\n vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; updateMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat) { int m = mat.size(), n = mat[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(m, vector\u0026lt;int\u0026gt;(n, -1)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (int i = 0 ; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!Q.empty()) { pair\u0026lt;int, int\u0026gt; node = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { pair\u0026lt;int, int\u0026gt; neighbor = {node.first + dx[i], node.second + dy[i]}; if (neighbor.first \u0026lt; 0 || neighbor.first \u0026gt;= m || neighbor.second \u0026lt; 0 || neighbor.second \u0026gt;= n || dist[neighbor.first][neighbor.second] != -1) continue; dist[neighbor.first][neighbor.second] = dist[node.first][node.second] + 1; Q.push(neighbor); } } return dist; } "},{"id":24,"href":"/docs/cs/leetcode/77/","title":"77th","section":"C S","content":"public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(ans, 1, k, n, new ArrayList\u0026lt;\u0026gt;()); return ans; } private void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans, int start, int k, int n, List\u0026lt;Integer\u0026gt; cur) { if (cur.size() == k) { ans.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = start; i \u0026lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } } "},{"id":25,"href":"/docs/cs/leetcode/784/","title":"784th","section":"C S","content":"public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List\u0026lt;String\u0026gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); } "},{"id":26,"href":"/docs/cs/leetcode/tips/","title":"Tips","section":"C S","content":"摩尔投票算法\r#\r\r/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */ "},{"id":27,"href":"/docs/cs/linux/gdb/","title":"G D B","section":"C S","content":"GCC\r#\r\r  -E 获取预处理后的文件内容\n  -V 将编译、链接过程打印\n  -g 用于GDB调试\n  ltrace 命令用来跟踪程序运行时调用的库函数\n -S 查看系统调用 -e trace=write 只看write系统调用  strace 查看系统调用的封装函数\nGDB\r#\r\rSegment Fault快速定位\n首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core  list start ctrl + x + a  "},{"id":28,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt xxd 查看文件二进制  输出当前用户是不是 root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  查看磁盘引导扇区 (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  统计所有 cpp 文件的行数\n find . | grep '\\.cpp$' | xargs cat | wc -l  统计命令行命令的频率\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  文件检索 - cat, more, less, head, tail, file, find\n  输入输出控制 - 重定向, 管道, tee, xargs\n  文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  正则表达式\n  系统监控 - jobs, ps, top, kill, free, demsg, lsof\n   如何比较两个文件是否完全相同?   diff or md5sum\n  如何列出一个C语言项目中所有被包含过的头文件?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n du -h -d 1 2\u0026gt;/dev/null | grep -v denied 磁盘分析\n\r配置linux\n查看最大空间占用目录\nsudo du -h \u0026ndash;exclude=\u0026ldquo;mnt*\u0026rdquo; \u0026ndash;exclude=\u0026ldquo;proc*\u0026rdquo; -d 1 /\np@ssw0rd\n"},{"id":29,"href":"/docs/cs/linux/vim/","title":"Vim","section":"C S","content":" Vscode插件 Learn Vim  "},{"id":30,"href":"/docs/cs/linux/wsl/","title":"W S L","section":"C S","content":"\r为WSL2加图形化界面配置\n运行 startxfce4\n"},{"id":31,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"C S","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":32,"href":"/docs/cs/programming/","title":"Programming","section":"C S","content":" \rC \rJava \rGo \rC++ \rRust \rJavaScript \rScala \rKotlin \rWeb  "},{"id":33,"href":"/docs/cs/programming/go/","title":"Go","section":"Programming","content":"Resources\r#\r\r \rGo by Example \rGo语言圣经中文版 Link \rLearn Go with Tests \r【未来服务器端编程语言】最全空降golang资料补给包（满血战斗），包含文章，书籍，作者论文，理论分析，开源框架，云原生，大佬视频，大厂实战分享ppt \r1000+ Hand-Crafted Go Examples, Exercises, and Quizzes \rA Tuor of Go \rStandard Go Project Layout \rGo 语言设计与实现 \r《Effective Go》中英双语版 \rGo语言高级编程 \rPractical Go Lessons \rA hands-on approach to getting started with Go generics.  "},{"id":34,"href":"/docs/cs/programming/rust/","title":"Rust","section":"Programming","content":"Resources\r#\r\r \rWriting an OS in Rust \rRust 程序设计语言  "},{"id":35,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"Rust","content":"Cargo\r#\r\r cargo new project-name  "},{"id":36,"href":"/docs/cs/resource/","title":"Resource","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \r📚 List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCS公开课程学习群课程推荐 \r克莱登大学CS(热心网友整理) \r🎓 Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos \r写在20年初的校招面试心得与自学CS经验及找工作分享 \rTeach Yourself Programming in Ten Years \rCS自学指南 \r从小白到BAT后端工程师的自学路线 \rA Self-Learning, Modern Computer Science Curriculum \r名校公开课程评价网 \rBest-websites-a-programmer-should-visit \rCS-Awesome-Courses \rcs-video-courses  "},{"id":37,"href":"/docs/cs/tools/git/","title":"Git","section":"C S","content":"// 删除本地分支 git branch -d localBranchName\n// 删除远程分支 git push origin \u0026ndash;delete remoteBranchName\n修改github 日期\ngit commit\rgit cat-file -p HEAD \u0026gt; tmp.txt\r# at this point, edit the file to replace the timestamp\rgit hash-object -t commit -w tmp.txt\r#=\u0026gt; 2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rgit update-ref -m 'commit: foo' refs/heads/master \\\r2ee8fcc02658e23219143f5bcfe6f9a4615745f9\r取消跟踪,删除远程文件\ngit rm -r --cached .\rgit add .\rgit commit -m \u0026quot;update gitignore\u0026quot;\r配置全局信息\n \u0026ndash;local\n git config \u0026ndash;global user.name \u0026ldquo;myname\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;test@gmail.com\u0026rdquo;\n"},{"id":38,"href":"/docs/cs/tools/vscode/","title":"Vscode","section":"C S","content":"WSL相关\r#\r\rvscode server for wsl closed unexpectedly\nnetsh winsock reset重置网络 或移除wsl中的~/.vscode-server\n"},{"id":39,"href":"/docs/leetcode/","title":"Leet Code","section":"Docs","content":" \rCodeTop  目前分类目录\r#\r\r剑指 Offer\r#\r\r面试题 \r#\r\r国区周寨\r#\r\r  第273场\n \r5963. 反转两次的数字(E) \r5964. 执行所有后缀指令(M) \r5965. 相同元素的间隔之和(M)    第274场\n \r5967. 检查是否所有 A 都在 B 之前(E) \r5968. 银行中的激光束数量(M) \r5969. 摧毁小行星(M)    Dynamic Programming\r#\r\r \r10. 正则表达式匹配(H) \r62. Unique Paths(M) \r63. Unique Paths II(M) \r64. Minimum Path Sum(M) \r91. Decode Ways(M) \r118. Pascal\u0026rsquo;s Triangle(E) \r119. Pascal\u0026rsquo;s Triangle II(E) \r120. Triangle(M) \r122. 买卖股票的最佳时机 II(M) \r123. 买卖股票的最佳时机 III(H) \r198. 打家劫舍(M) \r213. 打家劫舍 II(M) \r264. Ugly Number II(E) \r309. 最佳买卖股票时机含冷冻期(M) \r509. Fibonacci Number(M) \r714. Best Time to Buy and Sell Stock with Transaction Fee(M)  Tree\r#\r\r \r559. Maximum Depth of N-ary Tree(E) \r700. Search in a Binary Search Tree(E) \r102. 二叉树的层序遍历(M)  Heap\r#\r\r \r1046. 最后一块石头的重量(E) \r347. 前 K 个高频元素(M) \r451. 根据字符出现频率排序(M)  Math\r#\r\r \r384. Shuffle an Array(E) \r519. Random Flip Matrix(M) \r1979. Find Greatest Common Divisor of Array(E) \r812. Largest Triangle Area(E)  DFS\r#\r\r \r17. 电话号码的字母组合(M) \r139. Word Break(M)  Recursion\r#\r\r \r1492. The kth Factor of n(M)  BinarySearch\r#\r\rSorts\r#\r\r Quick Select  \r215. Kth Largest Element in an Array    LinkedList\r#\r\r \r2. 两数相加(M) \r19. 删除链表的倒数第 N 个结点(M) \r21. 合并两个有序链表(E) \r23. 合并K个升序链表(H) \r24. 两两交换链表中的节点(M) \r25. K 个一组翻转链表(H)  Stack\r#\r\r \r20. 有效的括号(E)  Two Pointers\r#\r\r \r11. 盛最多水的容器(M) \r15. 三数之和(M) \r16. 最接近的三数之和(M) \r18. 四数之和(M) \r26. 删除有序数组中的重复项(E) \r27. 移除元素(E)   Sliding window  \r3. 无重复字符的最长子串(M) \r4. 寻找两个正序数组的中位数(H)    String\r#\r\r \r6. Z 字形变换(M) \r8. 字符串转换整数 (atoi)(M) \r14. 最长公共前缀(E)   Manacher  \r5. 最长回文子串(M)   KMP  \r28. 实现 strStr()(E)    Others\r#\r\r \r1. 两数之和(E) \r7. 整数反转(M) \r9. 回文数(E) \r22. 括号生成(E) \r29. 两数相除(M) \r1005. Maximize Sum Of Array After K Negations(E) \r383. Ransom Note(E) \r748. Shortest Completing Word(E)  Simulation\r#\r\r \r12. 整数转罗马数字(M) \r13. 罗马数字转整数(E)  Design\r#\r\r \r355. 设计推特(M) \r146. LRU 缓存(M)  "},{"id":40,"href":"/docs/leetcode/design/146/","title":"146th","section":"Leet Code","content":" \rLink\n 使用java的双向链表LinkedList有坑啊，过不了。\nclass LRUCache { private int capacity; private DoubleList list; private Map\u0026lt;Integer, Node\u0026gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap\u0026lt;\u0026gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.get(key); node.val = value; list.remove(node); } else { node = new Node(value, key); if (map.size() == capacity) { // full  Node last = list.removeLast(); map.remove(last.key); } } list.addFirst(node); map.put(key, node); } } class DoubleList { Node head, tail; public DoubleList() { this.head = null; this.tail = null; } public void addFirst(Node node) { if (head == null) { this.head = node; this.tail = node; } else { node.prev = null; node.next = head; head.prev = node; head = node; } } public void remove(Node node) { if (node == head) { this.head = node.next; if (this.head != null) { this.head.prev = null; } } else if (node == tail) { this.tail = node.prev; if (this.tail != null) { this.tail.next = null; } } else { Node prev = node.prev; prev.next = node.next; prev.next.prev = prev; } } public Node removeLast() { Node res = this.tail; if (this.head == this.tail) { res = this.head; this.head = this.tail = null; } else { Node node = this.tail.prev; node.next = null; this.tail = node; } return res; } } class Node { int val; int key; Node prev; Node next; public Node(int val, int key) { this.val = val; this.key = key; } } "},{"id":41,"href":"/docs/leetcode/design/355/","title":"355th","section":"Leet Code","content":" \rLink\n class Twitter { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; follows; private Map\u0026lt;Integer, PriorityQueue\u0026lt;Integer\u0026gt;\u0026gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map\u0026lt;Integer, Integer\u0026gt; orders = new HashMap\u0026lt;\u0026gt;(); public Twitter() { follows = new HashMap\u0026lt;\u0026gt;(); tweets = new HashMap\u0026lt;\u0026gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue\u0026lt;Integer\u0026gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue\u0026lt;Integer\u0026gt;((a, b) -\u0026gt; b - a); tweets.put(userId, tmp); } int key = ai.incrementAndGet(); orders.put(key, tweetId); tmp.offer(key); } public List\u0026lt;Integer\u0026gt; getNewsFeed(int userId) { List\u0026lt;Integer\u0026gt; followees = follows.get(userId); PriorityQueue\u0026lt;Integer\u0026gt; tmp = new PriorityQueue\u0026lt;\u0026gt;(); if (followees != null) { for (int followeeId : followees) { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(followeeId); if (t != null) { updateTop10Data(t, tmp); } } } else { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(userId); if (t != null) { updateTop10Data(t, tmp); } } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (tmp.size() \u0026gt; 0) { res.add(0, orders.get(tmp.poll())); } return res; } private void updateTop10Data(PriorityQueue\u0026lt;Integer\u0026gt; data, PriorityQueue\u0026lt;Integer\u0026gt; res) { for (int d : data) { if (res.size() \u0026gt;= 10) { if (res.peek() \u0026lt; d) { res.poll(); res.offer(d); } } else { res.offer(d); } } } public void follow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); tmp.add(followerId); follows.put(followerId, tmp); } if (tmp.contains(followeeId)) { return; } tmp.add(followeeId); } public void unfollow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { return; } tmp.remove(new Integer(followeeId)); } } "},{"id":42,"href":"/docs/leetcode/dfs/139/","title":"139th","section":"Leet Code","content":" \rLink\n 遍历字符串，将其分成两部分left和right，判断是否都在wordList里。\n加上记忆化\npublic boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(wordDict); Map\u0026lt;String, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set\u0026lt;String\u0026gt; set, Map\u0026lt;String, Boolean\u0026gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i \u0026lt; n; i++) { String left = s.substring(0, i); String right = s.substring(i, n); if (set.contains(left) \u0026amp;\u0026amp; dfs(right, set, map)) { map.put(s, true); return true; } } map.put(s, false); return false; } 最佳实践：使用Trie\npublic class TreeNode { TreeNode[] children; boolean isWord; char value; TreeNode() { children = new TreeNode[26]; } } private TreeNode root = new TreeNode(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { TreeNode node = root; for (char c : word.toCharArray()) { if (node.children[c - \u0026#39;a\u0026#39;] == null) { node.children[c - \u0026#39;a\u0026#39;] = new TreeNode(); } node.children[c - \u0026#39;a\u0026#39;].value = c; node = node.children[c - \u0026#39;a\u0026#39;]; } node.isWord = true; } return dfs(s, 0); } private int[] memo = new int[301]; private boolean dfs(String s, int cur) { // s[cur:]  int n = s.length(); if (cur \u0026gt;= n) return true; if (memo[cur] == 1) return false; TreeNode node = root; for (int i = cur; i \u0026lt; n; i++) { TreeNode tmp = node.children[s.charAt(i) - \u0026#39;a\u0026#39;]; node = tmp; if (tmp != null) { if (tmp.isWord \u0026amp;\u0026amp; dfs(s, i + 1)) { return true; } } else { break; } } memo[cur] = 1; return false; } "},{"id":43,"href":"/docs/leetcode/dfs/17/","title":"17th","section":"Leet Code","content":" \rLink\n 使用StringBuilder优化字符串copy\nclass Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), new StringBuilder()); return res; } private void dfs(String digits, int pos, int len, StringBuilder cur) { if (pos == len) { res.add(cur.toString()); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { cur.append(c); dfs(digits, pos + 1, len, cur); cur.deleteCharAt(cur.length() - 1); } } } } class Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), \u0026#34;\u0026#34;); return res; } private void dfs(String digits, int pos, int len, String cur) { if (pos == len) { res.add(cur); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { dfs(digits, pos + 1, len, cur + c); } } } } "},{"id":44,"href":"/docs/leetcode/dfs/5964/","title":"5964th","section":"Leet Code","content":" TODO: Link\n class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i \u0026lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i \u0026lt; len; i++) { if (checkAndRun(pos, s.charAt(i))) { res++; } else { break; } } return res; } private boolean checkAndRun(int[] pos, char c) { if (c == \u0026#39;U\u0026#39;) { if (pos[0] != 0) { pos[0]--; return true; } } else if (c == \u0026#39;R\u0026#39;) { if (pos[1] != (n - 1)) { pos[1]++; return true; } } else if (c == \u0026#39;L\u0026#39;) { if (pos[1] != 0) { pos[1]--; return true; } } else if (c == \u0026#39;D\u0026#39;) { if (pos[0] != (n - 1)) { pos[0]++; return true; } } return false; } } "},{"id":45,"href":"/docs/leetcode/dynamicprogramming/10/","title":"10th","section":"Leet Code","content":" \rLink\n public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // 表示 dp[i][j] = s[1..i] 和 p[1...j]是否相等  boolean[][] dp = new boolean[m + 1][n + 1]; s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; dp[0][0] = true; for (int i = 0; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (j + 1 \u0026lt;= n \u0026amp;\u0026amp; p.charAt(j + 1) == \u0026#39;*\u0026#39;) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; p.charAt(j) != \u0026#39;*\u0026#39;) { dp[i][j] = dp[i - 1][j - 1] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == \u0026#39;.\u0026#39;); } else if (p.charAt(j) == \u0026#39;*\u0026#39;) { /** dp[i][j] = dp[i][j-2] || (dp[i-1][j-2] \u0026amp;\u0026amp; s[i]==p[j-1]) || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1]==p[j-1] \u0026amp;\u0026amp; s[i]==p[j-1]) dp[i-1][j] = dp[i-1][j-2] || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1] == p[j-1]) dp[i][j] = dp[i][j-2] || (dp[i-1][j] \u0026amp;\u0026amp; s[i]==p[j-1]) */ dp[i][j] = dp[i][j - 2] || (i \u0026gt; 0 \u0026amp;\u0026amp; dp[i - 1][j] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j - 1) || p.charAt(j - 1) == \u0026#39;.\u0026#39;)); } } } return dp[m][n]; } "},{"id":46,"href":"/docs/leetcode/dynamicprogramming/118/","title":"118th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i \u0026lt;= numRows; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= numRows; i++) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (int j = 1; j \u0026lt;= i; j++) { tmp.add(dp[i][j]); } ans.add(tmp); } return ans; } } "},{"id":47,"href":"/docs/leetcode/dynamicprogramming/119/","title":"119th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;Integer\u0026gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row \u0026lt;= rowIndex; row++) { for (int col = 1; col \u0026lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int col = 1; col \u0026lt;= rowIndex; col++) { ans.add(dp[rowIndex][col]); } return ans; } } 进阶优化空间：O(rowIndex)\nclass Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { vector\u0026lt;int\u0026gt; ans(rowIndex + 1, 1); for (int i = 0; i \u0026lt;= rowIndex; i++) { for (int j = i - 1; j \u0026gt;= 1; j--) { ans[j] = ans[j] + ans[j - 1]; } } return ans; } }; "},{"id":48,"href":"/docs/leetcode/dynamicprogramming/120/","title":"120th","section":"Leet Code","content":" \rLink\n DP 要从下往上找，否则不一定是全局最优\n2 3 4 6 5 1 4 1 8 3\nclass Solution { public int minimumTotal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j \u0026lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt;= i; j++) { dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); } } return dp[0][0]; } } "},{"id":49,"href":"/docs/leetcode/dynamicprogramming/122/","title":"122nd","section":"Leet Code","content":" \rLink\n 可以把数据看成折线图，则所有上升之和为解\npublic int maxProfit(int[] prices) { int res = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP\npublic int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润  int[] dp1 = new int[n]; // 第i天卖掉的最大利润  int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i \u0026lt; n; i++) { // 可以不买或卖  dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] + prices[i]); } return dp2[n - 1]; } "},{"id":50,"href":"/docs/leetcode/dynamicprogramming/123/","title":"123rd","section":"Leet Code","content":" \rLink\n public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: 持有第一股的最大利益  // dp[0][1]: 售出第一股的最大利益  // dp[0][2]: 持有第二股的最大利益  // dp[0][3]: 售出第二股的最大利益  int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i \u0026lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i - 1]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i - 1]); } return Math.max(dp[n][1], dp[n][3]); } "},{"id":51,"href":"/docs/leetcode/dynamicprogramming/198/","title":"198th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: 第一个房间抢  // dp[0][1]: 第一个房间不抢  int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } "},{"id":52,"href":"/docs/leetcode/dynamicprogramming/213/","title":"213th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j)  private int help(int[] nums, int i, int j) { // 0 : 抢  // 1 : 不抢  int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i \u0026lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[j - 1][0], dp[j - 1][1]); } } "},{"id":53,"href":"/docs/leetcode/dynamicprogramming/264/","title":"264th","section":"Leet Code","content":" \rLink\n 使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]\n[1] -\u0026gt; [2 3 5] -\u0026gt; [3 4 5 6 10] -\u0026gt; \u0026hellip;\nclass Solution { // Time Complexity: O(3N * lg3N)  // 每次产生 最小数的2、3、5倍数  public int nthUglyNumber(int n) { PriorityQueue\u0026lt;Long\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); q.add(1L); long top = -1L; for (int i = 0; i \u0026lt; n; i++) { top = q.peek(); while (!q.isEmpty() \u0026amp;\u0026amp; q.peek() == top) { q.poll(); } q.add(top * 2); q.add(top * 3); q.add(top * 5); } return (int)top; } } dp思想，对于任何丑数，它只能由某一个丑数x x2、x3、x*5里得到。\n定义三个指针i、j、k来定跟踪丑数的大小。\nnums X X X X X X idx2 ^\ridx3 ^\ridx5 ^\rclass Solution { // Time Complexity: O(n);  public int nthUglyNumber(int n) { int i = 0, j = 0, k = 0; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); res.add(1); for (int v = 0; v \u0026lt; n; v++) { int cur = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5)); res.add(cur); if (cur == res.get(i) * 2) i++; if (cur == res.get(j) * 3) j++; if (cur == res.get(k) * 5) k++; } return res.get(n - 1); } } "},{"id":54,"href":"/docs/leetcode/dynamicprogramming/309/","title":"309th","section":"Leet Code","content":" \rLink\n DP\npublic int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润  int[] dp1 = new int[n + 1]; // i天买入的最大利润  int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出)  dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入)  dp2[i] = Math.max(dp2[i - 1], dp1[i - 2] - prices[i - 1]); } return dp1[n]; } "},{"id":55,"href":"/docs/leetcode/dynamicprogramming/509/","title":"509th","section":"Leet Code","content":" \rLink\n public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i \u0026lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; } "},{"id":56,"href":"/docs/leetcode/dynamicprogramming/62/","title":"62nd","section":"Leet Code","content":" \rLink\n DP\ndp[i][j] 表示能到i行j列不同路径个数\n初始化第一行和和第一列为1\nclass Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j \u0026lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i \u0026lt;= m; i++) { for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+记忆化\nclass Solution { public int uniquePaths(int m, int n) { int[][] memo = new int[m][n]; return dfs(0, 0, m, n, memo); } private int dfs(int i, int j, int m, int n, int[][] memo) { if (i \u0026gt;= m || j \u0026gt;= n || i \u0026lt; 0 || j \u0026lt; 0) { return 0; } if (memo[i][j] != 0) { return memo[i][j]; } if (i == m - 1 \u0026amp;\u0026amp; j == n - 1) { return 1; } int res = dfs(i + 1, j, m, n, memo) + dfs(i, j + 1, m, n, memo); memo[i][j] = res; return res; } } "},{"id":57,"href":"/docs/leetcode/dynamicprogramming/63/","title":"63rd","section":"Leet Code","content":" \rLink\n 同\r62题题思路一样\n直接看DP解法，注意初始化，有障碍物时，就不能往后走了\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } "},{"id":58,"href":"/docs/leetcode/dynamicprogramming/64/","title":"64th","section":"Leet Code","content":" \rLink\n dp[i][j] 表示到i行j列最小总和 注意初始化\nclass Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int k = i; k \u0026gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j \u0026lt; n; j++) { for (int k = j; k \u0026gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } "},{"id":59,"href":"/docs/leetcode/dynamicprogramming/714/","title":"714th","section":"Leet Code","content":" \rLink\n 第i天买入的最大利润buy[i]\n卖出的最大利润sell[i]\n卖出的时候(完成了一笔交易)减去手续费\nclass Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } } "},{"id":60,"href":"/docs/leetcode/dynamicprogramming/91/","title":"91st","section":"Leet Code","content":" \rLink\n DFS搜索 + 记忆化 class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i \u0026gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i \u0026lt; n - 1 \u0026amp;\u0026amp; isValid(s.substring(i, i + 2))) { res += dfs(s, i + 2); } memo.put(s.substring(i), res); return res; } private boolean isValid(String s) { int val = Integer.valueOf(s); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } private boolean isValid(char c) { int t = c - \u0026#39;0\u0026#39;; return 1 \u0026lt;= t \u0026amp;\u0026amp; t \u0026lt;= 26; } } DP\n\rclass Solution { public int numDecodings(String s) { s = \u0026#34;#\u0026#34; + s; int n = s.length(); // dp[i] = s[0]..s[i]解码方式  int[] dp = new int[n]; dp[0] = 1; dp[1] = (s.charAt(1) == \u0026#39;0\u0026#39;) ? 0 : 1; for (int i = 2; i \u0026lt; n; i++) { if (!isValid(s.charAt(i)) \u0026amp;\u0026amp; !isValid(s.charAt(i - 1), s.charAt(i))) { return 0; } if (isValid(s.charAt(i))) { dp[i] = dp[i - 1]; } if (isValid(s.charAt(i - 1), s.charAt(i))) { dp[i] += dp[i - 2]; } } return dp[n - 1]; } private boolean isValid(char c) { return \u0026#39;1\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } private boolean isValid(char a, char b) { int val = (a - \u0026#39;0\u0026#39;) * 10 + (b - \u0026#39;0\u0026#39;); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } } "},{"id":61,"href":"/docs/leetcode/heap/1046/","title":"1046th","section":"Leet Code","content":" \rLink\n // Time Complexity: O(nlogn)  // Space Complexity: O(n)  public int lastStoneWeight(int[] stones) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() \u0026gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.poll(); } "},{"id":62,"href":"/docs/leetcode/heap/347/","title":"347th","section":"Leet Code","content":" \rLink\n public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() \u0026gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!pq.isEmpty()) { res[idx++] = pq.poll(); } return res; } "},{"id":63,"href":"/docs/leetcode/heap/451/","title":"451st","section":"Leet Code","content":" \rLink\n public String frequencySort(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue\u0026lt;Character\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i \u0026lt; n; i++) { sb.append(c); } } return sb.toString(); } "},{"id":64,"href":"/docs/leetcode/linkedlist/19/","title":"19th","section":"Leet Code","content":" \rLink\n public ListNode removeNthFromEnd(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; int n = 0; while (head != null) { n++; head = head.next; } ListNode prev = dummy; for (int i = 0; i \u0026lt; (n - k); i++) { prev = prev.next; } prev.next = prev.next.next; return dummy.next; } "},{"id":65,"href":"/docs/leetcode/linkedlist/2/","title":"2nd","section":"Leet Code","content":" \rLink\n public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode curr = dummy; int t = 0; while (l1 != null || l2 != null || t != 0) { if (l1 != null) { t += l1.val; l1 = l1.next; } if (l2 != null) { t += l2.val; l2 = l2.next; } curr.next = new ListNode(t % 10); t /= 10; curr = curr.next; } return dummy.next; } "},{"id":66,"href":"/docs/leetcode/linkedlist/21/","title":"21st","section":"Leet Code","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode prev = dummy; while (l1 != null \u0026amp;\u0026amp; l2 != null) { if (l1.val \u0026lt; l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } if (l1 != null) { prev.next = l1; } if (l2 != null) { prev.next = l2; } return dummy.next; } "},{"id":67,"href":"/docs/leetcode/linkedlist/23/","title":"23rd","section":"Leet Code","content":" \rLink\n class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode dummy = new ListNode(); PriorityQueue\u0026lt;ListNode\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); for (var l : lists) { if (l != null) { // 示例3 特例  minHeap.offer(l); } } ListNode tail = dummy; while (!minHeap.isEmpty()) { ListNode cur = minHeap.poll(); tail.next = cur; tail = tail.next; cur = cur.next; if (cur != null) { minHeap.offer(cur); } } return dummy.next; } } "},{"id":68,"href":"/docs/leetcode/linkedlist/24/","title":"24th","section":"Leet Code","content":" \rLink\n public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy; p.next != null \u0026amp;\u0026amp; p.next.next != null;) { ListNode a = p.next; ListNode b = p.next.next; p.next = b; a.next = b.next; b.next = a; p = a; } return dummy.next; } "},{"id":69,"href":"/docs/leetcode/linkedlist/25/","title":"25th","section":"Leet Code","content":" \rLink\n public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy;;) { int n = 0; for (ListNode t = p.next; t != null; t = t.next) { n++; } if (n \u0026lt; k) { break; } // 翻转k个节点  ListNode a = p.next, b = p.next.next; for (int i = 0; i \u0026lt; k - 1; i++) { var c = b.next; b.next = a; a = b; b = c; } var c = p.next; p.next = a; c.next = b; p = c; } return dummy.next; } "},{"id":70,"href":"/docs/leetcode/math/1979/","title":"1979th","section":"Leet Code","content":" \rLink\n public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a \u0026gt; b  private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); } "},{"id":71,"href":"/docs/leetcode/math/384/","title":"384th","section":"Leet Code","content":" \rLink\n 常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。\n第一轮：1/n\n第二轮：(n-1)/n * 1/(n-1)\n第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)\n…………\nprivate int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i \u0026lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; } "},{"id":72,"href":"/docs/leetcode/math/519/","title":"519th","section":"Leet Code","content":" \rLink\n class Solution { private int m; private int n; private int count; private Map\u0026lt;Integer, Integer\u0026gt; map; /** 转成一维数组 索引i 相当于=\u0026gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =\u0026gt; 5 =\u0026gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =\u0026gt; 6 =\u0026gt; 3 map[5] = 4 map[3] = map[4] = 5 ... ... */ public Solution(int m, int n) { this.m = m; this.n = n; this.count = 0; this.map = new HashMap\u0026lt;\u0026gt;(); } public int[] flip() { int k = (int)(Math.random() * (m * n - count)); int res = 0; if (map.get(k) == null) { res = k; } else { res = map.get(k); } int lastIdx = m * n - count - 1; if (map.get(lastIdx) != null) { map.put(k, map.get(lastIdx)); } else { map.put(k, lastIdx); } count++; return new int[]{res / n, res % n}; } public void reset() { map.clear(); count = 0; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(m, n); * int[] param_1 = obj.flip(); * obj.reset(); */ "},{"id":73,"href":"/docs/leetcode/math/812/","title":"812th","section":"Leet Code","content":" \rLink\n 看评论区都用线性代数，没学过线性代数的我，泪目了哭！\npublic double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i \u0026lt; points.length; i++) { for (int j = i + 1; j \u0026lt; points.length; j++) { for (int k = j + 1; k \u0026lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp \u0026gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b \u0026gt; c) || (a + c \u0026gt; b) || (b + c) \u0026gt; a; } // 果断找个公式，海伦公式  private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.sqrt(p * (p - a) * (p - b) * (p - c)); } private double length(int[] p1, int[] p2) { return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)); } "},{"id":74,"href":"/docs/leetcode/others/1/","title":"1st","section":"Leet Code","content":" \rLink\n public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int another = target - nums[i]; if (map.containsKey(another)) { return new int[]{i, map.get(another)}; } map.put(nums[i], i); } return null; } "},{"id":75,"href":"/docs/leetcode/others/1005/","title":"1005th","section":"Leet Code","content":" \rLink\n 写的实在是太丑陋了, 太多边界条件不易写\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // 最小\u0026gt;0的数索引  for (int n : nums) { if (n \u0026lt; 0) i++; else break; } int j = i - 1; // 最大负数索引  int negCount = i; int idx = negCount - i; while (k \u0026gt; 0) { if (negCount \u0026gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i \u0026lt; nums.length \u0026amp;\u0026amp; nums[i] == 0) break; if ( i \u0026gt;= nums.length || (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt; nums[j])) { nums[j] = -nums[j]; } else { nums[i] = -nums[i]; } } k--; } int sum = 0; for (int n : nums) { sum += n; } return sum; } } 优先队列解法(最小堆)\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int n : nums) { q.add(n); } while (k \u0026gt; 0) { q.add(0 - q.poll()); k--; } int sum = 0; while (!q.isEmpty()) { sum += q.poll(); } return sum; } } "},{"id":76,"href":"/docs/leetcode/others/22/","title":"22nd","section":"Leet Code","content":" \rLink\n class Solution { private List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; generateParenthesis(int n) { dfs(n, 0, 0, \u0026#34;\u0026#34;); return res; } private void dfs(int n, int open, int closed, String s) { if (open == n \u0026amp;\u0026amp; closed == n) { res.add(s); return; } if (open \u0026lt; n) { dfs(n, open + 1, closed, s + \u0026#34;(\u0026#34;); } if (closed \u0026lt; n \u0026amp;\u0026amp; closed \u0026lt; open) { dfs(n, open, closed + 1, s + \u0026#34;)\u0026#34;); } } } "},{"id":77,"href":"/docs/leetcode/others/29/","title":"29th","section":"Leet Code","content":" \rLink\n X / Y = K \u0026ndash;\u0026gt; X = YK \u0026ndash;\u0026gt; K假设K=(1110)2 则 X = Y * 2^3 + Y * 2^2 + Y * 2^1 即logK个数相加\nclass Solution { public int divide(int dividend, int divisor) { int flag = 1; if (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) { flag = -1; } long a = Math.abs((long)dividend), b = Math.abs((long)divisor); List\u0026lt;Long\u0026gt; exp = new ArrayList\u0026lt;\u0026gt;(); for (long i = b; i \u0026lt;= a; i += i) { exp.add(i); } long res = 0; for (int i = exp.size() - 1; i \u0026gt;= 0; i--) { if (a \u0026gt;= exp.get(i)) { a -= exp.get(i); res += 1L \u0026lt;\u0026lt; i; } } res *= flag; if (res \u0026gt; Integer.MAX_VALUE || res \u0026lt; Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return (int)res; } } "},{"id":78,"href":"/docs/leetcode/others/383/","title":"383rd","section":"Leet Code","content":" \rLink\n class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - \u0026#39;a\u0026#39;] \u0026lt;= 0) return false; count[c - \u0026#39;a\u0026#39;]--; } return true; } } "},{"id":79,"href":"/docs/leetcode/others/5963/","title":"5963rd","section":"Leet Code","content":" TODO: Link\n class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i) == \u0026#39;0\u0026#39;) { i--; } for ( ; i \u0026gt;= 0; i--) { sb.append(s.charAt(i)); } return sb.toString(); } } "},{"id":80,"href":"/docs/leetcode/others/5965/","title":"5965th","section":"Leet Code","content":" TODO: Link\n 稍微优化下还是超时，放弃\nclass Solution { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // if (i == begin) continue;  if (arr[begin] == arr[i]) { list.add(i); } } map.put(arr[begin], list); System.out.println(1); } else { System.out.println(2); } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } 超时\nclass Solution { public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (i == begin) continue; if (arr[begin] == arr[i]) { list.add(i); } } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } ``"},{"id":81,"href":"/docs/leetcode/others/5967/","title":"5967th","section":"Leet Code","content":" \rLink\n public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i \u0026lt; chs.length; i++) { if (chs[i] == \u0026#39;a\u0026#39;) { x = i; } else if (y == -1 \u0026amp;\u0026amp; chs[i] == \u0026#39;b\u0026#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x \u0026lt; y; } "},{"id":82,"href":"/docs/leetcode/others/5968/","title":"5968th","section":"Leet Code","content":" \rLink\n class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i \u0026lt; m - 1; i++) { if (!bank[i].contains(\u0026#34;1\u0026#34;)) { continue; } int t = calculate(bank, i); // 计算这一行符合的激光束数量  if (t \u0026gt; 0) { // update result  for (int j = 0; j \u0026lt; n; j++) { if (bank[i].charAt(j) == \u0026#39;1\u0026#39;) { res += t; } } } } return res; } private int calculate(String[] bank, int start) { int end = start; for (int i = end + 1; i \u0026lt; m; i++) { if (bank[i].contains(\u0026#34;1\u0026#34;)) { end = i; break; } } int result = 0; if (end != start) { for (int i = 0; i \u0026lt; n; i++) { if (bank[end].charAt(i) == \u0026#39;1\u0026#39;) { result++; } } } return result; } } "},{"id":83,"href":"/docs/leetcode/others/5969/","title":"5969th","section":"Leet Code","content":" [Link]\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t \u0026lt; a) { return false; } else { t += a; } } return true; } } "},{"id":84,"href":"/docs/leetcode/others/7/","title":"7th","section":"Leet Code","content":" \rLink\n public int reverse(int x) { // java 这里-11 % 10 = -1 数学上应该是 9  int flag = 1; if (x \u0026lt; 0) { flag = -1; x = -x; } int res = 0; while (x != 0) { if (res \u0026gt; ((Integer.MAX_VALUE - (x % 10)) / 10)) { return 0; } res = res * 10 + (x % 10); x /= 10; } return res * flag; } "},{"id":85,"href":"/docs/leetcode/others/748/","title":"748th","section":"Leet Code","content":" \rLink\n public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = \u0026#34;\u0026#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) \u0026amp;\u0026amp; word.length() \u0026lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i \u0026lt; a1.length; i++) { if (a1[i] \u0026gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.toCharArray()) { if (Character.isLetter(c)) { c = Character.toUpperCase(c); tmp[c - \u0026#39;A\u0026#39;]++; } } return tmp; } "},{"id":86,"href":"/docs/leetcode/others/9/","title":"9th","section":"Leet Code","content":" \rLink\n public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int y = x; int res = 0; while (x \u0026gt; 0) { res = res * 10 + (x % 10); x /= 10; } return res == y; } public boolean isPalindrome(int x) { String s = String.valueOf(x); return s.equals(new StringBuilder(s).reverse().toString()); } "},{"id":87,"href":"/docs/leetcode/recursion/1492/","title":"1492nd","section":"Leet Code","content":" \rLink\n public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f \u0026gt;= n \u0026amp;\u0026amp; k \u0026gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); } "},{"id":88,"href":"/docs/leetcode/simulation/12/","title":"12th","section":"Leet Code","content":" \rLink\n public String intToRoman(int num) { int[] values = new int[]{ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; String[] chs = new String[]{ \u0026#34;I\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;M\u0026#34; }; StringBuilder sb = new StringBuilder(); for (int i = values.length - 1; i \u0026gt;= 0; i--) { while (num \u0026gt;= values[i]) { num -= values[i]; sb.append(chs[i]); } } return sb.toString(); } "},{"id":89,"href":"/docs/leetcode/simulation/13/","title":"13th","section":"Leet Code","content":" \rLink\n public int romanToInt(String s) { Map\u0026lt;Character, Integer\u0026gt; hash = new HashMap\u0026lt;\u0026gt;(); hash.put(\u0026#39;I\u0026#39;, 1); hash.put(\u0026#39;V\u0026#39;, 5); hash.put(\u0026#39;X\u0026#39;, 10); hash.put(\u0026#39;L\u0026#39;, 50); hash.put(\u0026#39;C\u0026#39;, 100); hash.put(\u0026#39;D\u0026#39;, 500); hash.put(\u0026#39;M\u0026#39;, 1000); int res = 0; int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (i + 1 \u0026lt; n \u0026amp;\u0026amp; hash.get(s.charAt(i)) \u0026lt; hash.get(s.charAt(i + 1))) { res = res + (-hash.get(s.charAt(i))); } else { res = res + hash.get(s.charAt(i)); } } return res; } "},{"id":90,"href":"/docs/leetcode/sorts/215/","title":"215th","section":"Leet Code","content":" \rLink\n 使用优先队列\n// Time Complexity: O(nlgn)  // Space Complexity: O(k)  public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int num : nums) { if (q.size() == k) { if (num \u0026gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); } "},{"id":91,"href":"/docs/leetcode/stack/20/","title":"20th","section":"Leet Code","content":" \rLink\n 查阅Ascii码表进行简化\npublic boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); } else { if (st.size() \u0026gt; 0 \u0026amp;\u0026amp; Math.abs(st.peek() - s.charAt(i)) \u0026lt;= 2) { st.pop(); } else { return false; } } } return st.size() == 0; } public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); continue; } if (st.size() == 0 || (s.charAt(i) == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;(\u0026#39;) || (s.charAt(i) == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;[\u0026#39;) || (s.charAt(i) == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;{\u0026#39;)) { return false; } st.pop(); } return st.size() == 0; } "},{"id":92,"href":"/docs/leetcode/string/14/","title":"14th","section":"Leet Code","content":" \rLink\n public String longestCommonPrefix(String[] strs) { StringBuilder sb = new StringBuilder(); int n = strs[0].length(); for (int i = 0; i \u0026lt; n; i++) { char c = strs[0].charAt(i); for (int j = 1; j \u0026lt; strs.length; j++) { if (i \u0026gt;= strs[j].length() || c != strs[j].charAt(i)) { return sb.toString(); } } sb.append(c); } return sb.toString(); } "},{"id":93,"href":"/docs/leetcode/string/28/","title":"28th","section":"Leet Code","content":" \rLink\n "},{"id":94,"href":"/docs/leetcode/string/5/","title":"5th","section":"Leet Code","content":" \rLink\n public String longestPalindrome(String s) { int n = s.length(); String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { int l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } l = i; r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } } return res; } "},{"id":95,"href":"/docs/leetcode/string/6/","title":"6th","section":"Leet Code","content":" \rLink\n 转成索引排列，找出规律\npublic String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; numRows; i++) { if (i == 0 || i == numRows - 1) { for (int j = i; j \u0026lt; n; j += 2 * numRows - 2) { sb.append(s.charAt(j)); } } else { for (int j = i, k = 2 * numRows - 2 - i; j \u0026lt; n || k \u0026lt; n; j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j \u0026lt; n) { sb.append(s.charAt(j)); } if (k \u0026lt; n) { sb.append(s.charAt(k)); } } } } return sb.toString(); } "},{"id":96,"href":"/docs/leetcode/string/8/","title":"8th","section":"Leet Code","content":" \rLink\n class Solution { public int myAtoi(String s) { int k = 0; int n = s.length(); while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) == \u0026#39; \u0026#39;) { k++; } if (k == n) { return 0; } int minus = 1; if (s.charAt(k) == \u0026#39;-\u0026#39;) { minus = -1; k++; } else if (s.charAt(k) == \u0026#39;+\u0026#39;) { k++; } int res = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s.charAt(k) \u0026lt;= \u0026#39;9\u0026#39;) { int x = s.charAt(k) - \u0026#39;0\u0026#39;; if (minus \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (Integer.MAX_VALUE - x) / 10) { return Integer.MAX_VALUE; } if (minus \u0026lt; 0 \u0026amp;\u0026amp; -res \u0026lt; (Integer.MIN_VALUE + x) / 10) { return Integer.MIN_VALUE; } if (-res * 10 - x == Integer.MIN_VALUE) { return Integer.MIN_VALUE; } res = res * 10 + x; k++; } res *= minus; return res; } } "},{"id":97,"href":"/docs/leetcode/tree/102/","title":"102nd","section":"Leet Code","content":" \rLink\n 考虑当前层结束条件，即当前队列中的元素个数。\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); int count = q.size(); while (count \u0026gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; } "},{"id":98,"href":"/docs/leetcode/tree/559/","title":"559th","section":"Leet Code","content":" \rLink 一道简单的搜索\n public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i \u0026lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; } "},{"id":99,"href":"/docs/leetcode/tree/700/","title":"700th","section":"Leet Code","content":" \rLink\n 递归搜索\nclass Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val \u0026gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } } "},{"id":100,"href":"/docs/leetcode/twopointers/11/","title":"11th","section":"Leet Code","content":" \rLink\n public int maxArea(int[] height) { int res = 0; for (int i = 0, j = height.length - 1; i \u0026lt; j; ) { res = Math.max(res, Math.min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) { i++; } else { j--; } } return res; } "},{"id":101,"href":"/docs/leetcode/twopointers/15/","title":"15th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) { // 找靠近左边第一个\u0026gt;=的k索引  k--; } if (nums[i] + nums[j] + nums[k] == 0) { res.add(List.of(nums[i], nums[j], nums[k])); } } } return res; } "},{"id":102,"href":"/docs/leetcode/twopointers/16/","title":"16th","section":"Leet Code","content":" \rLink\n public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { int j = i + 1, k = nums.length - 1; while (j \u0026lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum \u0026gt; target) { k--; } else { j++; } if (Math.abs(target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } return res; } public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) { k--; } int sum = nums[i] + nums[j] + nums[k]; // 靠近左边第一个\u0026gt;=target的k  if (Math.abs(sum - target) \u0026lt; Math.abs(target - res)) { res = sum; } if (k - 1 \u0026gt; j) { sum = nums[i] + nums[j] + nums[k - 1]; // \u0026lt; target  if ((target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } } return res; } `` "},{"id":103,"href":"/docs/leetcode/twopointers/18/","title":"18th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } for (int k = j + 1, u = n - 1; k \u0026lt; u; k++) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { continue; } while (k \u0026lt; u - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k] + nums[u - 1] \u0026gt;= target) { u--; } if (nums[i] + nums[j] + nums[k] + nums[u] == target) { res.add(List.of(nums[i], nums[j], nums[k], nums[u])); } } } } return res; } "},{"id":104,"href":"/docs/leetcode/twopointers/26/","title":"26th","section":"Leet Code","content":" \rLink\n public int removeDuplicates(int[] nums) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i == 0 || nums[i] != nums[i - 1]) { nums[j++] = nums[i]; } } return j; } "},{"id":105,"href":"/docs/leetcode/twopointers/27/","title":"27th","section":"Leet Code","content":" \rLink\n public int removeElement(int[] nums, int val) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[j++] = nums[i]; } } return j; } "},{"id":106,"href":"/docs/leetcode/twopointers/3/","title":"3rd","section":"Leet Code","content":" \rLink\n int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;char, int\u0026gt; map{}; int res = 0; int n = s.length(); int j = 0; for (int i = 0; i \u0026lt; n; i++) { map[s[i]]++; if (map[s[i]] \u0026gt; 1) { while (map[s[i]] \u0026gt; 1) { map[s[j++]]--; } } res = max(res, i - j + 1); } return res; } public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int res = 0; int n = s.length(); for (int i = 0, j = 0; i \u0026lt; n; i++) { map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1); if (map.get(s.charAt(i)) == 1) { res = Math.max(res, i - j + 1); continue; } while (map.get(s.charAt(i)) \u0026gt; 1) { map.put(s.charAt(j), map.get(s.charAt(j)) - 1); j++; } } return res; } "},{"id":107,"href":"/docs/leetcode/twopointers/4/","title":"4th","section":"Leet Code","content":" \rLink\n public double findMedianSortedArrays(int[] nums1, int[] nums2) { int k = nums1.length + nums2.length; if (k % 2 == 0) { int left = findKth(nums1, 0, nums2, 0, k / 2); int right = findKth(nums1, 0, nums2, 0, k / 2 + 1); return (left + right) / 2.0; } else { return findKth(nums1, 0, nums2, 0, k / 2 + 1); } } // 二分做法  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { if (nums1.length - i \u0026gt; nums2.length - j) { return findKth(nums2, j, nums1, i, k); } if (nums1.length == i) { return nums2[j + k - 1]; } if (k == 1) { return Math.min(nums1[i], nums2[j]); } int k1 = Math.min(nums1.length - i, k / 2); int k2 = k - k1; if (nums1[i + k1 - 1] \u0026lt; nums2[j + k2 - 1]) { return findKth(nums1, i + k1, nums2, j, k - k1); } else { return findKth(nums1, i, nums2, j + k2, k - k2); } } //优先队列做法  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); while (i \u0026lt; nums1.length) { pq.offer(nums1[i++]); } while (j \u0026lt; nums2.length) { pq.offer(nums2[j++]); } int res = 0; while (k-- \u0026gt; 0) { res = pq.poll(); } return res; } "},{"id":108,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/","title":"剑指 Offer","section":"Leet Code","content":" \r剑指 Offer 03. 数组中重复的数字(E) \r14. 不修改数组找出重复的数字(E) \r剑指 Offer 04. 二维数组中的查找(M) \r剑指 Offer 05. 替换空格(E) \r剑指 Offer 50. 第一个只出现一次的字符(E) \r剑指 Offer 32 - I. 从上到下打印二叉树(M) \r剑指 Offer 32 - II. 从上到下打印二叉树 II(E) \r剑指 Offer 32 - III. 从上到下打印二叉树 III(M) \r剑指 Offer 47. 礼物的最大价值(M) \r剑指 Offer 26. 树的子结构(M) \r剑指 Offer 18. 删除链表的节点(E) \r剑指 Offer 22. 链表中倒数第k个节点(E) \r剑指 Offer 48. 最长不含重复字符的子字符串(M) \r剑指 Offer 46. 把数字翻译成字符串(M) \r剑指 Offer 25. 合并两个排序的链表(M) \r剑指 Offer 57. 和为s的两个数字(E) \r剑指 Offer 21. 调整数组顺序使奇数位于偶数前面(E) \r剑指 Offer 58 - I. 翻转单词顺序(E) \r剑指 Offer 13. 机器人的运动范围(M) \r剑指 Offer 12. 矩阵中的路径(M) \r剑指 Offer 64. 求1+2+…+n(M) \r剑指 Offer 54. 二叉搜索树的第k大节点(M) \r剑指 Offer 55 - I. 二叉树的深度(E) \r剑指 Offer 55 - II. 平衡二叉树(E) \r剑指 Offer 68 - I. 二叉搜索树的最近公共祖先(E) \r剑指 Offer 68 - II. 二叉树的最近公共祖先(E) \r剑指 Offer 15. 二进制中1的个数(E)  "},{"id":109,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/","title":"6th","section":"剑指 Offer","content":" \rLink\n vector\u0026lt;int\u0026gt; reversePrint(ListNode* head) { vector\u0026lt;int\u0026gt; res; while (head) { res.push_back(head-\u0026gt;val); head = head-\u0026gt;next; } return vector\u0026lt;int\u0026gt;(res.rbegin(), res.rend()); } public int[] reversePrint(ListNode head) { Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head.val); head = head.next; } int[] res = new int[s.size()]; int idx = 0; while (!s.isEmpty()) { res[idx++] = s.pop(); } return res; } "},{"id":110,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/","title":"3rd","section":"剑指 Offer","content":" \rLink\n 将元素放置到对应的位置。2代表下标为2的位置\nint findRepeatNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { while (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] != nums[i]) { swap(nums[i], nums[nums[i]]); } if (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] == nums[i]) { return nums[i]; } } return -1; } "},{"id":111,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/","title":"4th","section":"剑指 Offer","content":" \rLink\n \r上图是从右上角，同理左下角\n从右上角看成一个二分搜索树\nbool searchArray(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; array, int target) { if (array.size() == 0) { return false; } int m = array.size(); int n = array[0].size(); int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (array[i][j] == target) { return true; } else if (array[i][j] \u0026lt; target) { i++; } else { j--; } } return false; } public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] \u0026lt; target) { col++; } else { row--; } } return false; } "},{"id":112,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/","title":"5th","section":"剑指 Offer","content":" \rLink\n C语言需要注意内存分配，先求出空格数量，在计算出需要的内存大小。\npublic String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39; \u0026#39;) { sb.append(\u0026#34;%20\u0026#34;); } else { sb.append(s.charAt(i)); } } return sb.toString(); } "},{"id":113,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/","title":"12th","section":"剑指 Offer","content":" \rLink\n public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || board[i][j] != word.charAt(idx)) { return false; } if (idx == word.length() - 1) { return true; } board[i][j] = \u0026#39;0\u0026#39;; boolean res = search(board, word, idx + 1, i + 1, j) || search(board, word, idx + 1, i - 1, j) || search(board, word, idx + 1, i, j + 1) || search(board, word, idx + 1, i, j - 1); board[i][j] = word.charAt(idx); return res; } 菜写法，超时\nclass Solution { private int m; private int n; private char[][] board; private String word; private boolean[][] visited; public boolean exist(char[][] board, String word) { this.m = board.length; this.n = board[0].length; this.visited = new boolean[m][n]; this.board = board; this.word = word; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dfs(sb, i, j)) return true; } } return false; } private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; private boolean dfs(StringBuilder cur, int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n) { return false; } if (visited[x][y]) { return false; } cur.append(board[x][y]); visited[x][y] = true; int cmp = cur.length() - word.length(); if (cmp == 0 \u0026amp;\u0026amp; word.equals(cur.toString())) { return true; } else if (cmp \u0026lt; 0) { for (int i = 0; i \u0026lt; 4; i++) { int tmpX = x + dirs[i][0]; int tmpY = y + dirs[i][1]; if (dfs(cur, tmpX, tmpY)) return true; } } visited[x][y] = false; cur.deleteCharAt(cur.length() - 1); return false; } } "},{"id":114,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/","title":"13th","section":"剑指 Offer","content":" \rLink\n 简单DFS\nclass Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x \u0026gt;= m || x \u0026lt; 0 || y \u0026gt;= n || y \u0026lt; 0) return 0; if (visited[x][y] || !isValid(x, y)) { return 0; } visited[x][y] = true; return 1 + dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1); } private boolean isValid(int x, int y) { int val = 0; while (x \u0026gt; 0) { val += (x % 10); x /= 10; } while (y \u0026gt; 0) { val += (y % 10); y /= 10; } return val \u0026lt;= k; } } "},{"id":115,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/","title":"15th","section":"剑指 Offer","content":" \rLink\n public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;\u0026gt;= 1; } return res; } "},{"id":116,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/","title":"18th","section":"剑指 Offer","content":" \rLink\n class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } } "},{"id":117,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/","title":"21st","section":"剑指 Offer","content":" \rLink\n public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i \u0026lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; } "},{"id":118,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/","title":"22nd","section":"剑指 Offer","content":" \rLink\n public ListNode getKthFromEnd(ListNode head, int k) { Stack\u0026lt;ListNode\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head); head = head.next; } if (k \u0026gt; s.size()) return null; ListNode res = null; while (k \u0026gt; 0) { k--; res = s.pop(); } return res; } "},{"id":119,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/","title":"25th","section":"剑指 Offer","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null \u0026amp;\u0026amp; cur2 != null) { if (cur1.val \u0026lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.next; } "},{"id":120,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/","title":"26th","section":"剑指 Offer","content":" \rLink\n class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) \u0026amp;\u0026amp; help(A.right, B.right); } } "},{"id":121,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/","title":"32 1","section":"剑指 Offer","content":" \rLink\n class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } } "},{"id":122,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/","title":"32 2","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null]  while (q.peek() != null) { TreeNode node; List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); } res.add(tmp); q.offer(null); } return res; } } "},{"id":123,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/","title":"32 3","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList\u0026lt;Integer\u0026gt; tmp = new LinkedList\u0026lt;\u0026gt;(); int n = res.size(); for (int i = q.size(); i \u0026gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } res.add(tmp); } return res; } } "},{"id":124,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/","title":"46th","section":"剑指 Offer","content":" \rLink\n DFS\npublic int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start \u0026gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - \u0026#39;0\u0026#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start \u0026lt; str.length() - 1) { // 06  if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - \u0026#39;0\u0026#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25; } 动态规划\npublic int translateNum(int num) { String str = String.valueOf(num); int n = str.length(); // 以i为结尾 不同翻译数  int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1]; int val = (str.charAt(i - 2) - \u0026#39;0\u0026#39;) * 10 + (str.charAt(i - 1) - \u0026#39;0\u0026#39;); if (10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25) { dp[i] = (dp[i - 2] + dp[i - 1]); } } return dp[n]; } "},{"id":125,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/","title":"47th","section":"剑指 Offer","content":" \rLink\n class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } } "},{"id":126,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/","title":"48th","section":"剑指 Offer","content":" \rLink\n 双指针\npublic int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (j \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; } "},{"id":127,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/","title":"50th","section":"剑指 Offer","content":" \rLink\n class Solution { public char firstUniqChar(String s) { Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - \u0026#39;a\u0026#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return \u0026#39; \u0026#39;; } } "},{"id":128,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/","title":"54th","section":"剑指 Offer","content":" \rLink\n DFS\nprivate int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack\npublic int kthLargest(TreeNode root, int k) { Queue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (q.size() \u0026lt; k) { q.offer(node.val); } else if (q.peek() \u0026lt; node.val) { q.poll(); q.offer(node.val); } if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } return q.peek(); } "},{"id":129,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/","title":"55 1","section":"剑指 Offer","content":" \rLink\n public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } "},{"id":130,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/","title":"55 2","section":"剑指 Offer","content":" \rLink\n public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) \u0026lt; 2 \u0026amp;\u0026amp; (isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; } "},{"id":131,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/","title":"57th","section":"剑指 Offer","content":" \rLink\n public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i \u0026lt; j) { if (nums[i] + nums[j] \u0026lt; target) { i++; } else if (nums[i] + nums[j] \u0026gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; } "},{"id":132,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/","title":"58th","section":"剑指 Offer","content":" \rLink\n public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i \u0026gt;= 0) { while(i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] != \u0026#39; \u0026#39;) i--; sb.append(s.substring(i + 1, j + 1) + \u0026#34; \u0026#34;); while (i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] == \u0026#39; \u0026#39;) i--; j = i; } return sb.toString().trim(); } "},{"id":133,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/","title":"64th","section":"剑指 Offer","content":" \rLink\n public int sumNums(int n) { boolean tmp = n \u0026gt; 1 \u0026amp;\u0026amp; (n += sumNums(n - 1)) \u0026gt; 0; return n; } "},{"id":134,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/","title":"68 1","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } } "},{"id":135,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/","title":"68 2","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left == null ? right : left; } 任意k个数的最近公共祖先\nprivate int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.val == p.val || node.val == q.val) { k--; } dfs(node.left, p, q); dfs(node.right, p, q); if (oldK == 2 \u0026amp;\u0026amp; k == 0 \u0026amp;\u0026amp; res == null) { res = node; } } "},{"id":136,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/","title":"A14","section":"剑指 Offer","content":" \rLink\n 通过二分查找，判断左右区间的个数\nint duplicateInArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 1, r = nums.size() - 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int cnt = 0; for (auto x : nums) { if (x \u0026gt;= l \u0026amp;\u0026amp; x \u0026lt;= mid) { cnt++; } } if (cnt \u0026gt; mid - l + 1) { r = mid; } else { l = mid + 1; } } return l; } "},{"id":137,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"面试题","section":"Leet Code","content":" \r面试题 08.05. 递归乘法(M)  "},{"id":138,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/","title":"805th","section":"面试题","content":" \rLink\n public int multiply(int A, int B) { if (B == 0) return 0; else if (B == 1) return A; else return A + multiply(A, B - 1); } "},{"id":139,"href":"/docs/cs/leetcode/994/","title":"LeetCode 994","section":"C S","content":" 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。  public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue\u0026lt;int[]\u0026gt; Q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count \u0026gt; 0 \u0026amp;\u0026amp; !Q.isEmpty()) { times++; int curSize = Q.size(); for (int j = 0; j \u0026lt; curSize; j ++) { int[] node = Q.poll(); for (int i = 0; i \u0026lt; 4; i++) { int[] neighbor = new int[]{node[0] + dir[i][0], node[1] + dir[i][1]}; if (neighbor[0] \u0026lt; 0 || neighbor[1] \u0026lt; 0 || neighbor[0] \u0026gt;= m || neighbor[1] \u0026gt;= n || grid[neighbor[0]][neighbor[1]] != 1) continue; grid[neighbor[0]][neighbor[1]] = 2; fresh_count--; Q.add(neighbor); } } } return fresh_count != 0 ? -1 : times; } "},{"id":140,"href":"/posts/test/test/","title":"Test","section":"Blog","content":"Test\n"},{"id":141,"href":"/posts/2022/","title":"关于我的2022的一些记录","section":"Blog","content":"读书\r#\r\r   Name Start Update     \r《国境以南太阳以西》 2021-01-11 2021-01-12    收藏的博客\r#\r\r   博客名称 添加日期 type 备注     \rSHUHARI 的博客 2021.01.04 重写 500 Lines 宝藏    收藏的文章\r#\r\r   文章名称 添加日期 type 备注     - 我在职业生涯中学到的所有良好实践 2022.02.06 技术文章 宝藏    "}]