<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Day Day Up</title><link>https://cs-learning-every-day.github.io/</link><description>Recent content in Introduction on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/786/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/786/</guid><description>
#include &amp;lt;iostream&amp;gt; using namespace std; int q[100001]; int quick_sort(int l, int r, int k) { if (l == r) { return q[l]; } int x = q[l], i = l - 1, j = r + 1; while (i &amp;lt; j) { while (q[++i] &amp;lt; x); while (q[--j] &amp;gt; x); if (i &amp;lt; j) { swap(q[i], q[j]); } } int sl = j - l + 1; if (k &amp;lt;= sl) return quick_sort(l, j, k); return quick_sort(j + 1, r, k - sl); } int main() { int n, k; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 0; i &amp;lt; n; i++) { cin &amp;gt;&amp;gt; q[i]; } cout &amp;lt;&amp;lt; quick_sort(0, n - 1, k); return 0; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/791/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/791/</guid><description>#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; const int N = 1e6 + 10; vecotr&amp;lt;int&amp;gt; add(vecotr&amp;lt;int&amp;gt; &amp;amp;A, vecotr&amp;lt;int&amp;gt; &amp;amp;B) { vector&amp;lt;int&amp;gt; C; int t = 0; for (int i = 0; i &amp;lt; A.size() || i &amp;lt; B.size(); i++) { if (i &amp;lt; A.size()) { t += A[i]; } if (i &amp;lt; B.size()) { t += B[i]; } C.push_back(t % 10); t /= 10; } if (t) { C.push_back(1); } return C; } int main() { string a, b; vecotr&amp;lt;int&amp;gt; A, B; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; // a = &amp;#34;123456&amp;#34; for (int i = a.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/792/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/792/</guid><description>两个正整数相减 A - B 考虑A &amp;lt; 0, B &amp;lt; 0 &amp;ndash;&amp;gt; A - B = -(|A| + |B|) 考虑A &amp;gt; 0, B &amp;lt; 0 &amp;ndash;&amp;gt; A - B = |A| + |B|
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; // 判断A&amp;gt;=B bool cmp(vecotr&amp;lt;int&amp;gt; &amp;amp;A, vecotr&amp;lt;int&amp;gt; &amp;amp;B) { if (A.size() != B.size()) { return A.size() &amp;gt; B.size(); } for (int i = A.size() - 1; i &amp;gt;= 0; i--) { if (A[i] !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/793/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/793/</guid><description>两个正整数相乘 大*小
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; vecotr&amp;lt;int&amp;gt; mul(vecotr&amp;lt;int&amp;gt; &amp;amp;A, int b) { vecotr&amp;lt;int&amp;gt; C; int t = 0; for (int i = 0; i &amp;lt; A.size() || t != 0; i++) { if (i &amp;lt; A.size()) { t += A[i] * b; } C.push_back(t % 10); t /= 10; } return C; } int main() { string a; int b; vecotr&amp;lt;int&amp;gt; A; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; // a = &amp;#34;123456&amp;#34; for (int i = a.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/794/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/794/</guid><description>两个正整数相除 大/小
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; vecotr&amp;lt;int&amp;gt; mul(vecotr&amp;lt;int&amp;gt; &amp;amp;A, int b, int &amp;amp;r) { vecotr&amp;lt;int&amp;gt; C; int t = 0; r = 0; for (int i = A.size(); i &amp;gt;= 0; i--) { r = r * 10 + A[i]; C.push_back(r / b); r = r % b; } reverse(C.begin(), C.end()); while (C.size() &amp;gt; 1 &amp;amp;&amp;amp; C.back() == 0) { C.pop_back(); } return C; } int main() { string a; int b; vecotr&amp;lt;int&amp;gt; A; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; // a = &amp;#34;123456&amp;#34; for (int i = a.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/795/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/795/</guid><description>
#include &amp;lt;iostream&amp;gt;using namespace std; const int N = 100010; int n, m; int a[N], s[N]; int main() { a[0] = 0; s[0] = 0; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); } for (int i = 1; i &amp;lt;= n; i++) { s[i] = s[i - 1] + a[i]; } while (m--) { int l, r; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;r, &amp;amp;l); printf(&amp;#34;%d\n&amp;#34;, s[r] - s[l - 1]); } return 0; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/796/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/796/</guid><description>
#include &amp;lt;iostream&amp;gt; const int N = 1010; int n, m, q; int a[N][N], s[N][N]; int main() { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;n, &amp;amp;m, &amp;amp;q); for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]); } } for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } } while (q--) { int x1, y1, x2, y2; scanf(&amp;#34;%d%d%d%d&amp;#34;, &amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2); printf(&amp;#34;%d\n&amp;#34;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 -1] + s[x1 - 1][y1 -1]); } return 0; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/797/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/797/</guid><description>
#include &amp;lt;iostream&amp;gt;using namespace std; const int N = 100010; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); } for (int i = 1; i &amp;lt;= n; i++) { insert(i, i, a[i]); } while (m--) { int l, r, c; scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;l, &amp;amp;r, &amp;amp;c); insert(l, r, c); } for (int i = 1; i &amp;lt;= n; i++) { b[i] += b[i - 1]; } for (int i = 1; i &amp;lt;= n; i++) { printf(&amp;#34;%d &amp;#34;, b[i]); } return 0; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/acwing/basic/798/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/acwing/basic/798/</guid><description>
#include &amp;lt;iostream&amp;gt;using namespace std; const int N = 1010; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;n, &amp;amp;m, &amp;amp;q); for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]); } } for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { insert(i, j, i, j, a[i][j]); } } while (q--) { int x1, y1, x2, y2, c; scanf(&amp;#34;%d%d%d%d%d&amp;#34;, &amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2, &amp;amp;c); insert(x1, y1, x2, y2, c); } for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; } } for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { printf(&amp;#34;%d &amp;#34;, b[i][j]); } puts(&amp;#34;&amp;#34;); } return 0; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/book/resource/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/book/resource/</guid><description>相关资源
#
No Starch Press
The Pragmatic Bookshelf
Manning
O&amp;rsquo;Reilly
Let Me Read
Library Genesis
SaltTiger 目前我主要在以下网站收集编程类电子书，大家去这上面找书就好，下载方法也一并给出：
CoderProg，点击验证码，跳转至Rapidgator或Turbobit网盘，将网盘链接复制到
木薯牛网盘中转站（1G流量1.33元）进行中转，即可下载。
AvaxHome，跳转至icerbox网盘，将网盘链接复制到
思飞网盘中转站（1G icerbox流量2.8元）进行中转，中转后自动转存到绑定的百度网盘，即可下载。
Fox eBook，跳转至NitroFlare网盘，将网盘链接复制到
木薯牛网盘中转站进行中转，即可下载。
Library Genesis，点击Mirrors链接直接下载。
Let Me Read，点击验证码，跳转DirectLink直接下载。
Zlibrary</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/book/timeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/book/timeline/</guid><description>读书
#
书籍是人类进步的阶梯
温故而知新,可以为师矣
《Java并发编程的艺术》
2021/10/9 P280 ~ P304 2021/10/30 finish 《操作系统导论》
2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 finish 《Build On Your Lisp》
2021/10/12 CH7 2021/10/23 CH10 2021/11/5 finish 《UNIX环境高级编程》
2021/10/22 CH11 2021/10/31 CH12 2021/11/10 2021/11/20 Ch16 2021/11/24 Finish</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/algo/template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/algo/template/</guid><description>Basic
#
Quick Sort
#
void quick_sort(int q[], int l, int r) { if (l &amp;gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &amp;gt;&amp;gt; 1]; while (i &amp;lt; j) { do i ++ ; while (q[i] &amp;lt; x); do j -- ; while (q[j] &amp;gt; x); if (i &amp;lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort
#
void merge_sort(int q[], int l, int r) { if (l &amp;gt;= r) return; int mid = l + r &amp;gt;&amp;gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= r) if (q[i] &amp;lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &amp;lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &amp;lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &amp;lt;= r; i ++, j ++ ) q[i] = tmp[j]; } Binary Search
#
// 区间[l,r]划分成[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l &amp;lt; r) { int mid = l + r &amp;gt;&amp;gt; 1; if (check(mid)) { //check() 检查mid是否满足性质 r = mid; } else { l = mid + 1; } } } // 区间[l,r]划分成[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l &amp;lt; r) { int mid = l + r + 1&amp;gt;&amp;gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</guid><description>11.2 定位问题
#
线上代码定位问题
11.3 性能测试
#
相关的命令</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/206/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/206/</guid><description>public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/21/</guid><description>ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = &amp;amp;dummy; while (p1 &amp;amp;&amp;amp; p2) { if (p1-&amp;gt;val &amp;gt; p2-&amp;gt;val) { cur-&amp;gt;next = p2; p2 = p2-&amp;gt;next; } else { cur-&amp;gt;next = p1; p1 = p1-&amp;gt;next; } cur = cur-&amp;gt;next; } cur-&amp;gt;next = p1 ? p1 : p2; return dummy.next;</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/273/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/273/</guid><description>class Solution { private final String[] LESS_THAN_20 = {&amp;#34;&amp;#34;, &amp;#34;One&amp;#34;, &amp;#34;Two&amp;#34;, &amp;#34;Three&amp;#34;, &amp;#34;Four&amp;#34;, &amp;#34;Five&amp;#34;, &amp;#34;Six&amp;#34;, &amp;#34;Seven&amp;#34;, &amp;#34;Eight&amp;#34;, &amp;#34;Nine&amp;#34;, &amp;#34;Ten&amp;#34;, &amp;#34;Eleven&amp;#34;, &amp;#34;Twelve&amp;#34;, &amp;#34;Thirteen&amp;#34;, &amp;#34;Fourteen&amp;#34;, &amp;#34;Fifteen&amp;#34;, &amp;#34;Sixteen&amp;#34;, &amp;#34;Seventeen&amp;#34;, &amp;#34;Eighteen&amp;#34;, &amp;#34;Nineteen&amp;#34;}; private final String[] TENS = {&amp;#34;&amp;#34;, &amp;#34;Ten&amp;#34;, &amp;#34;Twenty&amp;#34;, &amp;#34;Thirty&amp;#34;, &amp;#34;Forty&amp;#34;, &amp;#34;Fifty&amp;#34;, &amp;#34;Sixty&amp;#34;, &amp;#34;Seventy&amp;#34;, &amp;#34;Eighty&amp;#34;, &amp;#34;Ninety&amp;#34;}; private final String[] THOUSANDS = {&amp;#34;&amp;#34;, &amp;#34;Thousand&amp;#34;, &amp;#34;Million&amp;#34;, &amp;#34;Billion&amp;#34;}; public String numberToWords(int num) { if (num == 0) return &amp;#34;Zero&amp;#34;; int i = 0; String words = &amp;#34;&amp;#34;; while (num &amp;gt; 0) { if (num % 1000 !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/29/</guid><description>long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a &amp;lt; 0) sign *= -1; if (b &amp;lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a &amp;gt;= b) { long count = 1; long c = b; while ((c &amp;lt;&amp;lt; 1) &amp;lt;= a) { c &amp;lt;&amp;lt;= 1; count &amp;lt;&amp;lt;= 1; } quotient += count; a -= c; } if (sign * quotient &amp;gt; INT_MAX) { return INT_MAX; } return quotient*sign;</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/46/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/46/</guid><description>public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; cur; vector&amp;lt;bool&amp;gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans, vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, vector&amp;lt;int&amp;gt;&amp;amp; cur, vector&amp;lt;bool&amp;gt;&amp;amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i &amp;lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/542/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/542/</guid><description>看成图，0为起点
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; updateMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat) { int m = mat.size(), n = mat[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dist(m, vector&amp;lt;int&amp;gt;(n, -1)); queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Q; for (int i = 0 ; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/77/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/77/</guid><description>public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); dfs(ans, 1, k, n, new ArrayList&amp;lt;&amp;gt;()); return ans; } private void dfs(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans, int start, int k, int n, List&amp;lt;Integer&amp;gt; cur) { if (cur.size() == k) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = start; i &amp;lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/784/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/784/</guid><description>public List&amp;lt;String&amp;gt; letterCasePermutation(String s) { List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List&amp;lt;String&amp;gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/tips/</guid><description>摩尔投票算法
#
/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/linux/gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/linux/gdb/</guid><description>GCC
#
-E 获取预处理后的文件内容
-V 将编译、链接过程打印
-g 用于GDB调试
ltrace 命令用来跟踪程序运行时调用的库函数
-S 查看系统调用 -e trace=write 只看write系统调用 strace 查看系统调用的封装函数
GDB
#
Segment Fault快速定位
首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core list start ctrl + x + a</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/linux/main/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/linux/main/</guid><description>strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name &amp;ldquo;*.cpp&amp;rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt xxd 查看文件二进制 输出当前用户是不是 root
[ $UID -eq 0 ] &amp;amp;&amp;amp; echo &amp;quot;is root!&amp;quot; 查看磁盘引导扇区 (Master Boot Record)
cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 - 统计所有 cpp 文件的行数</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/linux/vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/linux/vim/</guid><description> Vscode插件 Learn Vim</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/linux/wsl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/linux/wsl/</guid><description>为WSL2加图形化界面配置
运行 startxfce4</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/network/tcp-ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/network/tcp-ip/</guid><description> sudo apt install net-tools
#
ifconfig
netstat -in
tcpdump</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/programming/rust/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/programming/rust/readme/</guid><description>Cargo
#
cargo new project-name</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/design/146/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/design/146/</guid><description>Link
使用java的双向链表LinkedList有坑啊，过不了。
class LRUCache { private int capacity; private DoubleList list; private Map&amp;lt;Integer, Node&amp;gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap&amp;lt;&amp;gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/design/355/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/design/355/</guid><description>Link
class Twitter { private Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; follows; private Map&amp;lt;Integer, PriorityQueue&amp;lt;Integer&amp;gt;&amp;gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map&amp;lt;Integer, Integer&amp;gt; orders = new HashMap&amp;lt;&amp;gt;(); public Twitter() { follows = new HashMap&amp;lt;&amp;gt;(); tweets = new HashMap&amp;lt;&amp;gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue&amp;lt;Integer&amp;gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue&amp;lt;Integer&amp;gt;((a, b) -&amp;gt; b - a); tweets.put(userId, tmp); } int key = ai.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dfs/139/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dfs/139/</guid><description>Link
遍历字符串，将其分成两部分left和right，判断是否都在wordList里。
加上记忆化
public boolean wordBreak(String s, List&amp;lt;String&amp;gt; wordDict) { Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(wordDict); Map&amp;lt;String, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set&amp;lt;String&amp;gt; set, Map&amp;lt;String, Boolean&amp;gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i &amp;lt; n; i++) { String left = s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dfs/5964/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dfs/5964/</guid><description>TODO: Link
class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i &amp;lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i &amp;lt; len; i++) { if (checkAndRun(pos, s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/118/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i &amp;lt;= numRows; i++) { for (int j = 1; j &amp;lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i &amp;lt;= numRows; i++) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for (int j = 1; j &amp;lt;= i; j++) { tmp.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/119/</guid><description>Link
class Solution { public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row &amp;lt;= rowIndex; row++) { for (int col = 1; col &amp;lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for (int col = 1; col &amp;lt;= rowIndex; col++) { ans.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/120/</guid><description>Link
DP 要从下往上找，否则不一定是全局最优
2 3 4 6 5 1 4 1 8 3
class Solution { public int minimumTotal(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j &amp;lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt;= i; j++) { dp[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/122/</guid><description>Link
可以把数据看成折线图，则所有上升之和为解
public int maxProfit(int[] prices) { int res = 0; for (int i = 0; i &amp;lt; prices.length - 1; i++) { if (prices[i + 1] &amp;gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP
public int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润 int[] dp1 = new int[n]; // 第i天卖掉的最大利润 int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i &amp;lt; n; i++) { // 可以不买或卖 dp1[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/123/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/123/</guid><description>Link
public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: 持有第一股的最大利益 // dp[0][1]: 售出第一股的最大利益 // dp[0][2]: 持有第二股的最大利益 // dp[0][3]: 售出第二股的最大利益 int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/198/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/198/</guid><description>
Link
class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: 第一个房间抢 // dp[0][1]: 第一个房间不抢 int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i &amp;lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/213/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/213/</guid><description>Link
class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j) private int help(int[] nums, int i, int j) { // 0 : 抢 // 1 : 不抢 int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i &amp;lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/264/</guid><description>Link
使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]
[1] -&amp;gt; [2 3 5] -&amp;gt; [3 4 5 6 10] -&amp;gt; &amp;hellip;
class Solution { // Time Complexity: O(3N * lg3N) // 每次产生 最小数的2、3、5倍数 public int nthUglyNumber(int n) { PriorityQueue&amp;lt;Long&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); q.add(1L); long top = -1L; for (int i = 0; i &amp;lt; n; i++) { top = q.peek(); while (!q.isEmpty() &amp;amp;&amp;amp; q.peek() == top) { q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/309/</guid><description>Link
DP
public int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润 int[] dp1 = new int[n + 1]; // i天买入的最大利润 int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出) dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入) dp2[i] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/509/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/509/</guid><description>
Link
public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i &amp;lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/62/</guid><description>Link
DP
dp[i][j] 表示能到i行j列不同路径个数
初始化第一行和和第一列为1
class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &amp;lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j &amp;lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i &amp;lt;= m; i++) { for (int j = 2; j &amp;lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+记忆化</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/63/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/63/</guid><description>
Link
同
62题题思路一样
直接看DP解法，注意初始化，有障碍物时，就不能往后走了
class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &amp;lt; m &amp;amp;&amp;amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j &amp;lt; n &amp;amp;&amp;amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i &amp;lt; m; i++) { for (int j = 1; j &amp;lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/64/</guid><description>Link
dp[i][j] 表示到i行j列最小总和 注意初始化
class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int k = i; k &amp;gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j &amp;lt; n; j++) { for (int k = j; k &amp;gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i &amp;lt; m; i++) { for (int j = 1; j &amp;lt; n; j++) { dp[i][j] = Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/714/</guid><description>
Link
第i天买入的最大利润buy[i]
卖出的最大利润sell[i]
卖出的时候(完成了一笔交易)减去手续费
class Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i &amp;lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/dynamicprogramming/91/</guid><description>Link
DFS搜索 + 记忆化 class Solution { private Map&amp;lt;String, Integer&amp;gt; memo = new HashMap&amp;lt;&amp;gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i &amp;gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i &amp;lt; n - 1 &amp;amp;&amp;amp; isValid(s.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/1046/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/1046/</guid><description>Link
// Time Complexity: O(nlogn) // Space Complexity: O(n) public int lastStoneWeight(int[] stones) { PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() &amp;gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/347/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/347/</guid><description>Link
public int[] topKFrequent(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() &amp;lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() &amp;gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/heap/451/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/heap/451/</guid><description>Link
public String frequencySort(String s) { Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue&amp;lt;Character&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;((a, b) -&amp;gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i &amp;lt; n; i++) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/1979/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/1979/</guid><description>
Link
public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a &amp;gt; b private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/384/</guid><description>
Link
常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。
第一轮：1/n
第二轮：(n-1)/n * 1/(n-1)
第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)
…………
private int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i &amp;lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/519/</guid><description>Link
class Solution { private int m; private int n; private int count; private Map&amp;lt;Integer, Integer&amp;gt; map; /** 转成一维数组 索引i 相当于=&amp;gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =&amp;gt; 5 =&amp;gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =&amp;gt; 6 =&amp;gt; 3 map[5] = 4 map[3] = map[4] = 5 ... .</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/math/812/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/math/812/</guid><description>Link
看评论区都用线性代数，没学过线性代数的我，泪目了哭！
public double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i &amp;lt; points.length; i++) { for (int j = i + 1; j &amp;lt; points.length; j++) { for (int k = j + 1; k &amp;lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp &amp;gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b &amp;gt; c) || (a + c &amp;gt; b) || (b + c) &amp;gt; a; } // 果断找个公式，海伦公式 private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/1005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/1005/</guid><description>Link
写的实在是太丑陋了, 太多边界条件不易写
class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // 最小&amp;gt;0的数索引 for (int n : nums) { if (n &amp;lt; 0) i++; else break; } int j = i - 1; // 最大负数索引 int negCount = i; int idx = negCount - i; while (k &amp;gt; 0) { if (negCount &amp;gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i &amp;lt; nums.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/383/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/383/</guid><description>
Link
class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - &amp;#39;a&amp;#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - &amp;#39;a&amp;#39;] &amp;lt;= 0) return false; count[c - &amp;#39;a&amp;#39;]--; } return true; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5963/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5963/</guid><description>TODO: Link
class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; s.charAt(i) == &amp;#39;0&amp;#39;) { i--; } for ( ; i &amp;gt;= 0; i--) { sb.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5965/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5965/</guid><description>TODO: Link
稍微优化下还是超时，放弃
class Solution { Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i &amp;lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List&amp;lt;Integer&amp;gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; arr.length; i++) { // if (i == begin) continue; if (arr[begin] == arr[i]) { list.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5967/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5967/</guid><description>
Link
public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i &amp;lt; chs.length; i++) { if (chs[i] == &amp;#39;a&amp;#39;) { x = i; } else if (y == -1 &amp;amp;&amp;amp; chs[i] == &amp;#39;b&amp;#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x &amp;lt; y; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5968/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5968/</guid><description>Link
class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i &amp;lt; m - 1; i++) { if (!bank[i].contains(&amp;#34;1&amp;#34;)) { continue; } int t = calculate(bank, i); // 计算这一行符合的激光束数量 if (t &amp;gt; 0) { // update result for (int j = 0; j &amp;lt; n; j++) { if (bank[i].</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/5969/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/5969/</guid><description> [Link]
class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t &amp;lt; a) { return false; } else { t += a; } } return true; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/others/748/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/others/748/</guid><description>Link
public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = &amp;#34;&amp;#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) &amp;amp;&amp;amp; word.length() &amp;lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i &amp;lt; a1.length; i++) { if (a1[i] &amp;gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/recursion/1492/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/recursion/1492/</guid><description>
Link
public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f &amp;gt;= n &amp;amp;&amp;amp; k &amp;gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/sorts/215/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/sorts/215/</guid><description>
Link
使用优先队列
// Time Complexity: O(nlgn) // Space Complexity: O(k) public int findKthLargest(int[] nums, int k) { PriorityQueue&amp;lt;Integer&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); for (int num : nums) { if (q.size() == k) { if (num &amp;gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/102/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/102/</guid><description>
Link
考虑当前层结束条件，即当前队列中的元素个数。
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); int count = q.size(); while (count &amp;gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/559/</guid><description>
Link 一道简单的搜索
public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i &amp;lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/tree/700/</guid><description>
Link
递归搜索
class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val &amp;gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/</guid><description>
Link
上图是从右上角，同理左下角
class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] &amp;lt; target) { col++; } else { row--; } } return false; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/</guid><description>Link
public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i &amp;lt; 0 || i &amp;gt;= board.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/</guid><description>Link
简单DFS
class Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x &amp;gt;= m || x &amp;lt; 0 || y &amp;gt;= n || y &amp;lt; 0) return 0; if (visited[x][y] || !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/</guid><description>
Link
public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n &amp;amp; 0x1); n &amp;gt;&amp;gt;&amp;gt;= 1; } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/</guid><description>
Link
class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/</guid><description>
Link
public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i &amp;lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/</guid><description>
Link
public ListNode getKthFromEnd(ListNode head, int k) { Stack&amp;lt;ListNode&amp;gt; s = new Stack&amp;lt;&amp;gt;(); while (head != null) { s.push(head); head = head.next; } if (k &amp;gt; s.size()) return null; ListNode res = null; while (k &amp;gt; 0) { k--; res = s.pop(); } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/</guid><description>Link
public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null &amp;amp;&amp;amp; cur2 != null) { if (cur1.val &amp;lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/</guid><description>
Link
class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) &amp;amp;&amp;amp; help(A.right, B.right); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/</guid><description>
Link
class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if (root == null) return res; Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null] while (q.peek() != null) { TreeNode node; List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/</guid><description>Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Queue&amp;lt;TreeNode&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList&amp;lt;Integer&amp;gt; tmp = new LinkedList&amp;lt;&amp;gt;(); int n = res.size(); for (int i = q.size(); i &amp;gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/</guid><description>Link
DFS
public int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start &amp;gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - &amp;#39;0&amp;#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start &amp;lt; str.length() - 1) { // 06 if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - &amp;#39;0&amp;#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= 25; } 动态规划</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/</guid><description>
Link
class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/</guid><description>
Link
双指针
public int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map&amp;lt;Character, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); while (j &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/</guid><description>
Link
class Solution { public char firstUniqChar(String s) { Map&amp;lt;Character, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - &amp;#39;a&amp;#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return &amp;#39; &amp;#39;; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/</guid><description>Link
DFS
private int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack
public int kthLargest(TreeNode root, int k) { Queue&amp;lt;Integer&amp;gt; q = new PriorityQueue&amp;lt;&amp;gt;(); Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/</guid><description>
Link
public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/</guid><description>
Link
public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) &amp;lt; 2 &amp;amp;&amp;amp; (isBalanced(root.left) &amp;amp;&amp;amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/</guid><description>
Link
public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i &amp;lt; j) { if (nums[i] + nums[j] &amp;lt; target) { i++; } else if (nums[i] + nums[j] &amp;gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/</guid><description>
Link
public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i &amp;gt;= 0) { while(i &amp;gt;= 0 &amp;amp;&amp;amp; chs[i] != &amp;#39; &amp;#39;) i--; sb.append(s.substring(i + 1, j + 1) + &amp;#34; &amp;#34;); while (i &amp;gt;= 0 &amp;amp;&amp;amp; chs[i] == &amp;#39; &amp;#39;) i--; j = i; } return sb.toString().trim(); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/</guid><description>
Link
public int sumNums(int n) { boolean tmp = n &amp;gt; 1 &amp;amp;&amp;amp; (n += sumNums(n - 1)) &amp;gt; 0; return n; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/</guid><description>
Link
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val &amp;lt; root.val &amp;amp;&amp;amp; q.val &amp;lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val &amp;gt; root.val &amp;amp;&amp;amp; q.val &amp;gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/</guid><description>Link
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;amp;&amp;amp; right != null) { return root; } return left == null ? right : left; } 任意k个数的最近公共祖先
private int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/</guid><description>
Link
public int multiply(int A, int B) { if (B == 0) return 0; else if (B == 1) return A; else return A + multiply(A, B - 1); }</description></item><item><title>LeetCode 994</title><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/994/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/994/</guid><description>一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。 public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue&amp;lt;int[]&amp;gt; Q = new LinkedList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count &amp;gt; 0 &amp;amp;&amp;amp; !</description></item></channel></rss>