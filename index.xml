<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Day Day Up</title><link>https://cs-learning-every-day.github.io/</link><description>Recent content in Introduction on Day Day Up</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://cs-learning-every-day.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://cs-learning-every-day.github.io/docs/book/resource/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/book/resource/</guid><description>相关资源
#
No Starch Press
The Pragmatic Bookshelf
Manning
O&amp;rsquo;Reilly
Let Me Read
Library Genesis
SaltTiger
Zlibrary
Leanpub
The best Programming books</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/book/timeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/book/timeline/</guid><description>读书
#
书籍是人类进步的阶梯
《Java并发编程的艺术》
2021/10/9 P280 ~ P304 2021/10/30 finish 《操作系统导论》
2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 finish 《Build On Your Lisp》
2021/10/12 CH7 2021/10/23 CH10 2021/11/5 finish</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/algo/template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/algo/template/</guid><description>Basic
#
Quick Sort
#
void quick_sort(int q[], int l, int r) { if (l &amp;gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &amp;gt;&amp;gt; 1]; while (i &amp;lt; j) { do i ++ ; while (q[i] &amp;lt; x); do j -- ; while (q[j] &amp;gt; x); if (i &amp;lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort
#
void merge_sort(int q[], int l, int r) { if (l &amp;gt;= r) return; int mid = l + r &amp;gt;&amp;gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= r) if (q[i] &amp;lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &amp;lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &amp;lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &amp;lt;= r; i ++, j ++ ) q[i] = tmp[j]; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</guid><description>11.2 定位问题
#
线上代码定位问题
11.3 性能测试
#
相关的命令</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/206/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/206/</guid><description>public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/21/</guid><description>ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = &amp;amp;dummy; while (p1 &amp;amp;&amp;amp; p2) { if (p1-&amp;gt;val &amp;gt; p2-&amp;gt;val) { cur-&amp;gt;next = p2; p2 = p2-&amp;gt;next; } else { cur-&amp;gt;next = p1; p1 = p1-&amp;gt;next; } cur = cur-&amp;gt;next; } cur-&amp;gt;next = p1 ? p1 : p2; return dummy.next;</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/273/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/273/</guid><description>class Solution { private final String[] LESS_THAN_20 = {&amp;#34;&amp;#34;, &amp;#34;One&amp;#34;, &amp;#34;Two&amp;#34;, &amp;#34;Three&amp;#34;, &amp;#34;Four&amp;#34;, &amp;#34;Five&amp;#34;, &amp;#34;Six&amp;#34;, &amp;#34;Seven&amp;#34;, &amp;#34;Eight&amp;#34;, &amp;#34;Nine&amp;#34;, &amp;#34;Ten&amp;#34;, &amp;#34;Eleven&amp;#34;, &amp;#34;Twelve&amp;#34;, &amp;#34;Thirteen&amp;#34;, &amp;#34;Fourteen&amp;#34;, &amp;#34;Fifteen&amp;#34;, &amp;#34;Sixteen&amp;#34;, &amp;#34;Seventeen&amp;#34;, &amp;#34;Eighteen&amp;#34;, &amp;#34;Nineteen&amp;#34;}; private final String[] TENS = {&amp;#34;&amp;#34;, &amp;#34;Ten&amp;#34;, &amp;#34;Twenty&amp;#34;, &amp;#34;Thirty&amp;#34;, &amp;#34;Forty&amp;#34;, &amp;#34;Fifty&amp;#34;, &amp;#34;Sixty&amp;#34;, &amp;#34;Seventy&amp;#34;, &amp;#34;Eighty&amp;#34;, &amp;#34;Ninety&amp;#34;}; private final String[] THOUSANDS = {&amp;#34;&amp;#34;, &amp;#34;Thousand&amp;#34;, &amp;#34;Million&amp;#34;, &amp;#34;Billion&amp;#34;}; public String numberToWords(int num) { if (num == 0) return &amp;#34;Zero&amp;#34;; int i = 0; String words = &amp;#34;&amp;#34;; while (num &amp;gt; 0) { if (num % 1000 !</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/29/</guid><description>long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a &amp;lt; 0) sign *= -1; if (b &amp;lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a &amp;gt;= b) { long count = 1; long c = b; while ((c &amp;lt;&amp;lt; 1) &amp;lt;= a) { c &amp;lt;&amp;lt;= 1; count &amp;lt;&amp;lt;= 1; } quotient += count; a -= c; } if (sign * quotient &amp;gt; INT_MAX) { return INT_MAX; } return quotient*sign;</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/46/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/46/</guid><description>public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; cur; vector&amp;lt;bool&amp;gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans, vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, vector&amp;lt;int&amp;gt;&amp;amp; cur, vector&amp;lt;bool&amp;gt;&amp;amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i &amp;lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/542/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/542/</guid><description>看成图，0为起点
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; updateMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat) { int m = mat.size(), n = mat[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dist(m, vector&amp;lt;int&amp;gt;(n, -1)); queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Q; for (int i = 0 ; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/77/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/77/</guid><description>public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); dfs(ans, 1, k, n, new ArrayList&amp;lt;&amp;gt;()); return ans; } private void dfs(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans, int start, int k, int n, List&amp;lt;Integer&amp;gt; cur) { if (cur.size() == k) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = start; i &amp;lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/784/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/784/</guid><description>public List&amp;lt;String&amp;gt; letterCasePermutation(String s) { List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List&amp;lt;String&amp;gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); }</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/tips/</guid><description>摩尔投票算法
#
/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/linux/gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/linux/gdb/</guid><description>GCC
#
-E 获取预处理后的文件内容
-V 将编译、链接过程打印
-g 用于GDB调试
ltrace 命令用来跟踪程序运行时调用的库函数
-S 查看系统调用 -e trace=write 只看write系统调用 strace 查看系统调用的封装函数
GDB
#
Segment Fault快速定位
首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core list start ctrl + x + a</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/linux/main/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/linux/main/</guid><description>strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name &amp;ldquo;*.cpp&amp;rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt 输出当前用户是不是 root
[ $UID -eq 0 ] &amp;amp;&amp;amp; echo &amp;quot;is root!&amp;quot; 查看磁盘引导扇区 (Master Boot Record)
cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 - 统计所有 cpp 文件的行数</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/linux/vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/linux/vim/</guid><description> Vscode插件 Learn Vim</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/network/tcp-ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/network/tcp-ip/</guid><description> sudo apt install net-tools
#
ifconfig
netstat -in
tcpdump</description></item><item><title/><link>https://cs-learning-every-day.github.io/docs/cs/programming/rust/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/programming/rust/readme/</guid><description>Cargo
#
cargo new project-name</description></item><item><title>LeetCode 994</title><link>https://cs-learning-every-day.github.io/docs/cs/leetcode/994/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cs-learning-every-day.github.io/docs/cs/leetcode/994/</guid><description>一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。 public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue&amp;lt;int[]&amp;gt; Q = new LinkedList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count &amp;gt; 0 &amp;amp;&amp;amp; !</description></item></channel></rss>