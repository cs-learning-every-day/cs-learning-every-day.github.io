> [Link](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

写的实在是太丑陋了, 太多边界条件不易写

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);
        int i = 0; // 最小>0的数索引
        for (int n : nums) {
            if (n < 0) i++;
            else break;
        }
        int j = i - 1; // 最大负数索引
        int negCount = i;

        int idx = negCount - i;

        while (k > 0) {
            if (negCount > 0) {
                nums[idx] = -nums[idx];
                idx++;
                negCount--;
            } else {
                if (i < nums.length && nums[i] == 0) break;

                if ( i >= nums.length || (j >= 0 && nums[i] > nums[j])) {
                    nums[j] = -nums[j];
                } else {
                    nums[i] = -nums[i];
                }
            }
            k--;
        }

        int sum = 0;
        for (int n : nums) {
            sum += n;
        }
        return sum;
    }
}
```

优先队列解法(最小堆)
```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        PriorityQueue<Integer> q = new PriorityQueue<>();
        for (int n : nums) {
            q.add(n);
        }

        while (k > 0) {
            q.add(0 - q.poll());
            k--;
        }

        int sum = 0;
        while (!q.isEmpty()) {
            sum += q.poll();
        }

        return sum;
    }
}
```

