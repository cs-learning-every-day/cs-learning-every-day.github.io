
暴力：取矩阵的右下角，遍历每个位置O(N^2)，遍历每个长度并求和为O(N^2)，总体为O(N^4)

使用前缀和可以O(1)求出区域和，不必O(N^2)，总体为O(N^2) * O(1) * O(lgN)

```c++
class Solution {
private:
    int m, n;
    int presum[310][310];
public:
    int maxSideLength(vector<vector<int>>& mat, int threshold) {
        m = mat.size(); n = mat[0].size();
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                presum[i][j] = presum[i - 1][j] + presum[i][j - 1] - presum[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }

        int lo = 0, hi = std::min(m, n);
        while (lo < hi) {
            int mid = (hi - lo) / 2 + lo + 1;
            if (check(threshold, mid)) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return lo;
    }

    bool check(int threshold, int width) {
        for (int i = width; i <= m; i++) {
            for (int j = width; j <= n; j++) {
                int sum = presum[i][j] - presum[i][j - width] - presum[i - width][j] + presum[i - width][j - width];
                if (sum <= threshold) return true;
            }
        }
        return false;
    }
};
```