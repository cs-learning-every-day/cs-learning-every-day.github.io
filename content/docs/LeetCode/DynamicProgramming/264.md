> [Link](https://leetcode-cn.com/problems/ugly-number-ii/)

使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]


[1] -> [2 3 5] -> [3 4 5 6 10] -> ...

```java
class Solution {
    // Time Complexity: O(3N * lg3N)
    // 每次产生 最小数的2、3、5倍数
    public int nthUglyNumber(int n) {
        PriorityQueue<Long> q = new PriorityQueue<>();
        q.add(1L);

        long top = -1L;

        for (int i = 0; i < n; i++) {
            top = q.peek();
            while (!q.isEmpty() && q.peek() == top) {
                q.poll();
            }

            q.add(top * 2);
            q.add(top * 3);
            q.add(top * 5);
        }

        return (int)top;
    }
}
```

dp思想，对于任何丑数，它只能由某一个丑数x x*2、x*3、x*5里得到。

定义三个指针i、j、k来定跟踪丑数的大小。

```
nums X X X X X X 
idx2       ^
idx3     ^
idx5 ^
```

```java
class Solution {
    // Time Complexity: O(n);
    public int nthUglyNumber(int n) {
        int i = 0, j = 0, k = 0;
        List<Integer> res = new ArrayList<>();
        res.add(1);

        for (int v = 0; v < n; v++) {
            int cur = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5));
            res.add(cur);
            
            if (cur == res.get(i) * 2) i++;
            if (cur == res.get(j) * 3) j++;
            if (cur == res.get(k) * 5) k++;
        }

        return res.get(n - 1);
    }
}
```