> [Link](https://leetcode-cn.com/problems/word-break/)

遍历字符串，将其分成两部分left和right，判断是否都在wordList里。

加上记忆化
```java
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>(wordDict);
        Map<String, Boolean> map = new HashMap<>();

        return dfs(s, set, map);
    }

    private boolean dfs(String s, Set<String> set, Map<String, Boolean> map) {
        if (map.containsKey(s)) {
            return map.get(s);
        }

        if (set.contains(s)) {
            map.put(s, true);
            return true;
        }

        int n = s.length();
        for (int i = 1; i < n; i++) {
            String left = s.substring(0, i);
            String right =  s.substring(i, n);
            if (set.contains(left) && dfs(right, set, map)) {
                map.put(s, true);
                return true;
            }
        }
        map.put(s, false);
        return false;
    }
```

最佳实践：使用Trie
```java
    public class TreeNode {
        TreeNode[] children;
        boolean isWord;
        char value;

        TreeNode() {
            children = new TreeNode[26];
        }
    }


    private TreeNode root = new TreeNode();

    public boolean wordBreak(String s, List<String> wordDict) {

        for (String word : wordDict) {
            TreeNode node = root;

            for (char c : word.toCharArray()) {
                if (node.children[c - 'a'] == null) {
                    node.children[c - 'a'] = new TreeNode();
                }
                node.children[c - 'a'].value = c;
                node = node.children[c - 'a'];
            }
            node.isWord = true;
        }

        return dfs(s, 0);
    }

    private int[] memo = new int[301];

    private boolean dfs(String s, int cur) { // s[cur:]
        int n = s.length();
        if (cur >= n) return true;
        if (memo[cur] == 1) return false;

        TreeNode node = root;

        for (int i = cur; i < n; i++) {
            TreeNode tmp = node.children[s.charAt(i) - 'a'];
            node = tmp;
            if (tmp != null) {
                if (tmp.isWord && dfs(s, i + 1)) {
                    return true;
                }
            } else {
                break;
            }
        }

        memo[cur] = 1;
        return false;
    }
```