[{"id":0,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"ç›¸å…³èµ„æº\r#\r\r \rNo Starch Press \rThe Pragmatic Bookshelf \rManning \rO\u0026rsquo;Reilly \rLet Me Read \rLibrary Genesis \rSaltTiger \rZlibrary \rLeanpub \rThe best Programming books  "},{"id":1,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"è¯»ä¹¦\r#\r\r ä¹¦ç±æ˜¯äººç±»è¿›æ­¥çš„é˜¶æ¢¯\n ã€ŠJavaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ã€‹\n 2021/10/9 P280 ~ P304 2021/10/30 finish  ã€Šæ“ä½œç³»ç»Ÿå¯¼è®ºã€‹\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40ã€41ã€42 2021/10/18 finish  ã€ŠBuild On Your Lispã€‹\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 finish  "},{"id":2,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  "},{"id":3,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":"Basic\r#\r\rQuick Sort\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } "},{"id":4,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Javaå¹¶å‘ç¼–ç¨‹è‰ºæœ¯","section":"C S","content":"11.2 å®šä½é—®é¢˜\r#\r\rçº¿ä¸Šä»£ç å®šä½é—®é¢˜\n11.3 æ€§èƒ½æµ‹è¯•\r#\r\rç›¸å…³çš„å‘½ä»¤\n"},{"id":5,"href":"/docs/cs/leetcode/206/","title":"206th","section":"C S","content":"public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; } "},{"id":6,"href":"/docs/cs/leetcode/21/","title":"21st","section":"C S","content":"ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = \u0026amp;dummy; while (p1 \u0026amp;\u0026amp; p2) { if (p1-\u0026gt;val \u0026gt; p2-\u0026gt;val) { cur-\u0026gt;next = p2; p2 = p2-\u0026gt;next; } else { cur-\u0026gt;next = p1; p1 = p1-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = p1 ? p1 : p2; return dummy.next; "},{"id":7,"href":"/docs/cs/leetcode/273/","title":"273rd","section":"C S","content":"class Solution { private final String[] LESS_THAN_20 = {\u0026#34;\u0026#34;, \u0026#34;One\u0026#34;, \u0026#34;Two\u0026#34;, \u0026#34;Three\u0026#34;, \u0026#34;Four\u0026#34;, \u0026#34;Five\u0026#34;, \u0026#34;Six\u0026#34;, \u0026#34;Seven\u0026#34;, \u0026#34;Eight\u0026#34;, \u0026#34;Nine\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Eleven\u0026#34;, \u0026#34;Twelve\u0026#34;, \u0026#34;Thirteen\u0026#34;, \u0026#34;Fourteen\u0026#34;, \u0026#34;Fifteen\u0026#34;, \u0026#34;Sixteen\u0026#34;, \u0026#34;Seventeen\u0026#34;, \u0026#34;Eighteen\u0026#34;, \u0026#34;Nineteen\u0026#34;}; private final String[] TENS = {\u0026#34;\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Twenty\u0026#34;, \u0026#34;Thirty\u0026#34;, \u0026#34;Forty\u0026#34;, \u0026#34;Fifty\u0026#34;, \u0026#34;Sixty\u0026#34;, \u0026#34;Seventy\u0026#34;, \u0026#34;Eighty\u0026#34;, \u0026#34;Ninety\u0026#34;}; private final String[] THOUSANDS = {\u0026#34;\u0026#34;, \u0026#34;Thousand\u0026#34;, \u0026#34;Million\u0026#34;, \u0026#34;Billion\u0026#34;}; public String numberToWords(int num) { if (num == 0) return \u0026#34;Zero\u0026#34;; int i = 0; String words = \u0026#34;\u0026#34;; while (num \u0026gt; 0) { if (num % 1000 != 0) words = helper(num % 1000) +THOUSANDS[i] + \u0026#34; \u0026#34; + words; num /= 1000; i++; } return words.trim(); } private String helper(int num) { if (num == 0) return \u0026#34;\u0026#34;; else if (num \u0026lt; 20) return LESS_THAN_20[num] + \u0026#34; \u0026#34;; else if (num \u0026lt; 100) return TENS[num / 10] + \u0026#34; \u0026#34; + helper(num % 10); else return LESS_THAN_20[num / 100] + \u0026#34; Hundred \u0026#34; + helper(num % 100); } } "},{"id":8,"href":"/docs/cs/leetcode/29/","title":"29th","section":"C S","content":"long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a \u0026lt; 0) sign *= -1; if (b \u0026lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a \u0026gt;= b) { long count = 1; long c = b; while ((c \u0026lt;\u0026lt; 1) \u0026lt;= a) { c \u0026lt;\u0026lt;= 1; count \u0026lt;\u0026lt;= 1; } quotient += count; a -= c; } if (sign * quotient \u0026gt; INT_MAX) { return INT_MAX; } return quotient*sign; "},{"id":9,"href":"/docs/cs/leetcode/46/","title":"46th","section":"C S","content":"public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;bool\u0026gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, vector\u0026lt;int\u0026gt;\u0026amp; cur, vector\u0026lt;bool\u0026gt;\u0026amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } } "},{"id":10,"href":"/docs/cs/leetcode/542/","title":"542nd","section":"C S","content":" çœ‹æˆå›¾ï¼Œ0ä¸ºèµ·ç‚¹\n vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; updateMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat) { int m = mat.size(), n = mat[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(m, vector\u0026lt;int\u0026gt;(n, -1)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (int i = 0 ; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!Q.empty()) { pair\u0026lt;int, int\u0026gt; node = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { pair\u0026lt;int, int\u0026gt; neighbor = {node.first + dx[i], node.second + dy[i]}; if (neighbor.first \u0026lt; 0 || neighbor.first \u0026gt;= m || neighbor.second \u0026lt; 0 || neighbor.second \u0026gt;= n || dist[neighbor.first][neighbor.second] != -1) continue; dist[neighbor.first][neighbor.second] = dist[node.first][node.second] + 1; Q.push(neighbor); } } return dist; } "},{"id":11,"href":"/docs/cs/leetcode/77/","title":"77th","section":"C S","content":"public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(ans, 1, k, n, new ArrayList\u0026lt;\u0026gt;()); return ans; } private void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans, int start, int k, int n, List\u0026lt;Integer\u0026gt; cur) { if (cur.size() == k) { ans.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = start; i \u0026lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } } "},{"id":12,"href":"/docs/cs/leetcode/784/","title":"784th","section":"C S","content":"public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List\u0026lt;String\u0026gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); } "},{"id":13,"href":"/docs/cs/leetcode/tips/","title":"Tips","section":"C S","content":"æ‘©å°”æŠ•ç¥¨ç®—æ³•\r#\r\r/* å¯¹äºnä¸ªå…ƒç´ ï¼Œè¶…è¿‡n/2çš„æ¬¡æ•°æœ€å¤šåªæœ‰ä¸€ä¸ªå…ƒç´ ã€‚åŒç†è¶…è¿‡n/3çš„æ¬¡æ•°æœ€å¤šåªæœ‰äºŒä¸ªå…ƒç´ ã€‚é€‰ä¸€ä¸ªcandidateï¼Œæ ‡è®°ä¸º1ï¼Œæ¯æ¬¡ä¸ä¸€æ ·æ ‡è®°å‡1ã€‚æ ‡è®°ä¸º0æ—¶ï¼Œå°†å½“å‰å…ƒç´ è®¾ä¸ºcandidateä¸”æ ‡è®°ä¸º1ã€‚(ç›¸å½“äºæ¶ˆé™¤ä¸ä¸€æ ·çš„å…ƒç´ )ï¼Œæœ€åéœ€è¦ç¡®å®šæ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚ */ "},{"id":14,"href":"/docs/cs/linux/gdb/","title":"G D B","section":"C S","content":"GCC\r#\r\r  -E è·å–é¢„å¤„ç†åçš„æ–‡ä»¶å†…å®¹\n  -V å°†ç¼–è¯‘ã€é“¾æ¥è¿‡ç¨‹æ‰“å°\n  -g ç”¨äºGDBè°ƒè¯•\n  ltrace å‘½ä»¤ç”¨æ¥è·Ÿè¸ªç¨‹åºè¿è¡Œæ—¶è°ƒç”¨çš„åº“å‡½æ•°\n -S æŸ¥çœ‹ç³»ç»Ÿè°ƒç”¨ -e trace=write åªçœ‹writeç³»ç»Ÿè°ƒç”¨  strace æŸ¥çœ‹ç³»ç»Ÿè°ƒç”¨çš„å°è£…å‡½æ•°\nGDB\r#\r\rSegment Faultå¿«é€Ÿå®šä½\né¦–å…ˆç”Ÿæˆcoreæ–‡ä»¶ ä½¿ç”¨ulimit -a æŸ¥çœ‹core file sizeä¸º0åˆ™æ˜¯ä¸ä¼šè¾“å‡º(æ”¹æˆä¸é™åˆ¶ ulimit -c unlimited) è¿è¡Œç¨‹åºå‡ºé”™åˆ™ä¼šè¾“å‡ºï¼Œè°ƒè¯•æ—¶gdb ./hello core  list start ctrl + x + a  "},{"id":15,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace è·Ÿè¸ªç³»ç»Ÿè°ƒç”¨ stat æ‰“å°æ–‡ä»¶ä¿¡æ¯ mount æŸ¥çœ‹æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿ grep telnet /etc/services åŒ…å«äº†ä¸€äº›ç†ŸçŸ¥çš„ç«¯å£å· ldd proc åˆ—å‡ºç¨‹åºçš„åŠ¨æ€ä¾èµ–æ€§ ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt  è¾“å‡ºå½“å‰ç”¨æˆ·æ˜¯ä¸æ˜¯ root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  æŸ¥çœ‹ç£ç›˜å¼•å¯¼æ‰‡åŒº (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  ç»Ÿè®¡æ‰€æœ‰ cpp æ–‡ä»¶çš„è¡Œæ•°\n find . | grep '\\.cpp$' | xargs cat | wc -l  ç»Ÿè®¡å‘½ä»¤è¡Œå‘½ä»¤çš„é¢‘ç‡\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  æ–‡ä»¶ç®¡ç† - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  æ–‡ä»¶æ£€ç´¢ - cat, more, less, head, tail, file, find\n  è¾“å…¥è¾“å‡ºæ§åˆ¶ - é‡å®šå‘, ç®¡é“, tee, xargs\n  æ–‡æœ¬å¤„ç† - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  æ­£åˆ™è¡¨è¾¾å¼\n  ç³»ç»Ÿç›‘æ§ - jobs, ps, top, kill, free, demsg, lsof\n   å¦‚ä½•æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶æ˜¯å¦å®Œå…¨ç›¸åŒ?   diff or md5sum\n  å¦‚ä½•åˆ—å‡ºä¸€ä¸ªCè¯­è¨€é¡¹ç›®ä¸­æ‰€æœ‰è¢«åŒ…å«è¿‡çš„å¤´æ–‡ä»¶?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n p@ssw0rd\n"},{"id":16,"href":"/docs/cs/linux/vim/","title":"Vim","section":"C S","content":" Vscodeæ’ä»¶ Learn Vim  "},{"id":17,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"C S","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":18,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"C S","content":"Cargo\r#\r\r cargo new project-name  "},{"id":19,"href":"/docs/cs/referrals/","title":"Referrals","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \rğŸ“š List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCSå…¬å¼€è¯¾ç¨‹å­¦ä¹ ç¾¤è¯¾ç¨‹æ¨è \rå…‹è±ç™»å¤§å­¦CS(çƒ­å¿ƒç½‘å‹æ•´ç†) \rğŸ“ Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos  "},{"id":20,"href":"/docs/cs/leetcode/994/","title":"LeetCode 994","section":"C S","content":" ä¸€å¼€å§‹ï¼Œæˆ‘ä»¬æ‰¾å‡ºæ‰€æœ‰è…çƒ‚çš„æ©˜å­ï¼Œå°†å®ƒä»¬æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸ºç¬¬ 0 å±‚çš„ç»“ç‚¹ã€‚ ç„¶åè¿›è¡Œ BFS éå†ï¼Œæ¯ä¸ªç»“ç‚¹çš„ç›¸é‚»ç»“ç‚¹å¯èƒ½æ˜¯ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘çš„ç»“ç‚¹ï¼Œæ³¨æ„åˆ¤æ–­ç»“ç‚¹ä½äºç½‘æ ¼è¾¹ç•Œçš„ç‰¹æ®Šæƒ…å†µã€‚ ç”±äºå¯èƒ½å­˜åœ¨æ— æ³•è¢«æ±¡æŸ“çš„æ©˜å­ï¼Œæˆ‘ä»¬éœ€è¦è®°å½•æ–°é²œæ©˜å­çš„æ•°é‡ã€‚åœ¨ BFS ä¸­ï¼Œæ¯éå†åˆ°ä¸€ä¸ªæ©˜å­ï¼ˆæ±¡æŸ“äº†ä¸€ä¸ªæ©˜å­ï¼‰ï¼Œå°±å°†æ–°é²œæ©˜å­çš„æ•°é‡å‡ä¸€ã€‚å¦‚æœ BFS ç»“æŸåè¿™ä¸ªæ•°é‡ä»æœªå‡ä¸ºé›¶ï¼Œè¯´æ˜å­˜åœ¨æ— æ³•è¢«æ±¡æŸ“çš„æ©˜å­ã€‚  public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue\u0026lt;int[]\u0026gt; Q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count \u0026gt; 0 \u0026amp;\u0026amp; !Q.isEmpty()) { times++; int curSize = Q.size(); for (int j = 0; j \u0026lt; curSize; j ++) { int[] node = Q.poll(); for (int i = 0; i \u0026lt; 4; i++) { int[] neighbor = new int[]{node[0] + dir[i][0], node[1] + dir[i][1]}; if (neighbor[0] \u0026lt; 0 || neighbor[1] \u0026lt; 0 || neighbor[0] \u0026gt;= m || neighbor[1] \u0026gt;= n || grid[neighbor[0]][neighbor[1]] != 1) continue; grid[neighbor[0]][neighbor[1]] = 2; fresh_count--; Q.add(neighbor); } } } return fresh_count != 0 ? -1 : times; } "}]