[{"id":0,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"相关资源\r#\r\r \rNo Starch Press \rThe Pragmatic Bookshelf \rManning \rO\u0026rsquo;Reilly \rLet Me Read \rLibrary Genesis \rSaltTiger \rZlibrary \rLeanpub \rThe best Programming books  "},{"id":1,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"读书\r#\r\r 书籍是人类进步的阶梯\n 《Java并发编程的艺术》\n 2021/10/9 P280 ~ P304 2021/10/30 finish  《操作系统导论》\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 finish  《Build On Your Lisp》\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 finish  "},{"id":2,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  "},{"id":3,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":"Basic\r#\r\rQuick Sort\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } Merge Sort\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } "},{"id":4,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Java并发编程艺术","section":"C S","content":"11.2 定位问题\r#\r\r线上代码定位问题\n11.3 性能测试\r#\r\r相关的命令\n"},{"id":5,"href":"/docs/cs/leetcode/206/","title":"206th","section":"C S","content":"public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode prev = null, cur = head, next = head.next; while (cur != null) { next = cur.next; cur.next = prev; prev = cur; cur = next; } return prev; } "},{"id":6,"href":"/docs/cs/leetcode/21/","title":"21st","section":"C S","content":"ListNode dummy; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* cur = \u0026amp;dummy; while (p1 \u0026amp;\u0026amp; p2) { if (p1-\u0026gt;val \u0026gt; p2-\u0026gt;val) { cur-\u0026gt;next = p2; p2 = p2-\u0026gt;next; } else { cur-\u0026gt;next = p1; p1 = p1-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = p1 ? p1 : p2; return dummy.next; "},{"id":7,"href":"/docs/cs/leetcode/273/","title":"273rd","section":"C S","content":"class Solution { private final String[] LESS_THAN_20 = {\u0026#34;\u0026#34;, \u0026#34;One\u0026#34;, \u0026#34;Two\u0026#34;, \u0026#34;Three\u0026#34;, \u0026#34;Four\u0026#34;, \u0026#34;Five\u0026#34;, \u0026#34;Six\u0026#34;, \u0026#34;Seven\u0026#34;, \u0026#34;Eight\u0026#34;, \u0026#34;Nine\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Eleven\u0026#34;, \u0026#34;Twelve\u0026#34;, \u0026#34;Thirteen\u0026#34;, \u0026#34;Fourteen\u0026#34;, \u0026#34;Fifteen\u0026#34;, \u0026#34;Sixteen\u0026#34;, \u0026#34;Seventeen\u0026#34;, \u0026#34;Eighteen\u0026#34;, \u0026#34;Nineteen\u0026#34;}; private final String[] TENS = {\u0026#34;\u0026#34;, \u0026#34;Ten\u0026#34;, \u0026#34;Twenty\u0026#34;, \u0026#34;Thirty\u0026#34;, \u0026#34;Forty\u0026#34;, \u0026#34;Fifty\u0026#34;, \u0026#34;Sixty\u0026#34;, \u0026#34;Seventy\u0026#34;, \u0026#34;Eighty\u0026#34;, \u0026#34;Ninety\u0026#34;}; private final String[] THOUSANDS = {\u0026#34;\u0026#34;, \u0026#34;Thousand\u0026#34;, \u0026#34;Million\u0026#34;, \u0026#34;Billion\u0026#34;}; public String numberToWords(int num) { if (num == 0) return \u0026#34;Zero\u0026#34;; int i = 0; String words = \u0026#34;\u0026#34;; while (num \u0026gt; 0) { if (num % 1000 != 0) words = helper(num % 1000) +THOUSANDS[i] + \u0026#34; \u0026#34; + words; num /= 1000; i++; } return words.trim(); } private String helper(int num) { if (num == 0) return \u0026#34;\u0026#34;; else if (num \u0026lt; 20) return LESS_THAN_20[num] + \u0026#34; \u0026#34;; else if (num \u0026lt; 100) return TENS[num / 10] + \u0026#34; \u0026#34; + helper(num % 10); else return LESS_THAN_20[num / 100] + \u0026#34; Hundred \u0026#34; + helper(num % 100); } } "},{"id":8,"href":"/docs/cs/leetcode/29/","title":"29th","section":"C S","content":"long a = (long)dividend; long b = (long)divisor; long sign = 1; if (a \u0026lt; 0) sign *= -1; if (b \u0026lt; 0) sign *= -1; a = abs(a); b = abs(b); long quotient = 0; while (a \u0026gt;= b) { long count = 1; long c = b; while ((c \u0026lt;\u0026lt; 1) \u0026lt;= a) { c \u0026lt;\u0026lt;= 1; count \u0026lt;\u0026lt;= 1; } quotient += count; a -= c; } if (sign * quotient \u0026gt; INT_MAX) { return INT_MAX; } return quotient*sign; "},{"id":9,"href":"/docs/cs/leetcode/46/","title":"46th","section":"C S","content":"public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;bool\u0026gt; used(nums.size(), false); dfs(ans, nums, 0, cur, used); return ans; } private: void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, vector\u0026lt;int\u0026gt;\u0026amp; cur, vector\u0026lt;bool\u0026gt;\u0026amp; used) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { if (used[i]) continue; used[i] = true; cur.push_back(nums[i]); dfs(ans, nums, i + 1, cur, used); cur.pop_back(); used[i] = false; } } "},{"id":10,"href":"/docs/cs/leetcode/542/","title":"542nd","section":"C S","content":" 看成图，0为起点\n vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; updateMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat) { int m = mat.size(), n = mat[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(m, vector\u0026lt;int\u0026gt;(n, -1)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (int i = 0 ; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) { dist[i][j] = 0; Q.push({i, j}); } } } const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, 1, -1}; while (!Q.empty()) { pair\u0026lt;int, int\u0026gt; node = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { pair\u0026lt;int, int\u0026gt; neighbor = {node.first + dx[i], node.second + dy[i]}; if (neighbor.first \u0026lt; 0 || neighbor.first \u0026gt;= m || neighbor.second \u0026lt; 0 || neighbor.second \u0026gt;= n || dist[neighbor.first][neighbor.second] != -1) continue; dist[neighbor.first][neighbor.second] = dist[node.first][node.second] + 1; Q.push(neighbor); } } return dist; } "},{"id":11,"href":"/docs/cs/leetcode/77/","title":"77th","section":"C S","content":"public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(ans, 1, k, n, new ArrayList\u0026lt;\u0026gt;()); return ans; } private void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans, int start, int k, int n, List\u0026lt;Integer\u0026gt; cur) { if (cur.size() == k) { ans.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = start; i \u0026lt;= n; i++) { cur.add(i); dfs(ans, i + 1, k, n, cur); cur.remove(cur.size() - 1); } } "},{"id":12,"href":"/docs/cs/leetcode/784/","title":"784th","section":"C S","content":"public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] chs, int i, List\u0026lt;String\u0026gt; ans) { if (i == chs.length) { ans.add(new String(chs)); return; } chs[i] = Character.toLowerCase(chs[i]); dfs(chs, i + 1, ans); if (Character.isDigit(chs[i])) return; chs[i] = Character.toUpperCase(chs[i]); dfs(chs, i + 1, ans); } "},{"id":13,"href":"/docs/cs/leetcode/tips/","title":"Tips","section":"C S","content":"摩尔投票算法\r#\r\r/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */ "},{"id":14,"href":"/docs/cs/linux/gdb/","title":"G D B","section":"C S","content":"GCC\r#\r\r  -E 获取预处理后的文件内容\n  -V 将编译、链接过程打印\n  -g 用于GDB调试\n  ltrace 命令用来跟踪程序运行时调用的库函数\n -S 查看系统调用 -e trace=write 只看write系统调用  strace 查看系统调用的封装函数\nGDB\r#\r\rSegment Fault快速定位\n首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core  list start ctrl + x + a  "},{"id":15,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt  输出当前用户是不是 root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  查看磁盘引导扇区 (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  统计所有 cpp 文件的行数\n find . | grep '\\.cpp$' | xargs cat | wc -l  统计命令行命令的频率\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  文件检索 - cat, more, less, head, tail, file, find\n  输入输出控制 - 重定向, 管道, tee, xargs\n  文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  正则表达式\n  系统监控 - jobs, ps, top, kill, free, demsg, lsof\n   如何比较两个文件是否完全相同?   diff or md5sum\n  如何列出一个C语言项目中所有被包含过的头文件?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n p@ssw0rd\n"},{"id":16,"href":"/docs/cs/linux/vim/","title":"Vim","section":"C S","content":" Vscode插件 Learn Vim  "},{"id":17,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"C S","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":18,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"C S","content":"Cargo\r#\r\r cargo new project-name  "},{"id":19,"href":"/docs/cs/referrals/","title":"Referrals","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \r📚 List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCS公开课程学习群课程推荐 \r克莱登大学CS(热心网友整理) \r🎓 Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos  "},{"id":20,"href":"/docs/cs/leetcode/994/","title":"LeetCode 994","section":"C S","content":" 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。  public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; int fresh_count = 0; Queue\u0026lt;int[]\u0026gt; Q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 1) { fresh_count++; } else if (grid[i][j] == 2) { Q.add(new int[]{i, j}); } } } int times = 0; final int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}}; while (fresh_count \u0026gt; 0 \u0026amp;\u0026amp; !Q.isEmpty()) { times++; int curSize = Q.size(); for (int j = 0; j \u0026lt; curSize; j ++) { int[] node = Q.poll(); for (int i = 0; i \u0026lt; 4; i++) { int[] neighbor = new int[]{node[0] + dir[i][0], node[1] + dir[i][1]}; if (neighbor[0] \u0026lt; 0 || neighbor[1] \u0026lt; 0 || neighbor[0] \u0026gt;= m || neighbor[1] \u0026gt;= n || grid[neighbor[0]][neighbor[1]] != 1) continue; grid[neighbor[0]][neighbor[1]] = 2; fresh_count--; Q.add(neighbor); } } } return fresh_count != 0 ? -1 : times; } "}]