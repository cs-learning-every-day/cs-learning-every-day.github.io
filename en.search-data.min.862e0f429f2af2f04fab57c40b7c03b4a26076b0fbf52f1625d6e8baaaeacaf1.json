[{"id":0,"href":"/docs/acwing/","title":"Acwing","section":"Docs","content":" \r786. 第k个数 \r788. 求逆序对的个数 \r790. 数的三次方根 \r791. 高精度加法 \r792. 高精度减法 \r793. 高精度乘法 \r794. 高精度除法 \r795. 前缀和 \r796. 子矩阵的和 \r797. 差分 \r798. 差分矩阵 \r799. 最长连续不重复子序列 \r801. 二进制中1的个数 \r802. 区间和 \r803. 区间合并 \r826. 单链表 \r827. 双链表 \r830. 单调栈 \r154. 滑动窗口 \r831. KMP字符串 \r835. Trie字符串统计 \r143. 最大异或对 \r836. 合并集合 \r838. 堆排序 \r840. 模拟散列表  "},{"id":1,"href":"/docs/acwing/basic/143/","title":"143rd","section":"Acwing","content":" \rLink\n "},{"id":2,"href":"/docs/acwing/basic/154/","title":"154th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n, k; int a[N], q[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i++) { // 判断并更新窗口  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; q[++tt] = i; if (i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i++) { // 判断并更新窗口  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt--; q[++tt] = i; if (i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } "},{"id":3,"href":"/docs/acwing/basic/786/","title":"786th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int q[100001]; int quick_sort(int l, int r, int k) { if (l == r) { return q[l]; } int x = q[l], i = l - 1, j = r + 1; while (i \u0026lt; j) { while (q[++i] \u0026lt; x); while (q[--j] \u0026gt; x); if (i \u0026lt; j) { swap(q[i], q[j]); } } int sl = j - l + 1; if (k \u0026lt;= sl) return quick_sort(l, j, k); return quick_sort(j + 1, r, k - sl); } int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; q[i]; } cout \u0026lt;\u0026lt; quick_sort(0, n - 1, k); return 0; } "},{"id":4,"href":"/docs/acwing/basic/788/","title":"788th","section":"Acwing","content":" \rLink\n class Solution { private int[] tmp; public int reversePairs(int[] nums) { tmp = new int[nums.length]; return mergeSort(nums, 0, nums.length - 1); } private int mergeSort(int[] nums, int l, int r) { if (l \u0026gt;= r) { return 0; } int mid = (l + r) \u0026gt;\u0026gt; 1; int res = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r); // 归并  int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (nums[i] \u0026lt;= nums[j]) { tmp[k++] = nums[i++]; } else { tmp[k++] = nums[j++]; res += (mid - i + 1); } } while (i \u0026lt;= mid) { tmp[k++] = nums[i++]; } while (j \u0026lt;= r) { tmp[k++] = nums[j++]; } for (i = l, j = 0; i \u0026lt;= r; i++, j++) { nums[i] = tmp[j]; } return res; } } "},{"id":5,"href":"/docs/acwing/basic/790/","title":"790th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int main() { double x; cin \u0026gt;\u0026gt; x; double l = -1e4, r = 1e4; while (r - l \u0026gt; 1e-8) { double m = (l + r) / 2; if (m * m * m \u0026gt;= x) { r = m; } else { l = m; } } printf(\u0026#34;%.6lf\u0026#34;, r); return 0; } "},{"id":6,"href":"/docs/acwing/basic/791/","title":"791st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e6 + 10; vecotr\u0026lt;int\u0026gt; add(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i++) { if (i \u0026lt; A.size()) { t += A[i]; } if (i \u0026lt; B.size()) { t += B[i]; } C.push_back(t % 10); t /= 10; } if (t) { C.push_back(1); } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } auto C = add(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":7,"href":"/docs/acwing/basic/792/","title":"792nd","section":"Acwing","content":"两个正整数相减 A - B 考虑A \u0026lt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = -(|A| + |B|) 考虑A \u0026gt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = |A| + |B|\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; // 判断A\u0026gt;=B bool cmp(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() != B.size()) { return A.size() \u0026gt; B.size(); } for (int i = A.size() - 1; i \u0026gt;= 0; i--) { if (A[i] != B[i]) { return A[i] \u0026gt; B[i]; } } // 去掉前导0  while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return true; } vecotr\u0026lt;int\u0026gt; sub(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vecotr\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i++) { t = A[i] - t; if (i \u0026lt; B.size()) { t -= B[i]; } c.push_back((t + 10) % 10); if (t \u0026lt; 0) { t = 1; } else { t = 0; } } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B, C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } if (cmp(A, B)) { C = sub(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } else { C = sub(B, A); printf(\u0026#34;-\u0026#34;); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } return 0; } "},{"id":8,"href":"/docs/acwing/basic/793/","title":"793rd","section":"Acwing","content":"两个正整数相乘 大*小\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; mul(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b) { vecotr\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t != 0; i++) { if (i \u0026lt; A.size()) { t += A[i] * b; } C.push_back(t % 10); t /= 10; } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A, vector\u0026lt;int\u0026gt; C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } C = mul(A, b); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":9,"href":"/docs/acwing/basic/794/","title":"794th","section":"Acwing","content":"两个正整数相除 大/小\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; div(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vecotr\u0026lt;int\u0026gt; C; int t = 0; r = 0; for (int i = A.size(); i \u0026gt;= 0; i--) { r = r * 10 + A[i]; C.push_back(r / b); r = r % b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A, vector\u0026lt;int\u0026gt; C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } int r; C = div(A, b, r); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } "},{"id":10,"href":"/docs/acwing/basic/795/","title":"795th","section":"Acwing","content":"\rS[i] = a[1] + a[2] + ... a[i]\ra[l] + ... + a[r] = S[r] - S[l - 1]\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], s[N]; int main() { a[0] = 0; s[0] = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { s[i] = s[i - 1] + a[i]; } while (m--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;r, \u0026amp;l); printf(\u0026#34;%d\\n\u0026#34;, s[r] - s[l - 1]); } return 0; } "},{"id":11,"href":"/docs/acwing/basic/796/","title":"796th","section":"Acwing","content":"\rS[i, j] = 第i行j列格子左上部分所有元素的和\r以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\rS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\r#include \u0026lt;iostream\u0026gt; const int N = 1010; int n, m, q; int a[N][N], s[N][N]; int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } } while (q--) { int x1, y1, x2, y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); printf(\u0026#34;%d\\n\u0026#34;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 -1] + s[x1 - 1][y1 -1]); } return 0; } "},{"id":12,"href":"/docs/acwing/basic/797/","title":"797th","section":"Acwing","content":"\r给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { insert(i, i, a[i]); } while (m--) { int l, r, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;c); insert(l, r, c); } for (int i = 1; i \u0026lt;= n; i++) { b[i] += b[i - 1]; } for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;%d \u0026#34;, b[i]); } return 0; } "},{"id":13,"href":"/docs/acwing/basic/798/","title":"798th","section":"Acwing","content":"\r给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\rS[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 1010; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { insert(i, j, i, j, a[i][j]); } } while (q--) { int x1, y1, x2, y2, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;c); insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { printf(\u0026#34;%d \u0026#34;, b[i][j]); } puts(\u0026#34;\u0026#34;); } return 0; } "},{"id":14,"href":"/docs/acwing/basic/799/","title":"799th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; int a[100010]; int s[100010]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int maxLen = 0; for (int i = 0, j = 0; i \u0026lt; n; i++) { s[a[i]]++; while (s[a[i]] \u0026gt; 1) { s[a[j]]--; j++; } if ((i - j + 1) \u0026gt; maxLen) { maxLen = i - j + 1; } } cout \u0026lt;\u0026lt; maxLen \u0026lt;\u0026lt; endl; return 0; } "},{"id":15,"href":"/docs/acwing/basic/801/","title":"801st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int lowbit(int x) { return x \u0026amp; -x; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n--) { int x; cin \u0026gt;\u0026gt; x; int cnt = 0; while (x != 0) { x -= lowbit(x); cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":16,"href":"/docs/acwing/basic/802/","title":"802nd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n, m; int a[N], s[N]; vector\u0026lt;int\u0026gt; alls; vector\u0026lt;PII\u0026gt; add, query; // 将x映射到索引为(1--alls.size())的数 int find(int x) { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x); } for (int i = 0; i \u0026lt; m; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // 去重  sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 处理插入  for (auto item : add) { int x = find(item.first); a[x] += item.second; } // 预处理前缀和  for (int i = 1; i \u0026lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; // 处理查询  for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } } "},{"id":17,"href":"/docs/acwing/basic/803/","title":"803rd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 100010; void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) { if (ed \u0026lt; seg.first) { if (ed != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else { ed = max(ed, seg.second); } } if (st != -2e9) res.push_back({st, ed}); segs = res; } int main() { int n; vector\u0026lt;PII\u0026gt; segs; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; segs.push_back({l, r}); } merge(segs); cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl; return 0; } "},{"id":18,"href":"/docs/acwing/basic/826/","title":"826th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } void add_to_head(int x) { e[idx] = x; ne[idx] = head; head = idx; idx++; } // 将x插入到下标是k的点面 void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++; } // 将下标是k的点后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while (m--) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if (op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (!k) head = ne[head]; remove(k - 1); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":19,"href":"/docs/acwing/basic/827/","title":"827th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int idx, e[N], l[N], r[N]; void init() { // 0表示head 1表示tail  r[0] = 1, l[1] = 0; idx = 2; } // 在下标为k的右边插入 void add(int k, int x) { e[idx] = x; l[idx] = k; r[idx] = r[k]; l[r[k]] = idx; r[k] = idx; idx++; } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { int n; cin \u0026gt;\u0026gt; n; init(); while (n--) { string op; cin \u0026gt;\u0026gt; op; int k, a; if (op == \u0026#34;R\u0026#34;) { cin \u0026gt;\u0026gt; a; add(l[1], a); } else if (op == \u0026#34;L\u0026#34;) { cin \u0026gt;\u0026gt; a; add(0, a); } else if (op == \u0026#34;D\u0026#34;) { cin \u0026gt;\u0026gt; k; remove(k + 1); } else if (op == \u0026#34;IL\u0026#34;) { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a; add(l[k + 1], a); } else if (op == \u0026#34;IR\u0026#34;) { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a; add(k + 1, a); } } for (int i = r[0]; i != 1; i = r[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":20,"href":"/docs/acwing/basic/830/","title":"830th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; const int N = 100010; int n; int stk[N], tt; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; while (tt \u0026amp;\u0026amp; skt[tt] \u0026gt;= x) tt--; if (tt) { cout \u0026lt;\u0026lt; skt[tt] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } skt[++tt] = x; } return 0; } "},{"id":21,"href":"/docs/acwing/basic/831/","title":"831st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 10010, M = 10010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; for (int i = 2, j = 0; i \u0026lt;= n; i++) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } for (int i = 1, j = 0; i \u0026lt;= m; i++) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == n) { cout \u0026lt;\u0026lt; i - n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; j = ne[j]; } } return 0; } "},{"id":22,"href":"/docs/acwing/basic/835/","title":"835th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; // idx=0 为根, cnt[n]:以n为结尾的数量 int son[N][26], cnt[N], idx; char str[N]; void insert(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p]++; } int query(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n--) { char op[2]; scanf(\u0026#34;%s%s\u0026#34;, op, str); if (op[0] == \u0026#39;I\u0026#39;) insert(str); else printf(\u0026#34;%d\\n\u0026#34;, query(str)); } return 0; } "},{"id":23,"href":"/docs/acwing/basic/836/","title":"836th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int p[N]; int n, m; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) p[i] = i; while (m--) { char op[2]; int a, b; scanf(\u0026#34;%s%d%d\u0026#34;, op, \u0026amp;a, \u0026amp;b); if (op[0] == \u0026#39;M\u0026#39;) { p[find(a)] = find(b); } else { if (find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } "},{"id":24,"href":"/docs/acwing/basic/837/","title":"837th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int p[N], sz[N]; int n, m; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { p[i] = i; sz[i] = 1; } while (m--) { char op[5]; int a, b; scanf(\u0026#34;%s\u0026#34;, op); if (op[0] == \u0026#39;C\u0026#39;) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (find(a) == find(b)) continue; sz[find(b)] += sz[find(a)]; p[find(a)] = find(b); } else if (op[1] == \u0026#39;1\u0026#39;) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } else { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;, sz[find(a)]); } } return 0; } "},{"id":25,"href":"/docs/acwing/basic/838/","title":"838th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], sz; void down(int u) { int t = u; if (u * 2 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (t != u) { swap(h[t], h[u]); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u / 2] \u0026gt; h[u]) { swap(h[u], h[u / 2]); u /= 2; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; h[i]; } sz = n; for (int i = n / 2; i; i--) { down(i); } while (m --) { cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; h[1] = h[sz]; sz -= 1; down(1); } return 0; } "},{"id":26,"href":"/docs/acwing/basic/839/","title":"839th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string.h\u0026gt; using namespace std; const int N = 100010; int h[N], ph[N], hp[N], sz; void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (t != u) { heap_swap(t, u); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u / 2] \u0026gt; h[u]) { heap_swap(u, u / 2); u /= 2; } } int main() { int n, m = 0; cin \u0026gt;\u0026gt; n; while (n--) { char op[10]; scanf(\u0026#34;%s\u0026#34;, op); int k, x; if (!strcmp(op, \u0026#34;I\u0026#34;)) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); m++; sz++; ph[m] = sz, hp[sz] = m; h[sz] = x; up(sz); } else if (!strcmp(op, \u0026#34;PM\u0026#34;)) { printf(\u0026#34;%d\\n\u0026#34;, h[1]); } else if (!strcmp(op, \u0026#34;DM\u0026#34;)) { heap_swap(1, sz); sz--; down(1); } else if (!strcmp(op, \u0026#34;D\u0026#34;)) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); k = ph[k]; heap_swap(k, sz); sz--; down(k), up(k); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;k, \u0026amp;x); k = ph[k]; h[k] = x; down(k), up(k); } } return 0; } "},{"id":27,"href":"/docs/acwing/basic/840/","title":"840th","section":"Acwing","content":"\r开放寻址法\r#\r\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 2000003, null = 0x3f3f3f3f; int h[N]; bool find(int x) { int k = (x % N + N) % N; while (h[k] != null \u0026amp;\u0026amp; h[k] != x) { k++; if (k == N) k = 0; } return k; } int main() { int n; cin \u0026gt;\u0026gt; n; memset(h, 0x3f, sizeof(h)); while (n--) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); int k = find(x); if (*op == \u0026#39;I\u0026#39;) h[k] = x; else { if (h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 拉链法\r#\r\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000003; int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx; idx++; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } int main() { int n; cin \u0026gt;\u0026gt; n; memset(h, -1, sizeof(h)); while (n--) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) insert(x); else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } "},{"id":28,"href":"/docs/acwing/basic/841/","title":"841st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main() { scanf(\u0026#34;%d%d%s\u0026#34;, \u0026amp;n, \u0026amp;m, str + 1); p[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while (m--) { int l1, r1, l2, r2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;l1, \u0026amp;r1, \u0026amp;l2, \u0026amp;r2); if (get(l1, r1) == get(l2, r2)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } return 0; } "},{"id":29,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"相关资源\r#\r\r  \r藏经阁\n  \rNo Starch Press\n  \rThe Pragmatic Bookshelf\n  \rManning\n  \rO\u0026rsquo;Reilly\n  \rLet Me Read\n  \rLibrary Genesis\n  \rSaltTiger 目前我主要在以下网站收集编程类电子书，大家去这上面找书就好，下载方法也一并给出：\n  \rCoderProg，点击验证码，跳转至Rapidgator或Turbobit网盘，将网盘链接复制到\r木薯牛网盘中转站（1G流量1.33元）进行中转，即可下载。\n  \rAvaxHome，跳转至icerbox网盘，将网盘链接复制到\r思飞网盘中转站（1G icerbox流量2.8元）进行中转，中转后自动转存到绑定的百度网盘，即可下载。\n  \rFox eBook，跳转至NitroFlare网盘，将网盘链接复制到\r木薯牛网盘中转站进行中转，即可下载。\n  \rLibrary Genesis，点击Mirrors链接直接下载。\n  \rLet Me Read，点击验证码，跳转DirectLink直接下载。\n    \rZlibrary\n  \rLeanpub\n  \rThe best Programming books\n  "},{"id":30,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"读书\r#\r\r 书籍是人类进步的阶梯。\n  温故而知新,可以为师矣。\n 《现代 C++ 教程》\n 2022/3/7 Ch1 ~ Ch2 2022/3/8 Finish  《算法导论》\n 2022/1/24 Ch1 2022/1/26 Ch2 ~ Ch4 2022/2/10 Ch6 ~ Ch14  《精通Spring 4.x 企业应用开发实战》\n Todo 18、19、20  《Java性能权威指南》\n 2021/12/16 Ch1 2022/2/6 Ch2~Ch4  《自己动手写Java虚拟机》\n 2021/12/21 Ch1 2021/12/23 Ch2 2021/12/31 Ch3.3 2022/1/1 Ch3 2022/2/6 Ch4 2022/2/7 Ch5  《Head First设计模式》\n《数据结构与算法分析：C语言描述》\n 2021/10/14 P27 2021/11/5 CH2  《Scala函数式编程》\n 2022/3/4 P47 2022/3/8 Ch3  《Java高并发编程详解：多线程与架构设计》 《Java高并发编程详解：深入理解并发核心库》 《Java程序员修炼之道》 《编程之美》 《深入理解Java模块系统》\n《gRPC与云原生应用开发：以Go和Java为例》\n 2022/3/4 P54 2022/3/5 P73 2022/3/6 Finish  《精力管理》\n 2022/3/5 Ch3  《巨人的工具》\n 2022/3/5  《领域驱动设计：软件核心复杂性应对之道》\n《测试驱动开发》\n 2022/3/2 Ch1 ~ Ch8 2022/3/3 Ch9 ~ Ch19 2022/3/4 Finish  《图解HTTP》\n 2022/2/26 Ch1 ~ Ch6 2022/2/27 Ch7 ~ Ch8 2022/2/28 Finish  《网络基本功系列》\n 2022/2/23 Ch1 ~ Ch3  《软件设计的哲学》\n 2022/2/22 Ch1 ~ Ch4  《Atomic Kotlin》\n 2022/3/1 P38 2022/3/2 P56 2022/3/7 P86  《On Java8》\n《Linux就该这么学》\n《UNIX网络编程 卷1：套接字联网API》\n 2021/12/8 P17 2022/2/10 Ch2 2022/3/4 Ch3 2022/3/7 Ch4 2022/3/8 Ch5  《TCP-IP详解 卷1：协议》\n 2021/10/16 CH1 2021/10/19 CH2 2021/10//20 CH3、CH4、CH5 2021/11/10 Ch8 2021/11/20 Ch9、Ch10 2022/3/4 Ch11  《LinuxUNIX系统编程》\n 2021/10/11 P46 2021/10/21 CH3 2021/11/4 CH4、5、6 2021/11/5 CH7 2021/11/21 Ch11、Ch12 2021//11/30 Ch13 2022/2/22 Ch14 2022/2/24 Ch15 ~ Ch19  《数据库系统概念》\n 2021/11/25 Ch1 2021/12/2 Ch2 2021/12/13 Ch3 2021/12/30 P102 2022/1/4 Ch4.5  《操作系统真象还原》\n 2021/10/21 2021/10/29 Ch0 2021/10/30 Ch1 2021/11/24 Ch2 2022/2/22 P81 2022/3/1 P91 2022/3/2 P101  《计算机系统要素：从零开始构建现代计算机》\n 2021/11/16 Ch8 2021/12/28 Ch9 2022/2/10 Ch10 2022/2/16 Ch11 2022/2/19 Finsih  《数据密集型应用系统设计》\n 2021/11/6 2021/11/19 Ch1 2021/11/28 Ch2、P86 2021/12/4 P89 2021/12/11 Ch3、P124 2021/12/12 Ch4 2021/12/21 2021/12/28 Ch5 2022/1/31 Ch6 2022/2/16 Ch7  《现代C++白皮书》\n 2021/12/30 P60  《计算机程序的构造和解释》\n 2022/2/13 3.5  《Redis设计与实现》\n 2021/10/13 CH7 2021/10/25 CH8、CH9  《Wireshark数据包分析实战》\n 2021/12/4 Ch1 2022/2/10 Ch2~Ch4 2022/2/14 Ch5  《如何科学学外语 语言习得的真相与方法》\n 2022/2/2 Ch1~Ch4 2022/2/3 Finish  《软件开发实践：项目驱动式的Java开发指南》\n 2022/2/2 Ch1~Ch3 2022/2/3 Finish  《JAVA解惑》\n 2022/2/6 Finish  《算法4》\n 2022/1/25 Finish  《编程珠玑》\n 2021/11/27 Ch1 2021/12/14 Ch2 2022/1/3 Ch3 2022/1/25 Finish  《Java工程师修炼之道》\n 2022/1/11 1.1 2022/1/23 Finish  《The Little Schemer》\n 2021/11/15 Ch5 2021/11/25 Ch6 2022/1/15 Ch7 2022/1/22 Finish  《代码整洁之道》\n 2021/11/15 Ch3 2021/12/14 Ch4、Ch5、Ch6 2022/1/21 Ch7、8、9、10、11 2022/1/22 Finish  《Java并发编程的艺术》\n 2021/10/9 P280 ~ P304 2021/10/30 Finish  《操作系统导论》\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 Finish  《Build On Your Lisp》\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 Finish  《UNIX环境高级编程》\n 2021/10/22 CH11 2021/10/31 CH12 2021/11/10 2021/11/20 Ch16 2021/11/24 Finish  "},{"id":31,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  Tools\r#\r\r \rVisuAlgo.net \rBig-O Cheat Sheet  "},{"id":32,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":" \rAcwing模板\n 快速排序\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } 归并排序\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 二分\r#\r\r// 区间[l,r]划分成[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) { //check() 检查mid是否满足性质  r = mid; } else { l = mid + 1; } } } // 区间[l,r]划分成[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1\u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } 双指针\r#\r\rfor (int i = 0, j = 0; i \u0026lt; n; i ++ ) { while (j \u0026lt; i \u0026amp;\u0026amp; check(i, j)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算\r#\r\r求n的第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1\r返回n的最后一位1：lowbit(n) = n \u0026amp; -n\r离散化\r#\r\rvector\u0026lt;int\u0026gt; alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素  // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 区间合并\r#\r\r// 将所有存在交集的区间合并 void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 单链表\r#\r\r// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } 双链表\r#\r\r// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点  r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈\n// tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u0026gt; 0) { } 队列\r#\r\r 普通队列  // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u0026lt;= tt) { } 循环队列  // hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt) { } 单调栈\r#\r\r常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 单调队列\r#\r\r常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口  while (hh \u0026lt;= tt \u0026amp;\u0026amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP\r#\r\r// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 求模式串的Next数组： for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑  } } Trie树\r#\r\rint son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量  // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集\r#\r\r(1)朴素并查集： int p[N]; //存储每个点的祖宗节点  // 返回x的祖宗节点  int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n  for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合：  p[find(a)] = find(b); (2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量  // 返回x的祖宗节点  int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n  for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合：  size[find(b)] += size[find(a)]; p[find(a)] = find(b); (3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离  // 返回x的祖宗节点  int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n  for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合：  p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆\r#\r\r// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u / 2]) { heap_swap(u, u / 2); u \u0026gt;\u0026gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); 一般哈希\r#\r\r(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数  void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在  bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置  int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希\r#\r\r核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64  // 初始化 p[0] = 1; for (int i = 1; i \u0026lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STL简介\r#\r\rvector, 变长数组，倍增的思想\rsize() 返回元素个数\rempty() 返回是否为空\rclear() 清空\rfront()/back()\rpush_back()/pop_back()\rbegin()/end()\r[]\r支持比较运算，按字典序\rpair\u0026lt;int, int\u0026gt;\rfirst, 第一个元素\rsecond, 第二个元素\r支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\rstring，字符串\rsize()/length() 返回字符串长度\rempty()\rclear()\rsubstr(起始下标，(子串长度)) 返回子串\rc_str() 返回字符串所在字符数组的起始地址\rqueue, 队列\rsize()\rempty()\rpush() 向队尾插入一个元素\rfront() 返回队头元素\rback() 返回队尾元素\rpop() 弹出队头元素\rpriority_queue, 优先队列，默认是大根堆\rsize()\rempty()\rpush() 插入一个元素\rtop() 返回堆顶元素\rpop() 弹出堆顶元素\r定义成小根堆的方式：priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q;\rstack, 栈\rsize()\rempty()\rpush() 向栈顶插入一个元素\rtop() 返回栈顶元素\rpop() 弹出栈顶元素\rdeque, 双端队列\rsize()\rempty()\rclear()\rfront()/back()\rpush_back()/pop_back()\rpush_front()/pop_front()\rbegin()/end()\r[]\rset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\rsize()\rempty()\rclear()\rbegin()/end()\r++, -- 返回前驱和后继，时间复杂度 O(logn)\rset/multiset\rinsert() 插入一个数\rfind() 查找一个数\rcount() 返回某一个数的个数\rerase()\r(1) 输入是一个数x，删除所有x O(k + logn)\r(2) 输入一个迭代器，删除这个迭代器\rlower_bound()/upper_bound()\rlower_bound(x) 返回大于等于x的最小的数的迭代器\rupper_bound(x) 返回大于x的最小的数的迭代器\rmap/multimap\rinsert() 插入的数是一个pair\rerase() 输入的参数是pair或者迭代器\rfind()\r[] 注意multimap不支持此操作。 时间复杂度是 O(logn)\rlower_bound()/upper_bound()\runordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\r和上面类似，增删改查的时间复杂度是 O(1)\r不支持 lower_bound()/upper_bound()， 迭代器的++，--\rbitset, 圧位\rbitset\u0026lt;10000\u0026gt; s;\r~, \u0026amp;, |, ^\r\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\r==, !=\r[]\rcount() 返回有多少个1\rany() 判断是否至少有一个1\rnone() 判断是否全为0\rset() 把所有位置成1\rset(k, v) 将第k位变成v\rreset() 把所有位变成0\rflip() 等价于~\rflip(k) 把第k位取反\r"},{"id":33,"href":"/docs/cs/build/","title":"Build","section":"C S","content":" \rlearn-x-by-doing-y \rbuild-your-own-x \rProject Based Learning  "},{"id":34,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Java并发编程艺术","section":"C S","content":"11.2 定位问题\r#\r\r线上代码定位问题\n11.3 性能测试\r#\r\r相关的命令\n"},{"id":35,"href":"/docs/cs/courses/","title":"Courses","section":"C S","content":"Study Path\r#\r\r [MIT 6.Null The Missing Semester of Your CS Education]  编程入门\r#\r\r CSE 251 Programming in C Programming Languages, Part A Standford CS106L C++ Programming CS 61A: Structure and Interpretation of Computer Programs  数据结构与算法\r#\r\r UCB CS61B Data Structures Standford CS106B Programming Abstractions  软件工程\r#\r\r MIT 6.031: Software Construction UCB CS169: software engineering  体系结构\r#\r\r From Nand to Tetris Building a Modern Computer From First Principles UCB CS61C Great Ideas in Computer Architecture (Machine Structures)  系统入门\r#\r\r MIT6.033: System Engineering CMU 15-213: Introduction to Computer System  操作系统\r#\r\r MIT 6.S081 Operating System Engineering UCB CS162: Operating Systems and System Programming  数据库系统\r#\r\r CMU 15-445: Introduction to Database System (C++) UCB CS186: Introduction to Database System (Java)  计算机网络\r#\r\r Stanford CS144: Computer Network  编译原理\r#\r\r Stanford CS143: Compilers  并行与分布式系统\r#\r\r CMU 15-418/Stanford CS149: Parallel Computing MIT 6.824: Distributed System  系统安全\r#\r\r UCB CS161: Computer Security  "},{"id":36,"href":"/docs/cs/database/","title":"Database","section":"C S","content":" \rdb-tutorial 是一个数据库教程。 \r电子科技大学分布式存储与计算实验室新生训练计划 \r😋 A curated reading list about database systems \rReadings in Databases  "},{"id":37,"href":"/docs/cs/interviews/","title":"Interviews","section":"C S","content":" \r整理it资料的百科全库 \r介绍中国各二线以上城市的互联网环境以及生活成本  Java\r#\r\r \rbugstack 虫洞栈 \rJava 全栈知识体系 \rJavaGuide \rJavaFamily \rJavaTutorial \rlearning-note \rJavaKeeper \r互联网 Java 工程师进阶知识完全扫盲 \rJavaHome \rJavaSourceCodeLearning \rDocs \rJavaYouth \rjavaDesign \r大厂面试指北 \r算法刷题指南、Java多线程与高并发、Java集合源码、Spring boot、Spring Cloud等笔记，源码级学习笔记后续也会更新。  C++\r#\r\r \r【C++面试\u0026amp;C++学习指南】 这里整理了C++后端研发工程师面试和工作必备的知识点 。  Others\r#\r\r \r互联网公司常用框架源码赏析 \rTech Interview Handbook \rCS-Notes \rEverything you need to know to get the job.  "},{"id":38,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt xxd 查看文件二进制  输出当前用户是不是 root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  查看磁盘引导扇区 (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  统计所有 cpp 文件的行数\n find . | grep '\\.cpp$' | xargs cat | wc -l  统计命令行命令的频率\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  文件检索 - cat, more, less, head, tail, file, find\n  输入输出控制 - 重定向, 管道, tee, xargs\n  文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  正则表达式\n  系统监控 - jobs, ps, top, kill, free, demsg, lsof\n   如何比较两个文件是否完全相同?   diff or md5sum\n  如何列出一个C语言项目中所有被包含过的头文件?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n du -h -d 1 2\u0026gt;/dev/null | grep -v denied 磁盘分析\n\r配置linux\n查看最大空间占用目录\nsudo du -h \u0026ndash;exclude=\u0026ldquo;mnt*\u0026rdquo; \u0026ndash;exclude=\u0026ldquo;proc*\u0026rdquo; -d 1 /\np@ssw0rd\n"},{"id":39,"href":"/docs/cs/linux/wsl/","title":"W S L","section":"C S","content":"\r为WSL2加图形化界面配置\n运行 startxfce4\n"},{"id":40,"href":"/docs/cs/network/","title":"Network","section":"C S","content":"Tools\r#\r\r \rWhois  "},{"id":41,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"Network","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":42,"href":"/docs/cs/operatingsystem/","title":"Operating System","section":"C S","content":" \r操作系统导论(ostep)笔记/课后习题答案/附加代码  "},{"id":43,"href":"/docs/cs/programming/","title":"Programming","section":"C S","content":" \rC \rJava \rGo \rC++ \rPython \rRust \rJavaScript \rScala \rKotlin \rWeb  "},{"id":44,"href":"/docs/cs/programming/c++/","title":"C++","section":"Programming","content":"Resources\r#\r\r \rC++那些事 \r关于C++STL的总体介绍 \rCheat Sheets \u0026amp; Infographics \r现代 C++ 教程  "},{"id":45,"href":"/docs/cs/programming/go/","title":"Go","section":"Programming","content":"Resources\r#\r\r \rGo by Example \rGo语言圣经中文版 Link \rLearn Go with Tests \r【未来服务器端编程语言】最全空降golang资料补给包（满血战斗），包含文章，书籍，作者论文，理论分析，开源框架，云原生，大佬视频，大厂实战分享ppt \r1000+ Hand-Crafted Go Examples, Exercises, and Quizzes \rA Tuor of Go \rStandard Go Project Layout \rGo 语言设计与实现 \r《Effective Go》中英双语版 \rGo语言高级编程 \rPractical Go Lessons \rA hands-on approach to getting started with Go generics. \rList of Golang books \r7 days golang programs from scratch \rGolangStudy: Golang 面试学习 \rGolang从入门到跑路  "},{"id":46,"href":"/docs/cs/programming/js/","title":"J S","section":"Programming","content":" \r现代 JavaScript 教程  "},{"id":47,"href":"/docs/cs/programming/rust/","title":"Rust","section":"Programming","content":"Resources\r#\r\r \rWriting an OS in Rust \rRust 程序设计语言 \rA book about Rust Data Structures and Algorithms. \rRust语言圣经  "},{"id":48,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"Rust","content":"Cargo\r#\r\r cargo new project-name  "},{"id":49,"href":"/docs/cs/resource/","title":"Resource","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \r📚 List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCS公开课程学习群课程推荐 \r克莱登大学CS(热心网友整理) \r🎓 Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos \r写在20年初的校招面试心得与自学CS经验及找工作分享 \rTeach Yourself Programming in Ten Years \rCS自学指南 \r从小白到BAT后端工程师的自学路线 \rA Self-Learning, Modern Computer Science Curriculum \r名校公开课程评价网 \rBest-websites-a-programmer-should-visit \rCS-Awesome-Courses \rcs-video-courses \rEvery Programmer Should Know  \rExplore, Create and Share Learning Roadmaps in Tech \rAlgorithms-Cheatsheet-Resources \rRoadmap \rRico\u0026rsquo;s cheatsheets \rA collection of the best resources for programming, web development, computer science and more. \r💻📖对开发人员有用的定律、理论、原则和模式 \r给新员工和实习生的生存指南  "},{"id":50,"href":"/docs/cs/software/","title":"Software","section":"C S","content":" \r为什么这么设计系列文章 \rsystem-design-primer \rThe Architecture of Open Source Applications \rMy favorite papers \rpapers-we-love  "},{"id":51,"href":"/docs/cs/tools/","title":"Tools","section":"C S","content":" \rRegular Expression \rMaven \rDocker \rGDB \rAwesome cheatsheets  "},{"id":52,"href":"/docs/cs/tools/docker/","title":"Docker","section":"Tools","content":"使用Docker提供本项目的Mysql和Redis服务\r#\r\rInstall\r#\r\rhttps://docs.docker.com/install/linux/docker-ce/centos/\nhttps://blog.csdn.net/weixin_39477597/article/details/87715899\nhttps://blog.csdn.net/weixin_43569697/article/details/89279225\nCMD中写windows路径 //c\n-v /c\\Users\\sunhu\\Documents\\Study\\Tool\\calibre-web\\books\nDocker 启动、重启、关闭\r#\r\r开机自启\nsystemctl enable docker\nsystemctl start docker\n守护进程重启 systemctl daemon-reload\n重启docker服务 systemctl restart docker / service docker restart\n关闭 docker service docker stop / docker systemctl stop docker\n停用全部运行中的容器:\r#\r\rdocker stop $(docker ps -q)\n删除全部容器：\r#\r\rdocker rm $(docker ps -aq)\n一条命令实现停用并删除容器：\r#\r\rdocker stop $(docker ps -q) \u0026amp; docker rm $(docker ps -aq)\r命令\r#\r\r docker images docker search \u0026lt;image_name\u0026gt; docker pull \u0026lt;域名\u0026gt;//: docker rmi : docker inspect \u0026lt;image_id\u0026gt; 查看容器信息  容器命令\r#\r\r docker create \u0026lt;image_name\u0026gt; docker run \u0026lt;image_name\u0026gt; docker run ubuntu /bin/echo \u0026ldquo;Test\u0026rdquo; docker run \u0026ndash;name demo -d ubuntu docker stop \u0026lt;container_id\u0026gt; docker ps 查看运行中的容器 docker ps -a 列出启动过的容器 可以使用start重新启动 docker start \u0026lt;container_id\u0026gt; 启动容器 docker rm \u0026lt;container_id\u0026gt; docker rm -f \u0026lt;container_id\u0026gt; docker container top  docker exec \u0026lt;container_id\u0026gt;  docker exec -it \u0026lt;container_id\u0026gt; bash 登陆到容器中    案例\r#\r\rdocker run \u0026ndash;name mysqlsvr -p 12345:3306 -e MYSQL_ROOT_PASSWORD=sfy1314 -d mysql\ndocker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server \u0026ndash;appendonly yes\n开机自启\ndocker run \u0026ndash;restart=always \u0026ndash;name first-mysql -p 12345:3306 -e MYSQL_ROOT_PASSWORD=sfy1314 -d mysql\nMongoDB\r#\r\rdocker run \u0026ndash;name mongo -p 27017:27017 -v ~/Desktop/docker/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo\n登录到MongoDB容器中\ndocker exec -it mongo bash\n通过Shell连接MongoDB\nmongo -u admin -p admin\nRdis\r#\r\r获取镜像\ndocker pull redis\n启动Redis\ndocker run \u0026ndash;name redis -d -p 6379:6379 redis\ndocker exec -it \u0026lt;container_name\u0026gt; redis-cli\nNginx\r#\r\rdocker run \u0026ndash;restart always \u0026ndash;name my-nginx -p 80:80 -d nginx\nRabbitMQ\r#\r\r#指定版本，该版本包含了web控制页面\rdocker pull rabbitmq:management\rdocker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management\rElasticSearch\r#\r\rdocker run -d -p 9200:9200 elasticsearch\r"},{"id":53,"href":"/docs/cs/tools/gdb/","title":"G D B","section":"Tools","content":"Resources\r#\r\r \r用GDB调试程序 \r100-gdb-tips  GCC\r#\r\r  -E 获取预处理后的文件内容\n  -V 将编译、链接过程打印\n  -g 用于GDB调试\n  ltrace 命令用来跟踪程序运行时调用的库函数\n -S 查看系统调用 -e trace=write 只看write系统调用  strace 查看系统调用的封装函数\nGDB\r#\r\rSegment Fault快速定位\n首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core  list start ctrl + x + a  "},{"id":54,"href":"/docs/cs/tools/git/","title":"Git","section":"Tools","content":"// 删除本地分支 git branch -d localBranchName\n// 删除远程分支 git push origin \u0026ndash;delete remoteBranchName\n修改github 日期\ngit commit\rgit cat-file -p HEAD \u0026gt; tmp.txt\r# at this point, edit the file to replace the timestamp\rgit hash-object -t commit -w tmp.txt\r#=\u0026gt; 2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rgit update-ref -m 'commit: foo' refs/heads/master \\\r2ee8fcc02658e23219143f5bcfe6f9a4615745f9\r取消跟踪,删除远程文件\ngit rm -r --cached .\rgit add .\rgit commit -m \u0026quot;update gitignore\u0026quot;\r配置全局信息\n \u0026ndash;local\n git config \u0026ndash;global user.name \u0026ldquo;myname\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;test@gmail.com\u0026rdquo;\n"},{"id":55,"href":"/docs/cs/tools/jenkins/","title":"Jenkins","section":"Tools","content":"https://linuxize.com/post/how-to-install-jenkins-on-ubuntu-20-04/\nhttps://www.cnblogs.com/chenxiaomeng/p/11412038.html\nhttps://www.cnblogs.com/ding2016/p/12988080.html\nservice jenkins restart[start\\stop]\nsystemctl status jenkins\n"},{"id":56,"href":"/docs/cs/tools/maven/","title":"Maven","section":"Tools","content":"mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.12 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.12.jar\n"},{"id":57,"href":"/docs/cs/tools/npm/","title":"Npm","section":"Tools","content":"\rnpkill\n"},{"id":58,"href":"/docs/cs/tools/regularexpression/","title":"Regular Expression","section":"Tools","content":"Resources\r#\r\r \rRegexLearn  "},{"id":59,"href":"/docs/cs/tools/vim/","title":"Vim","section":"Tools","content":"https://missing-semester-cn.github.io/2020/editors/\nhttps://vimawesome.com/\n"},{"id":60,"href":"/docs/cs/tools/vscode/","title":"Vscode","section":"Tools","content":"WSL相关\r#\r\rvscode server for wsl closed unexpectedly\nnetsh winsock reset重置网络 或移除wsl中的~/.vscode-server\n"},{"id":61,"href":"/docs/english/","title":"English","section":"Docs","content":"网站\r#\r\r https://www.eapfoundation.com/ https://lyricstraining.com/ 听歌 http://skesl.com/ https://www.speechace.com/ 口语 https://www.vocabulary.com/play/ 单词 \rThe New York Times 新闻 \rScienceDaily 新闻 https://english-e-reader.net/ 免费分级书籍 \rYouGlish 口语 \rOGDEN\u0026rsquo;s BASIC ENGLISH \rLongman Dictionary \r聚合工具 https://www.languagereactor.com/ 视频 \rHow to learn English \rLearn English 🇬🇧🇺🇸  "},{"id":62,"href":"/docs/leetcode/","title":"Leet Code","section":"Docs","content":" \rCodeTop  目前分类目录\r#\r\r剑指 Offer\r#\r\r面试题 \r#\r\r国区周寨\r#\r\r  第273场\n \r5963. 反转两次的数字(E) \r5964. 执行所有后缀指令(M) \r5965. 相同元素的间隔之和(M)    第274场\n \r5967. 检查是否所有 A 都在 B 之前(E) \r5968. 银行中的激光束数量(M) \r5969. 摧毁小行星(M)    Dynamic Programming\r#\r\r \r10. 正则表达式匹配(H) \r44. 通配符匹配(H) \r45. 跳跃游戏 II(M) \r62. Unique Paths(M) \r63. Unique Paths II(M) \r64. Minimum Path Sum(M) \r91. Decode Ways(M) \r118. Pascal\u0026rsquo;s Triangle(E) \r119. Pascal\u0026rsquo;s Triangle II(E) \r120. Triangle(M) \r122. 买卖股票的最佳时机 II(M) \r123. 买卖股票的最佳时机 III(H) \r198. 打家劫舍(M) \r213. 打家劫舍 II(M) \r264. Ugly Number II(E) \r309. 最佳买卖股票时机含冷冻期(M) \r509. Fibonacci Number(M) \r714. Best Time to Buy and Sell Stock with Transaction Fee(M)  Tree\r#\r\r \r559. Maximum Depth of N-ary Tree(E) \r700. Search in a Binary Search Tree(E) \r102. 二叉树的层序遍历(M)  Heap\r#\r\r \r1046. 最后一块石头的重量(E) \r347. 前 K 个高频元素(M) \r451. 根据字符出现频率排序(M)  Math\r#\r\r \r43. 字符串相乘(M) \r384. Shuffle an Array(E) \r519. Random Flip Matrix(M) \r1979. Find Greatest Common Divisor of Array(E) \r812. Largest Triangle Area(E)   Combinatorics  \r39. 组合总和(M) \r39. 组合总和 II(M) \r46. 全排列(M) \r47. 全排列 II(M)    DFS\r#\r\r \r17. 电话号码的字母组合(M) \r37. 解数独(H) \r51. N 皇后(H) \r52. N 皇后 II(H) \r139. Word Break(M)  Recursion\r#\r\r \r1492. The kth Factor of n(M)  BinarySearch\r#\r\r\r33. 搜索旋转排序数组(M) 34. 在排序数组中查找元素的第一个和最后一个位置(M) 35. 搜索插入位置(E)\nSorts\r#\r\r Quick Select  \r215. Kth Largest Element in an Array   Index Sort  \r41. 缺失的第一个正数(H)    LinkedList\r#\r\r \r2. 两数相加(M) \r19. 删除链表的倒数第 N 个结点(M) \r21. 合并两个有序链表(E) \r23. 合并K个升序链表(H) \r24. 两两交换链表中的节点(M) \r25. K 个一组翻转链表(H)  Stack\r#\r\r \r20. 有效的括号(E) \r32. 最长有效括号(H)   Monotonic Stack   \r42. 接雨水(H)  Hash Table\r#\r\r \r49. 字母异位词分组(M)  Two Pointers\r#\r\r \r11. 盛最多水的容器(M) \r15. 三数之和(M) \r16. 最接近的三数之和(M) \r18. 四数之和(M) \r26. 删除有序数组中的重复项(E) \r27. 移除元素(E)   Sliding window  \r3. 无重复字符的最长子串(M) \r4. 寻找两个正序数组的中位数(H) \r30. 串联所有单词的子串(H)    String\r#\r\r \r6. Z 字形变换(M) \r8. 字符串转换整数 (atoi)(M) \r14. 最长公共前缀(E)   Manacher  \r5. 最长回文子串(M)   KMP  \r28. 实现 strStr()(E)    Others\r#\r\r \r1. 两数之和(E) \r7. 整数反转(M) \r9. 回文数(E) \r22. 括号生成(E) \r29. 两数相除(M) \r31. 下一个排列(M) \r36. 有效的数独(M) \r48. 旋转图像(M) \r50. Pow(x, n)(M) \r1005. Maximize Sum Of Array After K Negations(E) \r383. Ransom Note(E) \r748. Shortest Completing Word(E)  Simulation\r#\r\r \r12. 整数转罗马数字(M) \r13. 罗马数字转整数(E) \r38. 外观数列(M)  Design\r#\r\r \r355. 设计推特(M) \r146. LRU 缓存(M)  "},{"id":63,"href":"/docs/leetcode/binarysearch/33/","title":"33rd","section":"Leet Code","content":" \rLink\n public int search(int[] nums, int target) { // 找到分隔点, 一半区间满足性质，另一半则不满足  // 2 3 4 5 6 7, 1  // 6 7, 1 2 3 4 5  int l = 0, r = nums.length - 1; int mid; while (l \u0026lt; r) { mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= nums[0]) { l = mid; } else { r = mid - 1; } } // 判断在左半边、右半边  if (target \u0026gt;= nums[0]) { l = 0; } else { l = r + 1; r = nums.length - 1; } while (l \u0026lt; r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[r] == target) return r; return -1; } "},{"id":64,"href":"/docs/leetcode/binarysearch/34/","title":"34th","section":"Leet Code","content":" \rLink\n class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int l = 0, r = nums.length - 1; int mid; while (l \u0026lt; r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[l] != target) { return new int[]{-1, -1}; } int[] res = new int[2]; res[0] = l; l = 0; r = nums.length - 1; while (l \u0026lt; r) { mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026lt;= target) { l = mid; } else { r = mid - 1; } } res[1] = l; return res; } } "},{"id":65,"href":"/docs/leetcode/binarysearch/35/","title":"35th","section":"Leet Code","content":" \rLink\n public int searchInsert(int[] nums, int target) { int lo = 0, hi = nums.length, mid = 0; while (lo \u0026lt; hi) { mid = (lo + hi) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { hi = mid; } else { lo = mid + 1; } } return lo; } "},{"id":66,"href":"/docs/leetcode/design/146/","title":"146th","section":"Leet Code","content":" \rLink\n 使用java的双向链表LinkedList有坑啊，过不了。\nclass LRUCache { private int capacity; private DoubleList list; private Map\u0026lt;Integer, Node\u0026gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap\u0026lt;\u0026gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.get(key); node.val = value; list.remove(node); } else { node = new Node(value, key); if (map.size() == capacity) { // full  Node last = list.removeLast(); map.remove(last.key); } } list.addFirst(node); map.put(key, node); } } class DoubleList { Node head, tail; public DoubleList() { this.head = null; this.tail = null; } public void addFirst(Node node) { if (head == null) { this.head = node; this.tail = node; } else { node.prev = null; node.next = head; head.prev = node; head = node; } } public void remove(Node node) { if (node == head) { this.head = node.next; if (this.head != null) { this.head.prev = null; } } else if (node == tail) { this.tail = node.prev; if (this.tail != null) { this.tail.next = null; } } else { Node prev = node.prev; prev.next = node.next; prev.next.prev = prev; } } public Node removeLast() { Node res = this.tail; if (this.head == this.tail) { res = this.head; this.head = this.tail = null; } else { Node node = this.tail.prev; node.next = null; this.tail = node; } return res; } } class Node { int val; int key; Node prev; Node next; public Node(int val, int key) { this.val = val; this.key = key; } } "},{"id":67,"href":"/docs/leetcode/design/355/","title":"355th","section":"Leet Code","content":" \rLink\n class Twitter { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; follows; private Map\u0026lt;Integer, PriorityQueue\u0026lt;Integer\u0026gt;\u0026gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map\u0026lt;Integer, Integer\u0026gt; orders = new HashMap\u0026lt;\u0026gt;(); public Twitter() { follows = new HashMap\u0026lt;\u0026gt;(); tweets = new HashMap\u0026lt;\u0026gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue\u0026lt;Integer\u0026gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue\u0026lt;Integer\u0026gt;((a, b) -\u0026gt; b - a); tweets.put(userId, tmp); } int key = ai.incrementAndGet(); orders.put(key, tweetId); tmp.offer(key); } public List\u0026lt;Integer\u0026gt; getNewsFeed(int userId) { List\u0026lt;Integer\u0026gt; followees = follows.get(userId); PriorityQueue\u0026lt;Integer\u0026gt; tmp = new PriorityQueue\u0026lt;\u0026gt;(); if (followees != null) { for (int followeeId : followees) { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(followeeId); if (t != null) { updateTop10Data(t, tmp); } } } else { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(userId); if (t != null) { updateTop10Data(t, tmp); } } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (tmp.size() \u0026gt; 0) { res.add(0, orders.get(tmp.poll())); } return res; } private void updateTop10Data(PriorityQueue\u0026lt;Integer\u0026gt; data, PriorityQueue\u0026lt;Integer\u0026gt; res) { for (int d : data) { if (res.size() \u0026gt;= 10) { if (res.peek() \u0026lt; d) { res.poll(); res.offer(d); } } else { res.offer(d); } } } public void follow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); tmp.add(followerId); follows.put(followerId, tmp); } if (tmp.contains(followeeId)) { return; } tmp.add(followeeId); } public void unfollow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { return; } tmp.remove(new Integer(followeeId)); } } "},{"id":68,"href":"/docs/leetcode/dfs/139/","title":"139th","section":"Leet Code","content":" \rLink\n 遍历字符串，将其分成两部分left和right，判断是否都在wordList里。\n加上记忆化\npublic boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(wordDict); Map\u0026lt;String, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set\u0026lt;String\u0026gt; set, Map\u0026lt;String, Boolean\u0026gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i \u0026lt; n; i++) { String left = s.substring(0, i); String right = s.substring(i, n); if (set.contains(left) \u0026amp;\u0026amp; dfs(right, set, map)) { map.put(s, true); return true; } } map.put(s, false); return false; } 最佳实践：使用Trie\npublic class TreeNode { TreeNode[] children; boolean isWord; char value; TreeNode() { children = new TreeNode[26]; } } private TreeNode root = new TreeNode(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { TreeNode node = root; for (char c : word.toCharArray()) { if (node.children[c - \u0026#39;a\u0026#39;] == null) { node.children[c - \u0026#39;a\u0026#39;] = new TreeNode(); } node.children[c - \u0026#39;a\u0026#39;].value = c; node = node.children[c - \u0026#39;a\u0026#39;]; } node.isWord = true; } return dfs(s, 0); } private int[] memo = new int[301]; private boolean dfs(String s, int cur) { // s[cur:]  int n = s.length(); if (cur \u0026gt;= n) return true; if (memo[cur] == 1) return false; TreeNode node = root; for (int i = cur; i \u0026lt; n; i++) { TreeNode tmp = node.children[s.charAt(i) - \u0026#39;a\u0026#39;]; node = tmp; if (tmp != null) { if (tmp.isWord \u0026amp;\u0026amp; dfs(s, i + 1)) { return true; } } else { break; } } memo[cur] = 1; return false; } "},{"id":69,"href":"/docs/leetcode/dfs/17/","title":"17th","section":"Leet Code","content":" \rLink\n 使用StringBuilder优化字符串copy\nclass Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), new StringBuilder()); return res; } private void dfs(String digits, int pos, int len, StringBuilder cur) { if (pos == len) { res.add(cur.toString()); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { cur.append(c); dfs(digits, pos + 1, len, cur); cur.deleteCharAt(cur.length() - 1); } } } } class Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), \u0026#34;\u0026#34;); return res; } private void dfs(String digits, int pos, int len, String cur) { if (pos == len) { res.add(cur); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { dfs(digits, pos + 1, len, cur + c); } } } } "},{"id":70,"href":"/docs/leetcode/dfs/37/","title":"37th","section":"Leet Code","content":" \rLink\n class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init  for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;1\u0026#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] != \u0026#39;.\u0026#39;) return dfs(board, x, y + 1); for (int i = 0; i \u0026lt; 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x / 3][y / 3][i]) { board[x][y] = (char)(i + \u0026#39;1\u0026#39;); row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if (dfs(board, x, y + 1)) { return true; } board[x][y] = \u0026#39;.\u0026#39;; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; } } "},{"id":71,"href":"/docs/leetcode/dfs/51/","title":"51st","section":"Leet Code","content":" \rLink\n class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; int n; vector\u0026lt;bool\u0026gt; col, dg, udg; vector\u0026lt;string\u0026gt; path; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int _n) { n = _n; col = vector\u0026lt;bool\u0026gt;(n); dg = vector\u0026lt;bool\u0026gt;(n * 2); udg = vector\u0026lt;bool\u0026gt;(n * 2); path = vector\u0026lt;string\u0026gt;(n, string(n, \u0026#39;.\u0026#39;)); dfs(0); return res; } void dfs(int u) { if (u == n) { res.push_back(path); return; } for (int i = 0; i \u0026lt; n; i++) { if (!col[i] \u0026amp;\u0026amp; !dg[u + i] \u0026amp;\u0026amp; !udg[u - i + n]) { col[i] = dg[u + i] = udg[u - i + n] = true; path[u][i] = \u0026#39;Q\u0026#39;; dfs(u + 1); path[u][i] = \u0026#39;.\u0026#39;; col[i] = dg[u + i] = udg[u - i + n] = false; } } } }; "},{"id":72,"href":"/docs/leetcode/dfs/52/","title":"52nd","section":"Leet Code","content":" \rLink\n class Solution { boolean[] col, dg, udg; int n; public int totalNQueens(int n) { this.n = n; col = new boolean[n]; dg = new boolean[n * 2]; udg = new boolean[n * 2]; return dfs(0); } private int dfs(int u) { if (u == n) { return 1; } int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (!col[i] \u0026amp;\u0026amp; !dg[u - i + n] \u0026amp;\u0026amp; !udg[u + i]) { col[i] = dg[u - i + n] = udg[u + i] = true; res += dfs(u + 1); col[i] = dg[u - i + n] = udg[u + i] = false; } } return res; } } "},{"id":73,"href":"/docs/leetcode/dfs/5964/","title":"5964th","section":"Leet Code","content":" TODO: Link\n class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i \u0026lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i \u0026lt; len; i++) { if (checkAndRun(pos, s.charAt(i))) { res++; } else { break; } } return res; } private boolean checkAndRun(int[] pos, char c) { if (c == \u0026#39;U\u0026#39;) { if (pos[0] != 0) { pos[0]--; return true; } } else if (c == \u0026#39;R\u0026#39;) { if (pos[1] != (n - 1)) { pos[1]++; return true; } } else if (c == \u0026#39;L\u0026#39;) { if (pos[1] != 0) { pos[1]--; return true; } } else if (c == \u0026#39;D\u0026#39;) { if (pos[0] != (n - 1)) { pos[0]++; return true; } } return false; } } "},{"id":74,"href":"/docs/leetcode/dynamicprogramming/10/","title":"10th","section":"Leet Code","content":" \rLink\n public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // 表示 dp[i][j] = s[1..i] 和 p[1...j]是否相等  boolean[][] dp = new boolean[m + 1][n + 1]; s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; dp[0][0] = true; for (int i = 0; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (j + 1 \u0026lt;= n \u0026amp;\u0026amp; p.charAt(j + 1) == \u0026#39;*\u0026#39;) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; p.charAt(j) != \u0026#39;*\u0026#39;) { dp[i][j] = dp[i - 1][j - 1] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == \u0026#39;.\u0026#39;); } else if (p.charAt(j) == \u0026#39;*\u0026#39;) { /** dp[i][j] = dp[i][j-2] || (dp[i-1][j-2] \u0026amp;\u0026amp; s[i]==p[j-1]) || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1]==p[j-1] \u0026amp;\u0026amp; s[i]==p[j-1]) dp[i-1][j] = dp[i-1][j-2] || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1] == p[j-1]) dp[i][j] = dp[i][j-2] || (dp[i-1][j] \u0026amp;\u0026amp; s[i]==p[j-1]) */ dp[i][j] = dp[i][j - 2] || (i \u0026gt; 0 \u0026amp;\u0026amp; dp[i - 1][j] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j - 1) || p.charAt(j - 1) == \u0026#39;.\u0026#39;)); } } } return dp[m][n]; } "},{"id":75,"href":"/docs/leetcode/dynamicprogramming/118/","title":"118th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i \u0026lt;= numRows; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= numRows; i++) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (int j = 1; j \u0026lt;= i; j++) { tmp.add(dp[i][j]); } ans.add(tmp); } return ans; } } "},{"id":76,"href":"/docs/leetcode/dynamicprogramming/119/","title":"119th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;Integer\u0026gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row \u0026lt;= rowIndex; row++) { for (int col = 1; col \u0026lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int col = 1; col \u0026lt;= rowIndex; col++) { ans.add(dp[rowIndex][col]); } return ans; } } 进阶优化空间：O(rowIndex)\nclass Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { vector\u0026lt;int\u0026gt; ans(rowIndex + 1, 1); for (int i = 0; i \u0026lt;= rowIndex; i++) { for (int j = i - 1; j \u0026gt;= 1; j--) { ans[j] = ans[j] + ans[j - 1]; } } return ans; } }; "},{"id":77,"href":"/docs/leetcode/dynamicprogramming/120/","title":"120th","section":"Leet Code","content":" \rLink\n DP 要从下往上找，否则不一定是全局最优\n2 3 4 6 5 1 4 1 8 3\nclass Solution { public int minimumTotal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j \u0026lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt;= i; j++) { dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); } } return dp[0][0]; } } "},{"id":78,"href":"/docs/leetcode/dynamicprogramming/122/","title":"122nd","section":"Leet Code","content":" \rLink\n 可以把数据看成折线图，则所有上升之和为解\npublic int maxProfit(int[] prices) { int res = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP\npublic int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润  int[] dp1 = new int[n]; // 第i天卖掉的最大利润  int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i \u0026lt; n; i++) { // 可以不买或卖  dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] + prices[i]); } return dp2[n - 1]; } "},{"id":79,"href":"/docs/leetcode/dynamicprogramming/123/","title":"123rd","section":"Leet Code","content":" \rLink\n public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: 持有第一股的最大利益  // dp[0][1]: 售出第一股的最大利益  // dp[0][2]: 持有第二股的最大利益  // dp[0][3]: 售出第二股的最大利益  int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i \u0026lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i - 1]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i - 1]); } return Math.max(dp[n][1], dp[n][3]); } "},{"id":80,"href":"/docs/leetcode/dynamicprogramming/198/","title":"198th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: 第一个房间抢  // dp[0][1]: 第一个房间不抢  int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } "},{"id":81,"href":"/docs/leetcode/dynamicprogramming/213/","title":"213th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j)  private int help(int[] nums, int i, int j) { // 0 : 抢  // 1 : 不抢  int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i \u0026lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[j - 1][0], dp[j - 1][1]); } } "},{"id":82,"href":"/docs/leetcode/dynamicprogramming/264/","title":"264th","section":"Leet Code","content":" \rLink\n 使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]\n[1] -\u0026gt; [2 3 5] -\u0026gt; [3 4 5 6 10] -\u0026gt; \u0026hellip;\nclass Solution { // Time Complexity: O(3N * lg3N)  // 每次产生 最小数的2、3、5倍数  public int nthUglyNumber(int n) { PriorityQueue\u0026lt;Long\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); q.add(1L); long top = -1L; for (int i = 0; i \u0026lt; n; i++) { top = q.peek(); while (!q.isEmpty() \u0026amp;\u0026amp; q.peek() == top) { q.poll(); } q.add(top * 2); q.add(top * 3); q.add(top * 5); } return (int)top; } } dp思想，对于任何丑数，它只能由某一个丑数x x2、x3、x*5里得到。\n定义三个指针i、j、k来定跟踪丑数的大小。\nnums X X X X X X idx2 ^\ridx3 ^\ridx5 ^\rclass Solution { // Time Complexity: O(n);  public int nthUglyNumber(int n) { int i = 0, j = 0, k = 0; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); res.add(1); for (int v = 0; v \u0026lt; n; v++) { int cur = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5)); res.add(cur); if (cur == res.get(i) * 2) i++; if (cur == res.get(j) * 3) j++; if (cur == res.get(k) * 5) k++; } return res.get(n - 1); } } "},{"id":83,"href":"/docs/leetcode/dynamicprogramming/309/","title":"309th","section":"Leet Code","content":" \rLink\n DP\npublic int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润  int[] dp1 = new int[n + 1]; // i天买入的最大利润  int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出)  dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入)  dp2[i] = Math.max(dp2[i - 1], dp1[i - 2] - prices[i - 1]); } return dp1[n]; } "},{"id":84,"href":"/docs/leetcode/dynamicprogramming/44/","title":"44th","section":"Leet Code","content":" \rLink\n f[i][j]：表示s[0..i]和p[0..j]是否匹配\npublic boolean isMatch(String s, String p) { int m = s.length(), n = p.length(); s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (p.charAt(j) == \u0026#39;*\u0026#39;) { f[i][j] = (i \u0026gt; 0 \u0026amp;\u0026amp; f[i - 1][j]) || f[i][j - 1]; } else { f[i][j] = i \u0026gt; 0 \u0026amp;\u0026amp; f[i - 1][j - 1] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == \u0026#39;?\u0026#39;); } } } return f[m][n]; } "},{"id":85,"href":"/docs/leetcode/dynamicprogramming/45/","title":"45th","section":"Leet Code","content":" \rLink\n public int jump(int[] nums) { int n = nums.length; // f[i]: 最少的跳跃次数到达i  int[] f = new int[n]; for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j + nums[j] \u0026lt; i) j++; f[i] = f[j] + 1; } return f[n - 1]; } "},{"id":86,"href":"/docs/leetcode/dynamicprogramming/509/","title":"509th","section":"Leet Code","content":" \rLink\n public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i \u0026lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; } "},{"id":87,"href":"/docs/leetcode/dynamicprogramming/62/","title":"62nd","section":"Leet Code","content":" \rLink\n DP\ndp[i][j] 表示能到i行j列不同路径个数\n初始化第一行和和第一列为1\nclass Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j \u0026lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i \u0026lt;= m; i++) { for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+记忆化\nclass Solution { public int uniquePaths(int m, int n) { int[][] memo = new int[m][n]; return dfs(0, 0, m, n, memo); } private int dfs(int i, int j, int m, int n, int[][] memo) { if (i \u0026gt;= m || j \u0026gt;= n || i \u0026lt; 0 || j \u0026lt; 0) { return 0; } if (memo[i][j] != 0) { return memo[i][j]; } if (i == m - 1 \u0026amp;\u0026amp; j == n - 1) { return 1; } int res = dfs(i + 1, j, m, n, memo) + dfs(i, j + 1, m, n, memo); memo[i][j] = res; return res; } } "},{"id":88,"href":"/docs/leetcode/dynamicprogramming/63/","title":"63rd","section":"Leet Code","content":" \rLink\n 同\r62题题思路一样\n直接看DP解法，注意初始化，有障碍物时，就不能往后走了\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } "},{"id":89,"href":"/docs/leetcode/dynamicprogramming/64/","title":"64th","section":"Leet Code","content":" \rLink\n dp[i][j] 表示到i行j列最小总和 注意初始化\nclass Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int k = i; k \u0026gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j \u0026lt; n; j++) { for (int k = j; k \u0026gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } "},{"id":90,"href":"/docs/leetcode/dynamicprogramming/714/","title":"714th","section":"Leet Code","content":" \rLink\n 第i天买入的最大利润buy[i]\n卖出的最大利润sell[i]\n卖出的时候(完成了一笔交易)减去手续费\nclass Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } } "},{"id":91,"href":"/docs/leetcode/dynamicprogramming/91/","title":"91st","section":"Leet Code","content":" \rLink\n DFS搜索 + 记忆化 class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i \u0026gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i \u0026lt; n - 1 \u0026amp;\u0026amp; isValid(s.substring(i, i + 2))) { res += dfs(s, i + 2); } memo.put(s.substring(i), res); return res; } private boolean isValid(String s) { int val = Integer.valueOf(s); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } private boolean isValid(char c) { int t = c - \u0026#39;0\u0026#39;; return 1 \u0026lt;= t \u0026amp;\u0026amp; t \u0026lt;= 26; } } DP\n\rclass Solution { public int numDecodings(String s) { s = \u0026#34;#\u0026#34; + s; int n = s.length(); // dp[i] = s[0]..s[i]解码方式  int[] dp = new int[n]; dp[0] = 1; dp[1] = (s.charAt(1) == \u0026#39;0\u0026#39;) ? 0 : 1; for (int i = 2; i \u0026lt; n; i++) { if (!isValid(s.charAt(i)) \u0026amp;\u0026amp; !isValid(s.charAt(i - 1), s.charAt(i))) { return 0; } if (isValid(s.charAt(i))) { dp[i] = dp[i - 1]; } if (isValid(s.charAt(i - 1), s.charAt(i))) { dp[i] += dp[i - 2]; } } return dp[n - 1]; } private boolean isValid(char c) { return \u0026#39;1\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } private boolean isValid(char a, char b) { int val = (a - \u0026#39;0\u0026#39;) * 10 + (b - \u0026#39;0\u0026#39;); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } } "},{"id":92,"href":"/docs/leetcode/hashtable/49/","title":"49th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String str : strs) { String oldStr = str; char[] chs = str.toCharArray(); Arrays.sort(chs); str = new String(chs); List\u0026lt;String\u0026gt; tmp = map.getOrDefault(str, null); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); map.put(str, tmp); } tmp.add(oldStr); } List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (var e : map.entrySet()) { res.add(e.getValue()); } return res; } "},{"id":93,"href":"/docs/leetcode/heap/1046/","title":"1046th","section":"Leet Code","content":" \rLink\n // Time Complexity: O(nlogn)  // Space Complexity: O(n)  public int lastStoneWeight(int[] stones) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() \u0026gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.poll(); } "},{"id":94,"href":"/docs/leetcode/heap/347/","title":"347th","section":"Leet Code","content":" \rLink\n public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() \u0026gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!pq.isEmpty()) { res[idx++] = pq.poll(); } return res; } "},{"id":95,"href":"/docs/leetcode/heap/451/","title":"451st","section":"Leet Code","content":" \rLink\n public String frequencySort(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue\u0026lt;Character\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i \u0026lt; n; i++) { sb.append(c); } } return sb.toString(); } "},{"id":96,"href":"/docs/leetcode/linkedlist/19/","title":"19th","section":"Leet Code","content":" \rLink\n public ListNode removeNthFromEnd(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; int n = 0; while (head != null) { n++; head = head.next; } ListNode prev = dummy; for (int i = 0; i \u0026lt; (n - k); i++) { prev = prev.next; } prev.next = prev.next.next; return dummy.next; } "},{"id":97,"href":"/docs/leetcode/linkedlist/2/","title":"2nd","section":"Leet Code","content":" \rLink\n public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode curr = dummy; int t = 0; while (l1 != null || l2 != null || t != 0) { if (l1 != null) { t += l1.val; l1 = l1.next; } if (l2 != null) { t += l2.val; l2 = l2.next; } curr.next = new ListNode(t % 10); t /= 10; curr = curr.next; } return dummy.next; } "},{"id":98,"href":"/docs/leetcode/linkedlist/21/","title":"21st","section":"Leet Code","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode prev = dummy; while (l1 != null \u0026amp;\u0026amp; l2 != null) { if (l1.val \u0026lt; l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } if (l1 != null) { prev.next = l1; } if (l2 != null) { prev.next = l2; } return dummy.next; } "},{"id":99,"href":"/docs/leetcode/linkedlist/23/","title":"23rd","section":"Leet Code","content":" \rLink\n class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode dummy = new ListNode(); PriorityQueue\u0026lt;ListNode\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); for (var l : lists) { if (l != null) { // 示例3 特例  minHeap.offer(l); } } ListNode tail = dummy; while (!minHeap.isEmpty()) { ListNode cur = minHeap.poll(); tail.next = cur; tail = tail.next; cur = cur.next; if (cur != null) { minHeap.offer(cur); } } return dummy.next; } } "},{"id":100,"href":"/docs/leetcode/linkedlist/24/","title":"24th","section":"Leet Code","content":" \rLink\n public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy; p.next != null \u0026amp;\u0026amp; p.next.next != null;) { ListNode a = p.next; ListNode b = p.next.next; p.next = b; a.next = b.next; b.next = a; p = a; } return dummy.next; } "},{"id":101,"href":"/docs/leetcode/linkedlist/25/","title":"25th","section":"Leet Code","content":" \rLink\n public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy;;) { int n = 0; for (ListNode t = p.next; t != null; t = t.next) { n++; } if (n \u0026lt; k) { break; } // 翻转k个节点  ListNode a = p.next, b = p.next.next; for (int i = 0; i \u0026lt; k - 1; i++) { var c = b.next; b.next = a; a = b; b = c; } var c = p.next; p.next = a; c.next = b; p = c; } return dummy.next; } "},{"id":102,"href":"/docs/leetcode/math/1979/","title":"1979th","section":"Leet Code","content":" \rLink\n public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a \u0026gt; b  private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); } "},{"id":103,"href":"/docs/leetcode/math/384/","title":"384th","section":"Leet Code","content":" \rLink\n 常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。\n第一轮：1/n\n第二轮：(n-1)/n * 1/(n-1)\n第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)\n…………\nprivate int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i \u0026lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; } "},{"id":104,"href":"/docs/leetcode/math/39/","title":"39th","section":"Leet Code","content":" \rLink\n List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList\u0026lt;\u0026gt;(), 0); return res; } private void dfs(int[] candidates, int target, List\u0026lt;Integer\u0026gt; cur, int s) { if (target \u0026lt; 0) { return; } if (target == 0) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = s; i \u0026lt; candidates.length; i++) { if (candidates[i] \u0026gt; target) break; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i); cur.remove(cur.size() - 1); } } "},{"id":105,"href":"/docs/leetcode/math/40/","title":"40th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList\u0026lt;\u0026gt;(), 0); return res; } private void dfs(int[] candidates, int target, List\u0026lt;Integer\u0026gt; cur, int s) { if (target == 0) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = s; i \u0026lt; candidates.length; i++) { if (candidates[i] \u0026gt; target) break; if (i \u0026gt; s \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) continue; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i + 1); cur.remove(cur.size() - 1); } } } "},{"id":106,"href":"/docs/leetcode/math/43/","title":"43rd","section":"Leet Code","content":" \rLink\n string multiply(string num1, string num2) { int n = num1.size(), m = num2.size(); vector\u0026lt;int\u0026gt; A, B; for (int i = n - 1; i \u0026gt;= 0; i--) A.push_back(num1[i] - \u0026#39;0\u0026#39;); for (int i = m - 1; i \u0026gt;= 0; i--) B.push_back(num2[i] - \u0026#39;0\u0026#39;); vector\u0026lt;int\u0026gt; C(n + m); for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) C[i + j] += A[i] * B[j]; for (int i = 0, t = 0; i \u0026lt; C.size(); i++) { t += C[i]; C[i] = t % 10; t /= 10; } int k = C.size() - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; C[k] == 0) k--; string res; while (k \u0026gt;= 0) res += (C[k--] + \u0026#39;0\u0026#39;); return res; } public String multiply(String num1, String num2) { int n = num1.length(), m = num2.length(); int[] A = new int[n]; int[] B = new int[m]; int idx = 0; for (int i = n - 1; i \u0026gt;= 0; i--) { A[idx++] = num1.charAt(i) - \u0026#39;0\u0026#39;; } idx = 0; for (int i = m - 1; i \u0026gt;= 0; i--) { B[idx++] = num2.charAt(i) - \u0026#39;0\u0026#39;; } int[] C = new int[n + m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { C[i + j] += A[i] * B[j]; } } for (int i = 0, t = 0; i \u0026lt; C.length; i++) { t += C[i]; C[i] = t % 10; t /= 10; } int k = C.length - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; C[k] == 0) k--; StringBuilder sb = new StringBuilder(); while (k \u0026gt;= 0) { sb.append(C[k--]); } return sb.toString(); } "},{"id":107,"href":"/docs/leetcode/math/46/","title":"46th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); boolean[] st; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { st = new boolean[nums.length]; dfs(new ArrayList\u0026lt;\u0026gt;(), nums); return res; } private void dfs(List\u0026lt;Integer\u0026gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (st[i]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } } "},{"id":108,"href":"/docs/leetcode/math/47/","title":"47th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); boolean[] st; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { Arrays.sort(nums); st = new boolean[nums.length]; dfs(new ArrayList\u0026lt;\u0026gt;(), nums); return res; } private void dfs(List\u0026lt;Integer\u0026gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (st[i]) continue; if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !st[i - 1]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } } "},{"id":109,"href":"/docs/leetcode/math/519/","title":"519th","section":"Leet Code","content":" \rLink\n class Solution { private int m; private int n; private int count; private Map\u0026lt;Integer, Integer\u0026gt; map; /** 转成一维数组 索引i 相当于=\u0026gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =\u0026gt; 5 =\u0026gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =\u0026gt; 6 =\u0026gt; 3 map[5] = 4 map[3] = map[4] = 5 ... ... */ public Solution(int m, int n) { this.m = m; this.n = n; this.count = 0; this.map = new HashMap\u0026lt;\u0026gt;(); } public int[] flip() { int k = (int)(Math.random() * (m * n - count)); int res = 0; if (map.get(k) == null) { res = k; } else { res = map.get(k); } int lastIdx = m * n - count - 1; if (map.get(lastIdx) != null) { map.put(k, map.get(lastIdx)); } else { map.put(k, lastIdx); } count++; return new int[]{res / n, res % n}; } public void reset() { map.clear(); count = 0; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(m, n); * int[] param_1 = obj.flip(); * obj.reset(); */ "},{"id":110,"href":"/docs/leetcode/math/812/","title":"812th","section":"Leet Code","content":" \rLink\n 看评论区都用线性代数，没学过线性代数的我，泪目了哭！\npublic double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i \u0026lt; points.length; i++) { for (int j = i + 1; j \u0026lt; points.length; j++) { for (int k = j + 1; k \u0026lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp \u0026gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b \u0026gt; c) || (a + c \u0026gt; b) || (b + c) \u0026gt; a; } // 果断找个公式，海伦公式  private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.sqrt(p * (p - a) * (p - b) * (p - c)); } private double length(int[] p1, int[] p2) { return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)); } "},{"id":111,"href":"/docs/leetcode/others/1/","title":"1st","section":"Leet Code","content":" \rLink\n public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int another = target - nums[i]; if (map.containsKey(another)) { return new int[]{i, map.get(another)}; } map.put(nums[i], i); } return null; } "},{"id":112,"href":"/docs/leetcode/others/1005/","title":"1005th","section":"Leet Code","content":" \rLink\n 写的实在是太丑陋了, 太多边界条件不易写\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // 最小\u0026gt;0的数索引  for (int n : nums) { if (n \u0026lt; 0) i++; else break; } int j = i - 1; // 最大负数索引  int negCount = i; int idx = negCount - i; while (k \u0026gt; 0) { if (negCount \u0026gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i \u0026lt; nums.length \u0026amp;\u0026amp; nums[i] == 0) break; if ( i \u0026gt;= nums.length || (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt; nums[j])) { nums[j] = -nums[j]; } else { nums[i] = -nums[i]; } } k--; } int sum = 0; for (int n : nums) { sum += n; } return sum; } } 优先队列解法(最小堆)\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int n : nums) { q.add(n); } while (k \u0026gt; 0) { q.add(0 - q.poll()); k--; } int sum = 0; while (!q.isEmpty()) { sum += q.poll(); } return sum; } } "},{"id":113,"href":"/docs/leetcode/others/22/","title":"22nd","section":"Leet Code","content":" \rLink\n class Solution { private List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; generateParenthesis(int n) { dfs(n, 0, 0, \u0026#34;\u0026#34;); return res; } private void dfs(int n, int open, int closed, String s) { if (open == n \u0026amp;\u0026amp; closed == n) { res.add(s); return; } if (open \u0026lt; n) { dfs(n, open + 1, closed, s + \u0026#34;(\u0026#34;); } if (closed \u0026lt; n \u0026amp;\u0026amp; closed \u0026lt; open) { dfs(n, open, closed + 1, s + \u0026#34;)\u0026#34;); } } } "},{"id":114,"href":"/docs/leetcode/others/29/","title":"29th","section":"Leet Code","content":" \rLink\n X / Y = K \u0026ndash;\u0026gt; X = YK \u0026ndash;\u0026gt; K假设K=(1110)2 则 X = Y * 2^3 + Y * 2^2 + Y * 2^1 即logK个数相加\nclass Solution { public int divide(int dividend, int divisor) { int flag = 1; if (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) { flag = -1; } long a = Math.abs((long)dividend), b = Math.abs((long)divisor); List\u0026lt;Long\u0026gt; exp = new ArrayList\u0026lt;\u0026gt;(); for (long i = b; i \u0026lt;= a; i += i) { exp.add(i); } long res = 0; for (int i = exp.size() - 1; i \u0026gt;= 0; i--) { if (a \u0026gt;= exp.get(i)) { a -= exp.get(i); res += 1L \u0026lt;\u0026lt; i; } } res *= flag; if (res \u0026gt; Integer.MAX_VALUE || res \u0026lt; Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return (int)res; } } "},{"id":115,"href":"/docs/leetcode/others/31/","title":"31st","section":"Leet Code","content":" \rLink\n class Solution { // 从前往后找第一次降序的位置k  // 从k开始找较k-1大的数，交换  // 反转(k, end)  public void nextPermutation(int[] nums) { int n = nums.length; int k = n - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k - 1] \u0026gt;= nums[k]) k--; if (k \u0026lt;= 0) { reverse(nums, 0, n - 1); } else { int t = k; while (t \u0026lt; n \u0026amp;\u0026amp; nums[t] \u0026gt; nums[k - 1]) t++; swap(nums, k - 1, t - 1); reverse(nums, k, n - 1); } } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } // [begin, end]  private void reverse(int[] nums, int begin, int end) { for (int i = 0; i \u0026lt; (end - begin + 1) / 2; i++) { swap(nums, begin + i, end - i); } } } "},{"id":116,"href":"/docs/leetcode/others/36/","title":"36th","section":"Leet Code","content":" \rLink\n class Solution { public boolean isValidSudoku(char[][] board) { boolean[] st = new boolean[10]; // 判断行  for (int i = 0; i \u0026lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } // 判断列  for (int i = 0; i \u0026lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j \u0026lt; 9; j++) { if (board[j][i] != \u0026#39;.\u0026#39;) { int t = board[j][i] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } // 判断小方格  for (int i = 0; i \u0026lt; 9; i += 3) { for (int j = 0; j \u0026lt; 9; j += 3) { Arrays.fill(st, false); for (int x = 0; x \u0026lt; 3; x++) { for (int y = 0; y \u0026lt; 3; y++) { if (board[x + i][y + j] != \u0026#39;.\u0026#39;) { int t = board[x + i][y + j] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } } } return true; } } "},{"id":117,"href":"/docs/leetcode/others/37/","title":"37th","section":"Leet Code","content":" \rLink\n class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init  for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;1\u0026#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] != \u0026#39;.\u0026#39;) return dfs(board, x, y + 1); for (int i = 0; i \u0026lt; 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x / 3][y / 3][i]) { board[x][y] = (char)(i + \u0026#39;1\u0026#39;); row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if (dfs(board, x, y + 1)) { return true; } board[x][y] = \u0026#39;.\u0026#39;; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; } } "},{"id":118,"href":"/docs/leetcode/others/383/","title":"383rd","section":"Leet Code","content":" \rLink\n class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - \u0026#39;a\u0026#39;] \u0026lt;= 0) return false; count[c - \u0026#39;a\u0026#39;]--; } return true; } } "},{"id":119,"href":"/docs/leetcode/others/48/","title":"48th","section":"Leet Code","content":" \rLink\n public void rotate(int[][] matrix) { int n = matrix.length; // 沿着对角线翻转  for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } // 沿着中心列翻转  for (int row = 0; row \u0026lt; n; row++) { for (int i = 0, j = n - 1; i \u0026lt; j; i++, j--) { int tmp = matrix[row][i]; matrix[row][i] = matrix[row][j]; matrix[row][j] = tmp; } } } "},{"id":120,"href":"/docs/leetcode/others/50/","title":"50th","section":"Leet Code","content":" \rLink\n public double myPow(double x, int n) { boolean isMinus = false; if (n \u0026lt; 0) { isMinus = true; } double res = 1; for (long k = (long)Math.abs((long)n); k != 0; k \u0026gt;\u0026gt;= 1) { if ((k \u0026amp; 0x1) == 0x1) { res *= x; } x *= x; } if (isMinus) { return 1 / res; } else { return res; } } "},{"id":121,"href":"/docs/leetcode/others/5963/","title":"5963rd","section":"Leet Code","content":" TODO: Link\n class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i) == \u0026#39;0\u0026#39;) { i--; } for ( ; i \u0026gt;= 0; i--) { sb.append(s.charAt(i)); } return sb.toString(); } } "},{"id":122,"href":"/docs/leetcode/others/5965/","title":"5965th","section":"Leet Code","content":" TODO: Link\n 稍微优化下还是超时，放弃\nclass Solution { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // if (i == begin) continue;  if (arr[begin] == arr[i]) { list.add(i); } } map.put(arr[begin], list); System.out.println(1); } else { System.out.println(2); } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } 超时\nclass Solution { public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (i == begin) continue; if (arr[begin] == arr[i]) { list.add(i); } } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } ``"},{"id":123,"href":"/docs/leetcode/others/5967/","title":"5967th","section":"Leet Code","content":" \rLink\n public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i \u0026lt; chs.length; i++) { if (chs[i] == \u0026#39;a\u0026#39;) { x = i; } else if (y == -1 \u0026amp;\u0026amp; chs[i] == \u0026#39;b\u0026#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x \u0026lt; y; } "},{"id":124,"href":"/docs/leetcode/others/5968/","title":"5968th","section":"Leet Code","content":" \rLink\n class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i \u0026lt; m - 1; i++) { if (!bank[i].contains(\u0026#34;1\u0026#34;)) { continue; } int t = calculate(bank, i); // 计算这一行符合的激光束数量  if (t \u0026gt; 0) { // update result  for (int j = 0; j \u0026lt; n; j++) { if (bank[i].charAt(j) == \u0026#39;1\u0026#39;) { res += t; } } } } return res; } private int calculate(String[] bank, int start) { int end = start; for (int i = end + 1; i \u0026lt; m; i++) { if (bank[i].contains(\u0026#34;1\u0026#34;)) { end = i; break; } } int result = 0; if (end != start) { for (int i = 0; i \u0026lt; n; i++) { if (bank[end].charAt(i) == \u0026#39;1\u0026#39;) { result++; } } } return result; } } "},{"id":125,"href":"/docs/leetcode/others/5969/","title":"5969th","section":"Leet Code","content":" [Link]\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t \u0026lt; a) { return false; } else { t += a; } } return true; } } "},{"id":126,"href":"/docs/leetcode/others/7/","title":"7th","section":"Leet Code","content":" \rLink\n public int reverse(int x) { // java 这里-11 % 10 = -1 数学上应该是 9  int flag = 1; if (x \u0026lt; 0) { flag = -1; x = -x; } int res = 0; while (x != 0) { if (res \u0026gt; ((Integer.MAX_VALUE - (x % 10)) / 10)) { return 0; } res = res * 10 + (x % 10); x /= 10; } return res * flag; } "},{"id":127,"href":"/docs/leetcode/others/748/","title":"748th","section":"Leet Code","content":" \rLink\n public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = \u0026#34;\u0026#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) \u0026amp;\u0026amp; word.length() \u0026lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i \u0026lt; a1.length; i++) { if (a1[i] \u0026gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.toCharArray()) { if (Character.isLetter(c)) { c = Character.toUpperCase(c); tmp[c - \u0026#39;A\u0026#39;]++; } } return tmp; } "},{"id":128,"href":"/docs/leetcode/others/9/","title":"9th","section":"Leet Code","content":" \rLink\n public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int y = x; int res = 0; while (x \u0026gt; 0) { res = res * 10 + (x % 10); x /= 10; } return res == y; } public boolean isPalindrome(int x) { String s = String.valueOf(x); return s.equals(new StringBuilder(s).reverse().toString()); } "},{"id":129,"href":"/docs/leetcode/recursion/1492/","title":"1492nd","section":"Leet Code","content":" \rLink\n public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f \u0026gt;= n \u0026amp;\u0026amp; k \u0026gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); } "},{"id":130,"href":"/docs/leetcode/simulation/12/","title":"12th","section":"Leet Code","content":" \rLink\n public String intToRoman(int num) { int[] values = new int[]{ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; String[] chs = new String[]{ \u0026#34;I\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;M\u0026#34; }; StringBuilder sb = new StringBuilder(); for (int i = values.length - 1; i \u0026gt;= 0; i--) { while (num \u0026gt;= values[i]) { num -= values[i]; sb.append(chs[i]); } } return sb.toString(); } "},{"id":131,"href":"/docs/leetcode/simulation/13/","title":"13th","section":"Leet Code","content":" \rLink\n public int romanToInt(String s) { Map\u0026lt;Character, Integer\u0026gt; hash = new HashMap\u0026lt;\u0026gt;(); hash.put(\u0026#39;I\u0026#39;, 1); hash.put(\u0026#39;V\u0026#39;, 5); hash.put(\u0026#39;X\u0026#39;, 10); hash.put(\u0026#39;L\u0026#39;, 50); hash.put(\u0026#39;C\u0026#39;, 100); hash.put(\u0026#39;D\u0026#39;, 500); hash.put(\u0026#39;M\u0026#39;, 1000); int res = 0; int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (i + 1 \u0026lt; n \u0026amp;\u0026amp; hash.get(s.charAt(i)) \u0026lt; hash.get(s.charAt(i + 1))) { res = res + (-hash.get(s.charAt(i))); } else { res = res + hash.get(s.charAt(i)); } } return res; } "},{"id":132,"href":"/docs/leetcode/simulation/38/","title":"38th","section":"Leet Code","content":" \rLink\n public String countAndSay(int n) { String res = \u0026#34;1\u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { StringBuilder t = new StringBuilder(); int m = res.length(); for (int j = 0; j \u0026lt; m; ) { int k = j + 1; while (k \u0026lt; m \u0026amp;\u0026amp; res.charAt(j) == res.charAt(k)) k++; t.append(k - j).append(res.charAt(j)); j = k; } res = t.toString(); } return res; } "},{"id":133,"href":"/docs/leetcode/sorts/215/","title":"215th","section":"Leet Code","content":" \rLink\n 使用优先队列\n// Time Complexity: O(nlgn)  // Space Complexity: O(k)  public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int num : nums) { if (q.size() == k) { if (num \u0026gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); } "},{"id":134,"href":"/docs/leetcode/sorts/41/","title":"41st","section":"Leet Code","content":" \rLink\n class Solution { public int firstMissingPositive(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { while (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] != i + 1 \u0026amp;\u0026amp; nums[i] \u0026lt;= nums.length \u0026amp;\u0026amp; nums[i] != nums[nums[i] - 1]) { int tmp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = tmp; } } for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != i + 1) { return i + 1; } } return nums.length + 1; } } "},{"id":135,"href":"/docs/leetcode/stack/20/","title":"20th","section":"Leet Code","content":" \rLink\n 查阅Ascii码表进行简化\npublic boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); } else { if (st.size() \u0026gt; 0 \u0026amp;\u0026amp; Math.abs(st.peek() - s.charAt(i)) \u0026lt;= 2) { st.pop(); } else { return false; } } } return st.size() == 0; } public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); continue; } if (st.size() == 0 || (s.charAt(i) == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;(\u0026#39;) || (s.charAt(i) == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;[\u0026#39;) || (s.charAt(i) == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;{\u0026#39;)) { return false; } st.pop(); } return st.size() == 0; } "},{"id":136,"href":"/docs/leetcode/stack/32/","title":"32nd","section":"Leet Code","content":" \rLink\n public int longestValidParentheses(String s) { Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); int result = 0; for (int i = 0, start = -1; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { st.push(i); } else { if (st.isEmpty()) { start = i; } else { st.pop(); if (st.isEmpty()) { result = Math.max(result, i - start); } else { result = Math.max(result, i - st.peek()); } } } } return result; } "},{"id":137,"href":"/docs/leetcode/stack/42/","title":"42nd","section":"Leet Code","content":" \rLink\n \r\rDetail\npublic int trap(int[] height) { Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int ans = 0; for (int i = 0; i \u0026lt; height.length; i++) { while (!st.isEmpty() \u0026amp;\u0026amp; height[st.peek()] \u0026lt; height[i]) { int cur = st.pop(); if (st.isEmpty()) break; int l = st.peek(); int r = i; int h = Math.min(height[l], height[r]) - height[cur]; ans += (r - l - 1) * h; } st.push(i); } return ans; } "},{"id":138,"href":"/docs/leetcode/string/14/","title":"14th","section":"Leet Code","content":" \rLink\n public String longestCommonPrefix(String[] strs) { StringBuilder sb = new StringBuilder(); int n = strs[0].length(); for (int i = 0; i \u0026lt; n; i++) { char c = strs[0].charAt(i); for (int j = 1; j \u0026lt; strs.length; j++) { if (i \u0026gt;= strs[j].length() || c != strs[j].charAt(i)) { return sb.toString(); } } sb.append(c); } return sb.toString(); } "},{"id":139,"href":"/docs/leetcode/string/28/","title":"28th","section":"Leet Code","content":" \rLink\n public int strStr(String s, String p) { int m = p.length(); if (m == 0) return 0; int n = s.length(); s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; int[] next = new int[m + 1]; for (int i = 2, j = 0; i \u0026lt;= m; i++) { while (j != 0 \u0026amp;\u0026amp; p.charAt(i) != p.charAt(j + 1)) j = next[j]; if ( p.charAt(i) == p.charAt(j + 1)) j++; next[i] = j; } // 匹配  for (int i = 1, j = 0; i \u0026lt;= n; i++) { while (j != 0 \u0026amp;\u0026amp; s.charAt(i) != p.charAt(j + 1)) j = next[j]; if (s.charAt(i) == p.charAt(j + 1)) j++; if (j == m) return i - m; } return -1; } "},{"id":140,"href":"/docs/leetcode/string/5/","title":"5th","section":"Leet Code","content":" \rLink\n public String longestPalindrome(String s) { int n = s.length(); String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { int l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } l = i; r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } } return res; } "},{"id":141,"href":"/docs/leetcode/string/6/","title":"6th","section":"Leet Code","content":" \rLink\n 转成索引排列，找出规律\npublic String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; numRows; i++) { if (i == 0 || i == numRows - 1) { for (int j = i; j \u0026lt; n; j += 2 * numRows - 2) { sb.append(s.charAt(j)); } } else { for (int j = i, k = 2 * numRows - 2 - i; j \u0026lt; n || k \u0026lt; n; j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j \u0026lt; n) { sb.append(s.charAt(j)); } if (k \u0026lt; n) { sb.append(s.charAt(k)); } } } } return sb.toString(); } "},{"id":142,"href":"/docs/leetcode/string/8/","title":"8th","section":"Leet Code","content":" \rLink\n class Solution { public int myAtoi(String s) { int k = 0; int n = s.length(); while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) == \u0026#39; \u0026#39;) { k++; } if (k == n) { return 0; } int minus = 1; if (s.charAt(k) == \u0026#39;-\u0026#39;) { minus = -1; k++; } else if (s.charAt(k) == \u0026#39;+\u0026#39;) { k++; } int res = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s.charAt(k) \u0026lt;= \u0026#39;9\u0026#39;) { int x = s.charAt(k) - \u0026#39;0\u0026#39;; if (minus \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (Integer.MAX_VALUE - x) / 10) { return Integer.MAX_VALUE; } if (minus \u0026lt; 0 \u0026amp;\u0026amp; -res \u0026lt; (Integer.MIN_VALUE + x) / 10) { return Integer.MIN_VALUE; } if (-res * 10 - x == Integer.MIN_VALUE) { return Integer.MIN_VALUE; } res = res * 10 + x; k++; } res *= minus; return res; } } "},{"id":143,"href":"/docs/leetcode/tips/","title":"Tips","section":"Leet Code","content":"摩尔投票算法\r#\r\r/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */ "},{"id":144,"href":"/docs/leetcode/tree/102/","title":"102nd","section":"Leet Code","content":" \rLink\n 考虑当前层结束条件，即当前队列中的元素个数。\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); int count = q.size(); while (count \u0026gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; } "},{"id":145,"href":"/docs/leetcode/tree/559/","title":"559th","section":"Leet Code","content":" \rLink 一道简单的搜索\n public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i \u0026lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; } "},{"id":146,"href":"/docs/leetcode/tree/700/","title":"700th","section":"Leet Code","content":" \rLink\n 递归搜索\nclass Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val \u0026gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } } "},{"id":147,"href":"/docs/leetcode/twopointers/11/","title":"11th","section":"Leet Code","content":" \rLink\n public int maxArea(int[] height) { int res = 0; for (int i = 0, j = height.length - 1; i \u0026lt; j; ) { res = Math.max(res, Math.min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) { i++; } else { j--; } } return res; } "},{"id":148,"href":"/docs/leetcode/twopointers/15/","title":"15th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) { // 找靠近左边第一个\u0026gt;=的k索引  k--; } if (nums[i] + nums[j] + nums[k] == 0) { res.add(List.of(nums[i], nums[j], nums[k])); } } } return res; } "},{"id":149,"href":"/docs/leetcode/twopointers/16/","title":"16th","section":"Leet Code","content":" \rLink\n public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { int j = i + 1, k = nums.length - 1; while (j \u0026lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum \u0026gt; target) { k--; } else { j++; } if (Math.abs(target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } return res; } public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) { k--; } int sum = nums[i] + nums[j] + nums[k]; // 靠近左边第一个\u0026gt;=target的k  if (Math.abs(sum - target) \u0026lt; Math.abs(target - res)) { res = sum; } if (k - 1 \u0026gt; j) { sum = nums[i] + nums[j] + nums[k - 1]; // \u0026lt; target  if ((target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } } return res; } `` "},{"id":150,"href":"/docs/leetcode/twopointers/18/","title":"18th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } for (int k = j + 1, u = n - 1; k \u0026lt; u; k++) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { continue; } while (k \u0026lt; u - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k] + nums[u - 1] \u0026gt;= target) { u--; } if (nums[i] + nums[j] + nums[k] + nums[u] == target) { res.add(List.of(nums[i], nums[j], nums[k], nums[u])); } } } } return res; } "},{"id":151,"href":"/docs/leetcode/twopointers/26/","title":"26th","section":"Leet Code","content":" \rLink\n public int removeDuplicates(int[] nums) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i == 0 || nums[i] != nums[i - 1]) { nums[j++] = nums[i]; } } return j; } "},{"id":152,"href":"/docs/leetcode/twopointers/27/","title":"27th","section":"Leet Code","content":" \rLink\n public int removeElement(int[] nums, int val) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[j++] = nums[i]; } } return j; } "},{"id":153,"href":"/docs/leetcode/twopointers/3/","title":"3rd","section":"Leet Code","content":" \rLink\n int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;char, int\u0026gt; map{}; int res = 0; int n = s.length(); int j = 0; for (int i = 0; i \u0026lt; n; i++) { map[s[i]]++; if (map[s[i]] \u0026gt; 1) { while (map[s[i]] \u0026gt; 1) { map[s[j++]]--; } } res = max(res, i - j + 1); } return res; } public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int res = 0; int n = s.length(); for (int i = 0, j = 0; i \u0026lt; n; i++) { map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1); if (map.get(s.charAt(i)) == 1) { res = Math.max(res, i - j + 1); continue; } while (map.get(s.charAt(i)) \u0026gt; 1) { map.put(s.charAt(j), map.get(s.charAt(j)) - 1); j++; } } return res; } "},{"id":154,"href":"/docs/leetcode/twopointers/30/","title":"30th","section":"Leet Code","content":" \rLink\n 滑动窗口 + Hash\npublic List\u0026lt;Integer\u0026gt; findSubstring(String s, String[] words) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = s.length(), m = words.length; if (m == 0) { return res; } int w = words[0].length(); Map\u0026lt;String, Integer\u0026gt; tot = new HashMap\u0026lt;\u0026gt;(); for (String word : words) tot.put(word, tot.getOrDefault(word, 0) + 1); for (int i = 0; i \u0026lt; w; i++) { Map\u0026lt;String, Integer\u0026gt; wd = new HashMap\u0026lt;\u0026gt;(); int cnt = 0; for (int j = i; j + w \u0026lt;= n; j += w) { if (j \u0026gt;= i + m * w) { String word = s.substring(j - m * w, j - (m - 1) * w); wd.put(word, wd.get(word) - 1); if (tot.containsKey(word) \u0026amp;\u0026amp; wd.get(word) \u0026lt; tot.get(word)) cnt--; } String word = s.substring(j, j + w); wd.put(word, wd.getOrDefault(word, 0) + 1); if (tot.containsKey(word) \u0026amp;\u0026amp; wd.get(word) \u0026lt;= tot.get(word)) cnt++; if (cnt == m) res.add(j - (m - 1) * w); } } return res; } "},{"id":155,"href":"/docs/leetcode/twopointers/4/","title":"4th","section":"Leet Code","content":" \rLink\n public double findMedianSortedArrays(int[] nums1, int[] nums2) { int k = nums1.length + nums2.length; if (k % 2 == 0) { int left = findKth(nums1, 0, nums2, 0, k / 2); int right = findKth(nums1, 0, nums2, 0, k / 2 + 1); return (left + right) / 2.0; } else { return findKth(nums1, 0, nums2, 0, k / 2 + 1); } } // 二分做法  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { if (nums1.length - i \u0026gt; nums2.length - j) { return findKth(nums2, j, nums1, i, k); } if (nums1.length == i) { return nums2[j + k - 1]; } if (k == 1) { return Math.min(nums1[i], nums2[j]); } int k1 = Math.min(nums1.length - i, k / 2); int k2 = k - k1; if (nums1[i + k1 - 1] \u0026lt; nums2[j + k2 - 1]) { return findKth(nums1, i + k1, nums2, j, k - k1); } else { return findKth(nums1, i, nums2, j + k2, k - k2); } } //优先队列做法  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); while (i \u0026lt; nums1.length) { pq.offer(nums1[i++]); } while (j \u0026lt; nums2.length) { pq.offer(nums2[j++]); } int res = 0; while (k-- \u0026gt; 0) { res = pq.poll(); } return res; } "},{"id":156,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/","title":"剑指 Offer","section":"Leet Code","content":" \r剑指 Offer 03. 数组中重复的数字(E) \r14. 不修改数组找出重复的数字(E) \r剑指 Offer 04. 二维数组中的查找(M) \r剑指 Offer 05. 替换空格(E) \r剑指 Offer 50. 第一个只出现一次的字符(E) \r剑指 Offer 32 - I. 从上到下打印二叉树(M) \r剑指 Offer 32 - II. 从上到下打印二叉树 II(E) \r剑指 Offer 32 - III. 从上到下打印二叉树 III(M) \r剑指 Offer 47. 礼物的最大价值(M) \r剑指 Offer 26. 树的子结构(M) \r剑指 Offer 18. 删除链表的节点(E) \r剑指 Offer 22. 链表中倒数第k个节点(E) \r剑指 Offer 48. 最长不含重复字符的子字符串(M) \r剑指 Offer 46. 把数字翻译成字符串(M) \r剑指 Offer 25. 合并两个排序的链表(M) \r剑指 Offer 57. 和为s的两个数字(E) \r剑指 Offer 21. 调整数组顺序使奇数位于偶数前面(E) \r剑指 Offer 58 - I. 翻转单词顺序(E) \r剑指 Offer 13. 机器人的运动范围(M) \r剑指 Offer 12. 矩阵中的路径(M) \r剑指 Offer 64. 求1+2+…+n(M) \r剑指 Offer 54. 二叉搜索树的第k大节点(M) \r剑指 Offer 55 - I. 二叉树的深度(E) \r剑指 Offer 55 - II. 平衡二叉树(E) \r剑指 Offer 68 - I. 二叉搜索树的最近公共祖先(E) \r剑指 Offer 68 - II. 二叉树的最近公共祖先(E) \r剑指 Offer 15. 二进制中1的个数(E)  "},{"id":157,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/","title":"6th","section":"剑指 Offer","content":" \rLink\n vector\u0026lt;int\u0026gt; reversePrint(ListNode* head) { vector\u0026lt;int\u0026gt; res; while (head) { res.push_back(head-\u0026gt;val); head = head-\u0026gt;next; } return vector\u0026lt;int\u0026gt;(res.rbegin(), res.rend()); } public int[] reversePrint(ListNode head) { Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head.val); head = head.next; } int[] res = new int[s.size()]; int idx = 0; while (!s.isEmpty()) { res[idx++] = s.pop(); } return res; } "},{"id":158,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/","title":"3rd","section":"剑指 Offer","content":" \rLink\n 将元素放置到对应的位置。2代表下标为2的位置\nint findRepeatNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { while (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] != nums[i]) { swap(nums[i], nums[nums[i]]); } if (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] == nums[i]) { return nums[i]; } } return -1; } "},{"id":159,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/","title":"4th","section":"剑指 Offer","content":" \rLink\n \r上图是从右上角，同理左下角\n从右上角看成一个二分搜索树\nbool searchArray(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; array, int target) { if (array.size() == 0) { return false; } int m = array.size(); int n = array[0].size(); int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (array[i][j] == target) { return true; } else if (array[i][j] \u0026lt; target) { i++; } else { j--; } } return false; } public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] \u0026lt; target) { col++; } else { row--; } } return false; } "},{"id":160,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/","title":"5th","section":"剑指 Offer","content":" \rLink\n C语言需要注意内存分配，先求出空格数量，在计算出需要的内存大小。\npublic String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39; \u0026#39;) { sb.append(\u0026#34;%20\u0026#34;); } else { sb.append(s.charAt(i)); } } return sb.toString(); } "},{"id":161,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/","title":"12th","section":"剑指 Offer","content":" \rLink\n public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || board[i][j] != word.charAt(idx)) { return false; } if (idx == word.length() - 1) { return true; } board[i][j] = \u0026#39;0\u0026#39;; boolean res = search(board, word, idx + 1, i + 1, j) || search(board, word, idx + 1, i - 1, j) || search(board, word, idx + 1, i, j + 1) || search(board, word, idx + 1, i, j - 1); board[i][j] = word.charAt(idx); return res; } 菜写法，超时\nclass Solution { private int m; private int n; private char[][] board; private String word; private boolean[][] visited; public boolean exist(char[][] board, String word) { this.m = board.length; this.n = board[0].length; this.visited = new boolean[m][n]; this.board = board; this.word = word; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dfs(sb, i, j)) return true; } } return false; } private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; private boolean dfs(StringBuilder cur, int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n) { return false; } if (visited[x][y]) { return false; } cur.append(board[x][y]); visited[x][y] = true; int cmp = cur.length() - word.length(); if (cmp == 0 \u0026amp;\u0026amp; word.equals(cur.toString())) { return true; } else if (cmp \u0026lt; 0) { for (int i = 0; i \u0026lt; 4; i++) { int tmpX = x + dirs[i][0]; int tmpY = y + dirs[i][1]; if (dfs(cur, tmpX, tmpY)) return true; } } visited[x][y] = false; cur.deleteCharAt(cur.length() - 1); return false; } } "},{"id":162,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/","title":"13th","section":"剑指 Offer","content":" \rLink\n 简单DFS\nclass Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x \u0026gt;= m || x \u0026lt; 0 || y \u0026gt;= n || y \u0026lt; 0) return 0; if (visited[x][y] || !isValid(x, y)) { return 0; } visited[x][y] = true; return 1 + dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1); } private boolean isValid(int x, int y) { int val = 0; while (x \u0026gt; 0) { val += (x % 10); x /= 10; } while (y \u0026gt; 0) { val += (y % 10); y /= 10; } return val \u0026lt;= k; } } "},{"id":163,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/","title":"15th","section":"剑指 Offer","content":" \rLink\n public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;\u0026gt;= 1; } return res; } "},{"id":164,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/","title":"18th","section":"剑指 Offer","content":" \rLink\n class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } } "},{"id":165,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/","title":"21st","section":"剑指 Offer","content":" \rLink\n public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i \u0026lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; } "},{"id":166,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/","title":"22nd","section":"剑指 Offer","content":" \rLink\n public ListNode getKthFromEnd(ListNode head, int k) { Stack\u0026lt;ListNode\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head); head = head.next; } if (k \u0026gt; s.size()) return null; ListNode res = null; while (k \u0026gt; 0) { k--; res = s.pop(); } return res; } "},{"id":167,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/","title":"25th","section":"剑指 Offer","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null \u0026amp;\u0026amp; cur2 != null) { if (cur1.val \u0026lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.next; } "},{"id":168,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/","title":"26th","section":"剑指 Offer","content":" \rLink\n class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) \u0026amp;\u0026amp; help(A.right, B.right); } } "},{"id":169,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/","title":"32 1","section":"剑指 Offer","content":" \rLink\n class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } } "},{"id":170,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/","title":"32 2","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null]  while (q.peek() != null) { TreeNode node; List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); } res.add(tmp); q.offer(null); } return res; } } "},{"id":171,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/","title":"32 3","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList\u0026lt;Integer\u0026gt; tmp = new LinkedList\u0026lt;\u0026gt;(); int n = res.size(); for (int i = q.size(); i \u0026gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } res.add(tmp); } return res; } } "},{"id":172,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/","title":"46th","section":"剑指 Offer","content":" \rLink\n DFS\npublic int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start \u0026gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - \u0026#39;0\u0026#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start \u0026lt; str.length() - 1) { // 06  if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - \u0026#39;0\u0026#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25; } 动态规划\npublic int translateNum(int num) { String str = String.valueOf(num); int n = str.length(); // 以i为结尾 不同翻译数  int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1]; int val = (str.charAt(i - 2) - \u0026#39;0\u0026#39;) * 10 + (str.charAt(i - 1) - \u0026#39;0\u0026#39;); if (10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25) { dp[i] = (dp[i - 2] + dp[i - 1]); } } return dp[n]; } "},{"id":173,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/","title":"47th","section":"剑指 Offer","content":" \rLink\n class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } } "},{"id":174,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/","title":"48th","section":"剑指 Offer","content":" \rLink\n 双指针\npublic int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (j \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; } "},{"id":175,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/","title":"50th","section":"剑指 Offer","content":" \rLink\n class Solution { public char firstUniqChar(String s) { Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - \u0026#39;a\u0026#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return \u0026#39; \u0026#39;; } } "},{"id":176,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/","title":"54th","section":"剑指 Offer","content":" \rLink\n DFS\nprivate int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack\npublic int kthLargest(TreeNode root, int k) { Queue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (q.size() \u0026lt; k) { q.offer(node.val); } else if (q.peek() \u0026lt; node.val) { q.poll(); q.offer(node.val); } if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } return q.peek(); } "},{"id":177,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/","title":"55 1","section":"剑指 Offer","content":" \rLink\n public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } "},{"id":178,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/","title":"55 2","section":"剑指 Offer","content":" \rLink\n public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) \u0026lt; 2 \u0026amp;\u0026amp; (isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; } "},{"id":179,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/","title":"57th","section":"剑指 Offer","content":" \rLink\n public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i \u0026lt; j) { if (nums[i] + nums[j] \u0026lt; target) { i++; } else if (nums[i] + nums[j] \u0026gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; } "},{"id":180,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/","title":"58th","section":"剑指 Offer","content":" \rLink\n public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i \u0026gt;= 0) { while(i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] != \u0026#39; \u0026#39;) i--; sb.append(s.substring(i + 1, j + 1) + \u0026#34; \u0026#34;); while (i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] == \u0026#39; \u0026#39;) i--; j = i; } return sb.toString().trim(); } "},{"id":181,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/","title":"64th","section":"剑指 Offer","content":" \rLink\n public int sumNums(int n) { boolean tmp = n \u0026gt; 1 \u0026amp;\u0026amp; (n += sumNums(n - 1)) \u0026gt; 0; return n; } "},{"id":182,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/","title":"68 1","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } } "},{"id":183,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/","title":"68 2","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left == null ? right : left; } 任意k个数的最近公共祖先\nprivate int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.val == p.val || node.val == q.val) { k--; } dfs(node.left, p, q); dfs(node.right, p, q); if (oldK == 2 \u0026amp;\u0026amp; k == 0 \u0026amp;\u0026amp; res == null) { res = node; } } "},{"id":184,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/","title":"A14","section":"剑指 Offer","content":" \rLink\n 通过二分查找，判断左右区间的个数\nint duplicateInArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 1, r = nums.size() - 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int cnt = 0; for (auto x : nums) { if (x \u0026gt;= l \u0026amp;\u0026amp; x \u0026lt;= mid) { cnt++; } } if (cnt \u0026gt; mid - l + 1) { r = mid; } else { l = mid + 1; } } return l; } "},{"id":185,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"面试题","section":"Leet Code","content":" \r面试题 08.05. 递归乘法(M)  "},{"id":186,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/","title":"805th","section":"面试题","content":" \rLink\n public int multiply(int A, int B) { if (B == 0) return 0; else if (B == 1) return A; else return A + multiply(A, B - 1); } "},{"id":187,"href":"/posts/test/test/","title":"Test","section":"Blog","content":"Test\n"},{"id":188,"href":"/posts/2022/","title":"关于我的2022的一些记录","section":"Blog","content":"收藏的播客\r#\r\r   播客名称 添加日期 type 备注     \rHappy Path Programming 2022.02.19      收藏的博客\r#\r\r   博客名称 添加日期 type 备注     \rcodedump的网络日志 2022.02.17 系统知识 宝藏   \r程序员的喵 2022.02.18 成长     收藏的文章\r#\r\r   文章名称 添加日期 type 备注     - 我在职业生涯中学到的所有良好实践 2022.02.06 技术文章 宝藏   - 聊聊微软面试 2022.02.18 面试 宝藏   - Raft 分布式共识算法动画演示 2022.03.02      "}]