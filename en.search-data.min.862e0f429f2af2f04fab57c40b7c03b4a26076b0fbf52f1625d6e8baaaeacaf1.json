[{"id":0,"href":"/docs/acwing/","title":"Acwing","section":"Docs","content":" \r786. ç¬¬kä¸ªæ•° \r788. æ±‚é€†åºå¯¹çš„ä¸ªæ•° \r790. æ•°çš„ä¸‰æ¬¡æ–¹æ ¹ \r791. é«˜ç²¾åº¦åŠ æ³• \r792. é«˜ç²¾åº¦å‡æ³• \r793. é«˜ç²¾åº¦ä¹˜æ³• \r794. é«˜ç²¾åº¦é™¤æ³• \r795. å‰ç¼€å’Œ \r796. å­çŸ©é˜µçš„å’Œ \r797. å·®åˆ† \r798. å·®åˆ†çŸ©é˜µ \r799. æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ— \r801. äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•° \r802. åŒºé—´å’Œ \r803. åŒºé—´åˆå¹¶ \r826. å•é“¾è¡¨ \r827. åŒé“¾è¡¨ \r830. å•è°ƒæ ˆ \r154. æ»‘åŠ¨çª—å£ \r831. KMPå­—ç¬¦ä¸² \r835. Trieå­—ç¬¦ä¸²ç»Ÿè®¡ \r143. æœ€å¤§å¼‚æˆ–å¯¹ \r836. åˆå¹¶é›†åˆ \r838. å †æ’åº \r840. æ¨¡æ‹Ÿæ•£åˆ—è¡¨  "},{"id":1,"href":"/docs/acwing/basic/143/","title":"143rd","section":"Acwing","content":" \rLink\n "},{"id":2,"href":"/docs/acwing/basic/154/","title":"154th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n, k; int a[N], q[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i++) { // åˆ¤æ–­å¹¶æ›´æ–°çª—å£  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; q[++tt] = i; if (i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i++) { // åˆ¤æ–­å¹¶æ›´æ–°çª—å£  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt--; q[++tt] = i; if (i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } "},{"id":3,"href":"/docs/acwing/basic/786/","title":"786th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int q[100001]; int quick_sort(int l, int r, int k) { if (l == r) { return q[l]; } int x = q[l], i = l - 1, j = r + 1; while (i \u0026lt; j) { while (q[++i] \u0026lt; x); while (q[--j] \u0026gt; x); if (i \u0026lt; j) { swap(q[i], q[j]); } } int sl = j - l + 1; if (k \u0026lt;= sl) return quick_sort(l, j, k); return quick_sort(j + 1, r, k - sl); } int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; q[i]; } cout \u0026lt;\u0026lt; quick_sort(0, n - 1, k); return 0; } "},{"id":4,"href":"/docs/acwing/basic/788/","title":"788th","section":"Acwing","content":" \rLink\n class Solution { private int[] tmp; public int reversePairs(int[] nums) { tmp = new int[nums.length]; return mergeSort(nums, 0, nums.length - 1); } private int mergeSort(int[] nums, int l, int r) { if (l \u0026gt;= r) { return 0; } int mid = (l + r) \u0026gt;\u0026gt; 1; int res = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r); // å½’å¹¶  int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (nums[i] \u0026lt;= nums[j]) { tmp[k++] = nums[i++]; } else { tmp[k++] = nums[j++]; res += (mid - i + 1); } } while (i \u0026lt;= mid) { tmp[k++] = nums[i++]; } while (j \u0026lt;= r) { tmp[k++] = nums[j++]; } for (i = l, j = 0; i \u0026lt;= r; i++, j++) { nums[i] = tmp[j]; } return res; } } "},{"id":5,"href":"/docs/acwing/basic/790/","title":"790th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int main() { double x; cin \u0026gt;\u0026gt; x; double l = -1e4, r = 1e4; while (r - l \u0026gt; 1e-8) { double m = (l + r) / 2; if (m * m * m \u0026gt;= x) { r = m; } else { l = m; } } printf(\u0026#34;%.6lf\u0026#34;, r); return 0; } "},{"id":6,"href":"/docs/acwing/basic/791/","title":"791st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e6 + 10; vecotr\u0026lt;int\u0026gt; add(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i++) { if (i \u0026lt; A.size()) { t += A[i]; } if (i \u0026lt; B.size()) { t += B[i]; } C.push_back(t % 10); t /= 10; } if (t) { C.push_back(1); } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } auto C = add(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":7,"href":"/docs/acwing/basic/792/","title":"792nd","section":"Acwing","content":"ä¸¤ä¸ªæ­£æ•´æ•°ç›¸å‡ A - B è€ƒè™‘A \u0026lt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = -(|A| + |B|) è€ƒè™‘A \u0026gt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = |A| + |B|\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; // åˆ¤æ–­A\u0026gt;=B bool cmp(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() != B.size()) { return A.size() \u0026gt; B.size(); } for (int i = A.size() - 1; i \u0026gt;= 0; i--) { if (A[i] != B[i]) { return A[i] \u0026gt; B[i]; } } // å»æ‰å‰å¯¼0  while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return true; } vecotr\u0026lt;int\u0026gt; sub(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vecotr\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i++) { t = A[i] - t; if (i \u0026lt; B.size()) { t -= B[i]; } c.push_back((t + 10) % 10); if (t \u0026lt; 0) { t = 1; } else { t = 0; } } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B, C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } if (cmp(A, B)) { C = sub(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } else { C = sub(B, A); printf(\u0026#34;-\u0026#34;); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } return 0; } "},{"id":8,"href":"/docs/acwing/basic/793/","title":"793rd","section":"Acwing","content":"ä¸¤ä¸ªæ­£æ•´æ•°ç›¸ä¹˜ å¤§*å°\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; mul(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b) { vecotr\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t != 0; i++) { if (i \u0026lt; A.size()) { t += A[i] * b; } C.push_back(t % 10); t /= 10; } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A, vector\u0026lt;int\u0026gt; C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } C = mul(A, b); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":9,"href":"/docs/acwing/basic/794/","title":"794th","section":"Acwing","content":"ä¸¤ä¸ªæ­£æ•´æ•°ç›¸é™¤ å¤§/å°\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; div(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vecotr\u0026lt;int\u0026gt; C; int t = 0; r = 0; for (int i = A.size(); i \u0026gt;= 0; i--) { r = r * 10 + A[i]; C.push_back(r / b); r = r % b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A, vector\u0026lt;int\u0026gt; C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } int r; C = div(A, b, r); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } "},{"id":10,"href":"/docs/acwing/basic/795/","title":"795th","section":"Acwing","content":"\rS[i] = a[1] + a[2] + ... a[i]\ra[l] + ... + a[r] = S[r] - S[l - 1]\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], s[N]; int main() { a[0] = 0; s[0] = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { s[i] = s[i - 1] + a[i]; } while (m--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;r, \u0026amp;l); printf(\u0026#34;%d\\n\u0026#34;, s[r] - s[l - 1]); } return 0; } "},{"id":11,"href":"/docs/acwing/basic/796/","title":"796th","section":"Acwing","content":"\rS[i, j] = ç¬¬iè¡Œjåˆ—æ ¼å­å·¦ä¸Šéƒ¨åˆ†æ‰€æœ‰å…ƒç´ çš„å’Œ\rä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µçš„å’Œä¸ºï¼š\rS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\r#include \u0026lt;iostream\u0026gt; const int N = 1010; int n, m, q; int a[N][N], s[N][N]; int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } } while (q--) { int x1, y1, x2, y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); printf(\u0026#34;%d\\n\u0026#34;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 -1] + s[x1 - 1][y1 -1]); } return 0; } "},{"id":12,"href":"/docs/acwing/basic/797/","title":"797th","section":"Acwing","content":"\rç»™åŒºé—´[l, r]ä¸­çš„æ¯ä¸ªæ•°åŠ ä¸Šcï¼šB[l] += c, B[r + 1] -= c\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { insert(i, i, a[i]); } while (m--) { int l, r, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;c); insert(l, r, c); } for (int i = 1; i \u0026lt;= n; i++) { b[i] += b[i - 1]; } for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;%d \u0026#34;, b[i]); } return 0; } "},{"id":13,"href":"/docs/acwing/basic/798/","title":"798th","section":"Acwing","content":"\rç»™ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ åŠ ä¸Šcï¼š\rS[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 1010; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { insert(i, j, i, j, a[i][j]); } } while (q--) { int x1, y1, x2, y2, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;c); insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { printf(\u0026#34;%d \u0026#34;, b[i][j]); } puts(\u0026#34;\u0026#34;); } return 0; } "},{"id":14,"href":"/docs/acwing/basic/799/","title":"799th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; int a[100010]; int s[100010]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int maxLen = 0; for (int i = 0, j = 0; i \u0026lt; n; i++) { s[a[i]]++; while (s[a[i]] \u0026gt; 1) { s[a[j]]--; j++; } if ((i - j + 1) \u0026gt; maxLen) { maxLen = i - j + 1; } } cout \u0026lt;\u0026lt; maxLen \u0026lt;\u0026lt; endl; return 0; } "},{"id":15,"href":"/docs/acwing/basic/801/","title":"801st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int lowbit(int x) { return x \u0026amp; -x; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n--) { int x; cin \u0026gt;\u0026gt; x; int cnt = 0; while (x != 0) { x -= lowbit(x); cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":16,"href":"/docs/acwing/basic/802/","title":"802nd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n, m; int a[N], s[N]; vector\u0026lt;int\u0026gt; alls; vector\u0026lt;PII\u0026gt; add, query; // å°†xæ˜ å°„åˆ°ç´¢å¼•ä¸º(1--alls.size())çš„æ•° int find(int x) { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x); } for (int i = 0; i \u0026lt; m; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // å»é‡  sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // å¤„ç†æ’å…¥  for (auto item : add) { int x = find(item.first); a[x] += item.second; } // é¢„å¤„ç†å‰ç¼€å’Œ  for (int i = 1; i \u0026lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; // å¤„ç†æŸ¥è¯¢  for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } } "},{"id":17,"href":"/docs/acwing/basic/803/","title":"803rd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 100010; void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) { if (ed \u0026lt; seg.first) { if (ed != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else { ed = max(ed, seg.second); } } if (st != -2e9) res.push_back({st, ed}); segs = res; } int main() { int n; vector\u0026lt;PII\u0026gt; segs; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; segs.push_back({l, r}); } merge(segs); cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl; return 0; } "},{"id":18,"href":"/docs/acwing/basic/826/","title":"826th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } void add_to_head(int x) { e[idx] = x; ne[idx] = head; head = idx; idx++; } // å°†xæ’å…¥åˆ°ä¸‹æ ‡æ˜¯kçš„ç‚¹é¢ void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++; } // å°†ä¸‹æ ‡æ˜¯kçš„ç‚¹åé¢çš„ç‚¹åˆ æ‰ void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while (m--) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if (op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (!k) head = ne[head]; remove(k - 1); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":19,"href":"/docs/acwing/basic/827/","title":"827th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int idx, e[N], l[N], r[N]; void init() { // 0è¡¨ç¤ºhead 1è¡¨ç¤ºtail  r[0] = 1, l[1] = 0; idx = 2; } // åœ¨ä¸‹æ ‡ä¸ºkçš„å³è¾¹æ’å…¥ void add(int k, int x) { e[idx] = x; l[idx] = k; r[idx] = r[k]; l[r[k]] = idx; r[k] = idx; idx++; } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { int n; cin \u0026gt;\u0026gt; n; init(); while (n--) { string op; cin \u0026gt;\u0026gt; op; int k, a; if (op == \u0026#34;R\u0026#34;) { cin \u0026gt;\u0026gt; a; add(l[1], a); } else if (op == \u0026#34;L\u0026#34;) { cin \u0026gt;\u0026gt; a; add(0, a); } else if (op == \u0026#34;D\u0026#34;) { cin \u0026gt;\u0026gt; k; remove(k + 1); } else if (op == \u0026#34;IL\u0026#34;) { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a; add(l[k + 1], a); } else if (op == \u0026#34;IR\u0026#34;) { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a; add(k + 1, a); } } for (int i = r[0]; i != 1; i = r[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":20,"href":"/docs/acwing/basic/830/","title":"830th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; const int N = 100010; int n; int stk[N], tt; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; while (tt \u0026amp;\u0026amp; skt[tt] \u0026gt;= x) tt--; if (tt) { cout \u0026lt;\u0026lt; skt[tt] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } skt[++tt] = x; } return 0; } "},{"id":21,"href":"/docs/acwing/basic/831/","title":"831st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 10010, M = 10010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; for (int i = 2, j = 0; i \u0026lt;= n; i++) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } for (int i = 1, j = 0; i \u0026lt;= m; i++) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == n) { cout \u0026lt;\u0026lt; i - n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; j = ne[j]; } } return 0; } "},{"id":22,"href":"/docs/acwing/basic/835/","title":"835th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; // idx=0 ä¸ºæ ¹, cnt[n]:ä»¥nä¸ºç»“å°¾çš„æ•°é‡ int son[N][26], cnt[N], idx; char str[N]; void insert(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p]++; } int query(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n--) { char op[2]; scanf(\u0026#34;%s%s\u0026#34;, op, str); if (op[0] == \u0026#39;I\u0026#39;) insert(str); else printf(\u0026#34;%d\\n\u0026#34;, query(str)); } return 0; } "},{"id":23,"href":"/docs/acwing/basic/836/","title":"836th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int p[N]; int n, m; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) p[i] = i; while (m--) { char op[2]; int a, b; scanf(\u0026#34;%s%d%d\u0026#34;, op, \u0026amp;a, \u0026amp;b); if (op[0] == \u0026#39;M\u0026#39;) { p[find(a)] = find(b); } else { if (find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } "},{"id":24,"href":"/docs/acwing/basic/837/","title":"837th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int p[N], sz[N]; int n, m; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { p[i] = i; sz[i] = 1; } while (m--) { char op[5]; int a, b; scanf(\u0026#34;%s\u0026#34;, op); if (op[0] == \u0026#39;C\u0026#39;) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (find(a) == find(b)) continue; sz[find(b)] += sz[find(a)]; p[find(a)] = find(b); } else if (op[1] == \u0026#39;1\u0026#39;) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } else { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;, sz[find(a)]); } } return 0; } "},{"id":25,"href":"/docs/acwing/basic/838/","title":"838th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], sz; void down(int u) { int t = u; if (u * 2 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (t != u) { swap(h[t], h[u]); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u / 2] \u0026gt; h[u]) { swap(h[u], h[u / 2]); u /= 2; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; h[i]; } sz = n; for (int i = n / 2; i; i--) { down(i); } while (m --) { cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; h[1] = h[sz]; sz -= 1; down(1); } return 0; } "},{"id":26,"href":"/docs/acwing/basic/839/","title":"839th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string.h\u0026gt; using namespace std; const int N = 100010; int h[N], ph[N], hp[N], sz; void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (t != u) { heap_swap(t, u); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u / 2] \u0026gt; h[u]) { heap_swap(u, u / 2); u /= 2; } } int main() { int n, m = 0; cin \u0026gt;\u0026gt; n; while (n--) { char op[10]; scanf(\u0026#34;%s\u0026#34;, op); int k, x; if (!strcmp(op, \u0026#34;I\u0026#34;)) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); m++; sz++; ph[m] = sz, hp[sz] = m; h[sz] = x; up(sz); } else if (!strcmp(op, \u0026#34;PM\u0026#34;)) { printf(\u0026#34;%d\\n\u0026#34;, h[1]); } else if (!strcmp(op, \u0026#34;DM\u0026#34;)) { heap_swap(1, sz); sz--; down(1); } else if (!strcmp(op, \u0026#34;D\u0026#34;)) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); k = ph[k]; heap_swap(k, sz); sz--; down(k), up(k); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;k, \u0026amp;x); k = ph[k]; h[k] = x; down(k), up(k); } } return 0; } "},{"id":27,"href":"/docs/acwing/basic/840/","title":"840th","section":"Acwing","content":"\rå¼€æ”¾å¯»å€æ³•\r#\r\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 2000003, null = 0x3f3f3f3f; int h[N]; bool find(int x) { int k = (x % N + N) % N; while (h[k] != null \u0026amp;\u0026amp; h[k] != x) { k++; if (k == N) k = 0; } return k; } int main() { int n; cin \u0026gt;\u0026gt; n; memset(h, 0x3f, sizeof(h)); while (n--) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); int k = find(x); if (*op == \u0026#39;I\u0026#39;) h[k] = x; else { if (h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } æ‹‰é“¾æ³•\r#\r\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000003; int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx; idx++; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } int main() { int n; cin \u0026gt;\u0026gt; n; memset(h, -1, sizeof(h)); while (n--) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) insert(x); else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } "},{"id":28,"href":"/docs/acwing/basic/841/","title":"841st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main() { scanf(\u0026#34;%d%d%s\u0026#34;, \u0026amp;n, \u0026amp;m, str + 1); p[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while (m--) { int l1, r1, l2, r2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;l1, \u0026amp;r1, \u0026amp;l2, \u0026amp;r2); if (get(l1, r1) == get(l2, r2)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } return 0; } "},{"id":29,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"ç›¸å…³èµ„æº\r#\r\r  \rè—ç»é˜\n  \rNo Starch Press\n  \rThe Pragmatic Bookshelf\n  \rManning\n  \rO\u0026rsquo;Reilly\n  \rLet Me Read\n  \rLibrary Genesis\n  \rSaltTiger ç›®å‰æˆ‘ä¸»è¦åœ¨ä»¥ä¸‹ç½‘ç«™æ”¶é›†ç¼–ç¨‹ç±»ç”µå­ä¹¦ï¼Œå¤§å®¶å»è¿™ä¸Šé¢æ‰¾ä¹¦å°±å¥½ï¼Œä¸‹è½½æ–¹æ³•ä¹Ÿä¸€å¹¶ç»™å‡ºï¼š\n  \rCoderProgï¼Œç‚¹å‡»éªŒè¯ç ï¼Œè·³è½¬è‡³Rapidgatoræˆ–Turbobitç½‘ç›˜ï¼Œå°†ç½‘ç›˜é“¾æ¥å¤åˆ¶åˆ°\ræœ¨è–¯ç‰›ç½‘ç›˜ä¸­è½¬ç«™ï¼ˆ1Gæµé‡1.33å…ƒï¼‰è¿›è¡Œä¸­è½¬ï¼Œå³å¯ä¸‹è½½ã€‚\n  \rAvaxHomeï¼Œè·³è½¬è‡³icerboxç½‘ç›˜ï¼Œå°†ç½‘ç›˜é“¾æ¥å¤åˆ¶åˆ°\ræ€é£ç½‘ç›˜ä¸­è½¬ç«™ï¼ˆ1G icerboxæµé‡2.8å…ƒï¼‰è¿›è¡Œä¸­è½¬ï¼Œä¸­è½¬åè‡ªåŠ¨è½¬å­˜åˆ°ç»‘å®šçš„ç™¾åº¦ç½‘ç›˜ï¼Œå³å¯ä¸‹è½½ã€‚\n  \rFox eBookï¼Œè·³è½¬è‡³NitroFlareç½‘ç›˜ï¼Œå°†ç½‘ç›˜é“¾æ¥å¤åˆ¶åˆ°\ræœ¨è–¯ç‰›ç½‘ç›˜ä¸­è½¬ç«™è¿›è¡Œä¸­è½¬ï¼Œå³å¯ä¸‹è½½ã€‚\n  \rLibrary Genesisï¼Œç‚¹å‡»Mirrorsé“¾æ¥ç›´æ¥ä¸‹è½½ã€‚\n  \rLet Me Readï¼Œç‚¹å‡»éªŒè¯ç ï¼Œè·³è½¬DirectLinkç›´æ¥ä¸‹è½½ã€‚\n    \rZlibrary\n  \rLeanpub\n  \rThe best Programming books\n  "},{"id":30,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":"è¯»ä¹¦\r#\r\r ä¹¦ç±æ˜¯äººç±»è¿›æ­¥çš„é˜¶æ¢¯ã€‚\n  æ¸©æ•…è€ŒçŸ¥æ–°,å¯ä»¥ä¸ºå¸ˆçŸ£ã€‚\n ã€Šç°ä»£ C++ æ•™ç¨‹ã€‹\n 2022/3/7 Ch1 ~ Ch2 2022/3/8 Finish  ã€Šç®—æ³•å¯¼è®ºã€‹\n 2022/1/24 Ch1 2022/1/26 Ch2 ~ Ch4 2022/2/10 Ch6 ~ Ch14  ã€Šç²¾é€šSpring 4.x ä¼ä¸šåº”ç”¨å¼€å‘å®æˆ˜ã€‹\n Todo 18ã€19ã€20  ã€ŠJavaæ€§èƒ½æƒå¨æŒ‡å—ã€‹\n 2021/12/16 Ch1 2022/2/6 Ch2~Ch4  ã€Šè‡ªå·±åŠ¨æ‰‹å†™Javaè™šæ‹Ÿæœºã€‹\n 2021/12/21 Ch1 2021/12/23 Ch2 2021/12/31 Ch3.3 2022/1/1 Ch3 2022/2/6 Ch4 2022/2/7 Ch5  ã€ŠHead Firstè®¾è®¡æ¨¡å¼ã€‹\nã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æï¼šCè¯­è¨€æè¿°ã€‹\n 2021/10/14 P27 2021/11/5 CH2  ã€ŠScalaå‡½æ•°å¼ç¼–ç¨‹ã€‹\n 2022/3/4 P47 2022/3/8 Ch3  ã€ŠJavaé«˜å¹¶å‘ç¼–ç¨‹è¯¦è§£ï¼šå¤šçº¿ç¨‹ä¸æ¶æ„è®¾è®¡ã€‹ ã€ŠJavaé«˜å¹¶å‘ç¼–ç¨‹è¯¦è§£ï¼šæ·±å…¥ç†è§£å¹¶å‘æ ¸å¿ƒåº“ã€‹ ã€ŠJavaç¨‹åºå‘˜ä¿®ç‚¼ä¹‹é“ã€‹ ã€Šç¼–ç¨‹ä¹‹ç¾ã€‹ ã€Šæ·±å…¥ç†è§£Javaæ¨¡å—ç³»ç»Ÿã€‹\nã€ŠgRPCä¸äº‘åŸç”Ÿåº”ç”¨å¼€å‘ï¼šä»¥Goå’ŒJavaä¸ºä¾‹ã€‹\n 2022/3/4 P54 2022/3/5 P73 2022/3/6 Finish  ã€Šç²¾åŠ›ç®¡ç†ã€‹\n 2022/3/5 Ch3  ã€Šå·¨äººçš„å·¥å…·ã€‹\n 2022/3/5  ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ï¼šè½¯ä»¶æ ¸å¿ƒå¤æ‚æ€§åº”å¯¹ä¹‹é“ã€‹\nã€Šæµ‹è¯•é©±åŠ¨å¼€å‘ã€‹\n 2022/3/2 Ch1 ~ Ch8 2022/3/3 Ch9 ~ Ch19 2022/3/4 Finish  ã€Šå›¾è§£HTTPã€‹\n 2022/2/26 Ch1 ~ Ch6 2022/2/27 Ch7 ~ Ch8 2022/2/28 Finish  ã€Šç½‘ç»œåŸºæœ¬åŠŸç³»åˆ—ã€‹\n 2022/2/23 Ch1 ~ Ch3  ã€Šè½¯ä»¶è®¾è®¡çš„å“²å­¦ã€‹\n 2022/2/22 Ch1 ~ Ch4  ã€ŠAtomic Kotlinã€‹\n 2022/3/1 P38 2022/3/2 P56 2022/3/7 P86  ã€ŠOn Java8ã€‹\nã€ŠLinuxå°±è¯¥è¿™ä¹ˆå­¦ã€‹\nã€ŠUNIXç½‘ç»œç¼–ç¨‹ å·1ï¼šå¥—æ¥å­—è”ç½‘APIã€‹\n 2021/12/8 P17 2022/2/10 Ch2 2022/3/4 Ch3 2022/3/7 Ch4 2022/3/8 Ch5  ã€ŠTCP-IPè¯¦è§£ å·1ï¼šåè®®ã€‹\n 2021/10/16 CH1 2021/10/19 CH2 2021/10//20 CH3ã€CH4ã€CH5 2021/11/10 Ch8 2021/11/20 Ch9ã€Ch10 2022/3/4 Ch11  ã€ŠLinuxUNIXç³»ç»Ÿç¼–ç¨‹ã€‹\n 2021/10/11 P46 2021/10/21 CH3 2021/11/4 CH4ã€5ã€6 2021/11/5 CH7 2021/11/21 Ch11ã€Ch12 2021//11/30 Ch13 2022/2/22 Ch14 2022/2/24 Ch15 ~ Ch19  ã€Šæ•°æ®åº“ç³»ç»Ÿæ¦‚å¿µã€‹\n 2021/11/25 Ch1 2021/12/2 Ch2 2021/12/13 Ch3 2021/12/30 P102 2022/1/4 Ch4.5  ã€Šæ“ä½œç³»ç»ŸçœŸè±¡è¿˜åŸã€‹\n 2021/10/21 2021/10/29 Ch0 2021/10/30 Ch1 2021/11/24 Ch2 2022/2/22 P81 2022/3/1 P91 2022/3/2 P101  ã€Šè®¡ç®—æœºç³»ç»Ÿè¦ç´ ï¼šä»é›¶å¼€å§‹æ„å»ºç°ä»£è®¡ç®—æœºã€‹\n 2021/11/16 Ch8 2021/12/28 Ch9 2022/2/10 Ch10 2022/2/16 Ch11 2022/2/19 Finsih  ã€Šæ•°æ®å¯†é›†å‹åº”ç”¨ç³»ç»Ÿè®¾è®¡ã€‹\n 2021/11/6 2021/11/19 Ch1 2021/11/28 Ch2ã€P86 2021/12/4 P89 2021/12/11 Ch3ã€P124 2021/12/12 Ch4 2021/12/21 2021/12/28 Ch5 2022/1/31 Ch6 2022/2/16 Ch7  ã€Šç°ä»£C++ç™½çš®ä¹¦ã€‹\n 2021/12/30 P60  ã€Šè®¡ç®—æœºç¨‹åºçš„æ„é€ å’Œè§£é‡Šã€‹\n 2022/2/13 3.5  ã€ŠRedisè®¾è®¡ä¸å®ç°ã€‹\n 2021/10/13 CH7 2021/10/25 CH8ã€CH9  ã€ŠWiresharkæ•°æ®åŒ…åˆ†æå®æˆ˜ã€‹\n 2021/12/4 Ch1 2022/2/10 Ch2~Ch4 2022/2/14 Ch5  ã€Šå¦‚ä½•ç§‘å­¦å­¦å¤–è¯­ è¯­è¨€ä¹ å¾—çš„çœŸç›¸ä¸æ–¹æ³•ã€‹\n 2022/2/2 Ch1~Ch4 2022/2/3 Finish  ã€Šè½¯ä»¶å¼€å‘å®è·µï¼šé¡¹ç›®é©±åŠ¨å¼çš„Javaå¼€å‘æŒ‡å—ã€‹\n 2022/2/2 Ch1~Ch3 2022/2/3 Finish  ã€ŠJAVAè§£æƒ‘ã€‹\n 2022/2/6 Finish  ã€Šç®—æ³•4ã€‹\n 2022/1/25 Finish  ã€Šç¼–ç¨‹ç ç‘ã€‹\n 2021/11/27 Ch1 2021/12/14 Ch2 2022/1/3 Ch3 2022/1/25 Finish  ã€ŠJavaå·¥ç¨‹å¸ˆä¿®ç‚¼ä¹‹é“ã€‹\n 2022/1/11 1.1 2022/1/23 Finish  ã€ŠThe Little Schemerã€‹\n 2021/11/15 Ch5 2021/11/25 Ch6 2022/1/15 Ch7 2022/1/22 Finish  ã€Šä»£ç æ•´æ´ä¹‹é“ã€‹\n 2021/11/15 Ch3 2021/12/14 Ch4ã€Ch5ã€Ch6 2022/1/21 Ch7ã€8ã€9ã€10ã€11 2022/1/22 Finish  ã€ŠJavaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ã€‹\n 2021/10/9 P280 ~ P304 2021/10/30 Finish  ã€Šæ“ä½œç³»ç»Ÿå¯¼è®ºã€‹\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40ã€41ã€42 2021/10/18 Finish  ã€ŠBuild On Your Lispã€‹\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 Finish  ã€ŠUNIXç¯å¢ƒé«˜çº§ç¼–ç¨‹ã€‹\n 2021/10/22 CH11 2021/10/31 CH12 2021/11/10 2021/11/20 Ch16 2021/11/24 Finish  "},{"id":31,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  Tools\r#\r\r \rVisuAlgo.net \rBig-O Cheat Sheet  "},{"id":32,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":" \rAcwingæ¨¡æ¿\n å¿«é€Ÿæ’åº\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } å½’å¹¶æ’åº\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } äºŒåˆ†\r#\r\r// åŒºé—´[l,r]åˆ’åˆ†æˆ[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) { //check() æ£€æŸ¥midæ˜¯å¦æ»¡è¶³æ€§è´¨  r = mid; } else { l = mid + 1; } } } // åŒºé—´[l,r]åˆ’åˆ†æˆ[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1\u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } åŒæŒ‡é’ˆ\r#\r\rfor (int i = 0, j = 0; i \u0026lt; n; i ++ ) { while (j \u0026lt; i \u0026amp;\u0026amp; check(i, j)) j ++ ; // å…·ä½“é—®é¢˜çš„é€»è¾‘ } å¸¸è§é—®é¢˜åˆ†ç±»ï¼š (1) å¯¹äºä¸€ä¸ªåºåˆ—ï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆç»´æŠ¤ä¸€æ®µåŒºé—´ (2) å¯¹äºä¸¤ä¸ªåºåˆ—ï¼Œç»´æŠ¤æŸç§æ¬¡åºï¼Œæ¯”å¦‚å½’å¹¶æ’åºä¸­åˆå¹¶ä¸¤ä¸ªæœ‰åºåºåˆ—çš„æ“ä½œ ä½è¿ç®—\r#\r\ræ±‚nçš„ç¬¬kä½æ•°å­—: n \u0026gt;\u0026gt; k \u0026amp; 1\rè¿”å›nçš„æœ€åä¸€ä½1ï¼šlowbit(n) = n \u0026amp; -n\rç¦»æ•£åŒ–\r#\r\rvector\u0026lt;int\u0026gt; alls; // å­˜å‚¨æ‰€æœ‰å¾…ç¦»æ•£åŒ–çš„å€¼ sort(alls.begin(), alls.end()); // å°†æ‰€æœ‰å€¼æ’åº alls.erase(unique(alls.begin(), alls.end()), alls.end()); // å»æ‰é‡å¤å…ƒç´   // äºŒåˆ†æ±‚å‡ºxå¯¹åº”çš„ç¦»æ•£åŒ–çš„å€¼ int find(int x) // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„ä½ç½® { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // æ˜ å°„åˆ°1, 2, ...n } åŒºé—´åˆå¹¶\r#\r\r// å°†æ‰€æœ‰å­˜åœ¨äº¤é›†çš„åŒºé—´åˆå¹¶ void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } å•é“¾è¡¨\r#\r\r// headå­˜å‚¨é“¾è¡¨å¤´ï¼Œe[]å­˜å‚¨èŠ‚ç‚¹çš„å€¼ï¼Œne[]å­˜å‚¨èŠ‚ç‚¹çš„nextæŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹ int head, e[N], ne[N], idx; // åˆå§‹åŒ– void init() { head = -1; idx = 0; } // åœ¨é“¾è¡¨å¤´æ’å…¥ä¸€ä¸ªæ•°a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // å°†å¤´ç»“ç‚¹åˆ é™¤ï¼Œéœ€è¦ä¿è¯å¤´ç»“ç‚¹å­˜åœ¨ void remove() { head = ne[head]; } åŒé“¾è¡¨\r#\r\r// e[]è¡¨ç¤ºèŠ‚ç‚¹çš„å€¼ï¼Œl[]è¡¨ç¤ºèŠ‚ç‚¹çš„å·¦æŒ‡é’ˆï¼Œr[]è¡¨ç¤ºèŠ‚ç‚¹çš„å³æŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹ int e[N], l[N], r[N], idx; // åˆå§‹åŒ– void init() { //0æ˜¯å·¦ç«¯ç‚¹ï¼Œ1æ˜¯å³ç«¯ç‚¹  r[0] = 1, l[1] = 0; idx = 2; } // åœ¨èŠ‚ç‚¹açš„å³è¾¹æ’å…¥ä¸€ä¸ªæ•°x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // åˆ é™¤èŠ‚ç‚¹a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } æ ˆ\n// ttè¡¨ç¤ºæ ˆé¡¶ int stk[N], tt = 0; // å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªæ•° stk[ ++ tt] = x; // ä»æ ˆé¡¶å¼¹å‡ºä¸€ä¸ªæ•° tt -- ; // æ ˆé¡¶çš„å€¼ stk[tt]; // åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º if (tt \u0026gt; 0) { } é˜Ÿåˆ—\r#\r\r æ™®é€šé˜Ÿåˆ—  // hh è¡¨ç¤ºé˜Ÿå¤´ï¼Œttè¡¨ç¤ºé˜Ÿå°¾ int q[N], hh = 0, tt = -1; // å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªæ•° q[ ++ tt] = x; // ä»é˜Ÿå¤´å¼¹å‡ºä¸€ä¸ªæ•° hh ++ ; // é˜Ÿå¤´çš„å€¼ q[hh]; // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º if (hh \u0026lt;= tt) { } å¾ªç¯é˜Ÿåˆ—  // hh è¡¨ç¤ºé˜Ÿå¤´ï¼Œttè¡¨ç¤ºé˜Ÿå°¾çš„åä¸€ä¸ªä½ç½® int q[N], hh = 0, tt = 0; // å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªæ•° q[tt ++ ] = x; if (tt == N) tt = 0; // ä»é˜Ÿå¤´å¼¹å‡ºä¸€ä¸ªæ•° hh ++ ; if (hh == N) hh = 0; // é˜Ÿå¤´çš„å€¼ q[hh]; // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º if (hh != tt) { } å•è°ƒæ ˆ\r#\r\rå¸¸è§æ¨¡å‹ï¼šæ‰¾å‡ºæ¯ä¸ªæ•°å·¦è¾¹ç¦»å®ƒæœ€è¿‘çš„æ¯”å®ƒå¤§/å°çš„æ•° int tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } å•è°ƒé˜Ÿåˆ—\r#\r\rå¸¸è§æ¨¡å‹ï¼šæ‰¾å‡ºæ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼ int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; check_out(q[hh])) hh ++ ; // åˆ¤æ–­é˜Ÿå¤´æ˜¯å¦æ»‘å‡ºçª—å£  while (hh \u0026lt;= tt \u0026amp;\u0026amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP\r#\r\r// s[]æ˜¯é•¿æ–‡æœ¬ï¼Œp[]æ˜¯æ¨¡å¼ä¸²ï¼Œnæ˜¯sçš„é•¿åº¦ï¼Œmæ˜¯pçš„é•¿åº¦ æ±‚æ¨¡å¼ä¸²çš„Nextæ•°ç»„ï¼š for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // åŒ¹é… for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // åŒ¹é…æˆåŠŸåçš„é€»è¾‘  } } Trieæ ‘\r#\r\rint son[N][26], cnt[N], idx; // 0å·ç‚¹æ—¢æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåˆæ˜¯ç©ºèŠ‚ç‚¹ // son[][]å­˜å‚¨æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹ // cnt[]å­˜å‚¨ä»¥æ¯ä¸ªèŠ‚ç‚¹ç»“å°¾çš„å•è¯æ•°é‡  // æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸² void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // æŸ¥è¯¢å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•° int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } å¹¶æŸ¥é›†\r#\r\r(1)æœ´ç´ å¹¶æŸ¥é›†ï¼š int p[N]; //å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹  // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹  int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n  for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š  p[find(a)] = find(b); (2)ç»´æŠ¤sizeçš„å¹¶æŸ¥é›†ï¼š int p[N], size[N]; //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, size[]åªæœ‰ç¥–å®—èŠ‚ç‚¹çš„æœ‰æ„ä¹‰ï¼Œè¡¨ç¤ºç¥–å®—èŠ‚ç‚¹æ‰€åœ¨é›†åˆä¸­çš„ç‚¹çš„æ•°é‡  // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹  int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n  for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š  size[find(b)] += size[find(a)]; p[find(a)] = find(b); (3)ç»´æŠ¤åˆ°ç¥–å®—èŠ‚ç‚¹è·ç¦»çš„å¹¶æŸ¥é›†ï¼š int p[N], d[N]; //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, d[x]å­˜å‚¨xåˆ°p[x]çš„è·ç¦»  // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹  int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n  for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š  p[find(a)] = find(b); d[find(a)] = distance; // æ ¹æ®å…·ä½“é—®é¢˜ï¼Œåˆå§‹åŒ–find(a)çš„åç§»é‡ å †\r#\r\r// h[N]å­˜å‚¨å †ä¸­çš„å€¼, h[1]æ˜¯å †é¡¶ï¼Œxçš„å·¦å„¿å­æ˜¯2x, å³å„¿å­æ˜¯2x + 1 // ph[k]å­˜å‚¨ç¬¬kä¸ªæ’å…¥çš„ç‚¹åœ¨å †ä¸­çš„ä½ç½® // hp[k]å­˜å‚¨å †ä¸­ä¸‹æ ‡æ˜¯kçš„ç‚¹æ˜¯ç¬¬å‡ ä¸ªæ’å…¥çš„ int h[N], ph[N], hp[N], size; // äº¤æ¢ä¸¤ä¸ªç‚¹ï¼ŒåŠå…¶æ˜ å°„å…³ç³» void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u / 2]) { heap_swap(u, u / 2); u \u0026gt;\u0026gt;= 1; } } // O(n)å»ºå † for (int i = n / 2; i; i -- ) down(i); ä¸€èˆ¬å“ˆå¸Œ\r#\r\r(1) æ‹‰é“¾æ³• int h[N], e[N], ne[N], idx; // å‘å“ˆå¸Œè¡¨ä¸­æ’å…¥ä¸€ä¸ªæ•°  void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥è¯¢æŸä¸ªæ•°æ˜¯å¦å­˜åœ¨  bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) å¼€æ”¾å¯»å€æ³• int h[N]; // å¦‚æœxåœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xçš„ä¸‹æ ‡ï¼›å¦‚æœxä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xåº”è¯¥æ’å…¥çš„ä½ç½®  int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } å­—ç¬¦ä¸²å“ˆå¸Œ\r#\r\ræ ¸å¿ƒæ€æƒ³ï¼šå°†å­—ç¬¦ä¸²çœ‹æˆPè¿›åˆ¶æ•°ï¼ŒPçš„ç»éªŒå€¼æ˜¯131æˆ–13331ï¼Œå–è¿™ä¸¤ä¸ªå€¼çš„å†²çªæ¦‚ç‡ä½ å°æŠ€å·§ï¼šå–æ¨¡çš„æ•°ç”¨2^64ï¼Œè¿™æ ·ç›´æ¥ç”¨unsigned long longå­˜å‚¨ï¼Œæº¢å‡ºçš„ç»“æœå°±æ˜¯å–æ¨¡çš„ç»“æœ typedef unsigned long long ULL; ULL h[N], p[N]; // h[k]å­˜å‚¨å­—ç¬¦ä¸²å‰kä¸ªå­—æ¯çš„å“ˆå¸Œå€¼, p[k]å­˜å‚¨ P^k mod 2^64  // åˆå§‹åŒ– p[0] = 1; for (int i = 1; i \u0026lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // è®¡ç®—å­ä¸² str[l ~ r] çš„å“ˆå¸Œå€¼ ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STLç®€ä»‹\r#\r\rvector, å˜é•¿æ•°ç»„ï¼Œå€å¢çš„æ€æƒ³\rsize() è¿”å›å…ƒç´ ä¸ªæ•°\rempty() è¿”å›æ˜¯å¦ä¸ºç©º\rclear() æ¸…ç©º\rfront()/back()\rpush_back()/pop_back()\rbegin()/end()\r[]\ræ”¯æŒæ¯”è¾ƒè¿ç®—ï¼ŒæŒ‰å­—å…¸åº\rpair\u0026lt;int, int\u0026gt;\rfirst, ç¬¬ä¸€ä¸ªå…ƒç´ \rsecond, ç¬¬äºŒä¸ªå…ƒç´ \ræ”¯æŒæ¯”è¾ƒè¿ç®—ï¼Œä»¥firstä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œä»¥secondä¸ºç¬¬äºŒå…³é”®å­—ï¼ˆå­—å…¸åºï¼‰\rstringï¼Œå­—ç¬¦ä¸²\rsize()/length() è¿”å›å­—ç¬¦ä¸²é•¿åº¦\rempty()\rclear()\rsubstr(èµ·å§‹ä¸‹æ ‡ï¼Œ(å­ä¸²é•¿åº¦)) è¿”å›å­ä¸²\rc_str() è¿”å›å­—ç¬¦ä¸²æ‰€åœ¨å­—ç¬¦æ•°ç»„çš„èµ·å§‹åœ°å€\rqueue, é˜Ÿåˆ—\rsize()\rempty()\rpush() å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªå…ƒç´ \rfront() è¿”å›é˜Ÿå¤´å…ƒç´ \rback() è¿”å›é˜Ÿå°¾å…ƒç´ \rpop() å¼¹å‡ºé˜Ÿå¤´å…ƒç´ \rpriority_queue, ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé»˜è®¤æ˜¯å¤§æ ¹å †\rsize()\rempty()\rpush() æ’å…¥ä¸€ä¸ªå…ƒç´ \rtop() è¿”å›å †é¡¶å…ƒç´ \rpop() å¼¹å‡ºå †é¡¶å…ƒç´ \rå®šä¹‰æˆå°æ ¹å †çš„æ–¹å¼ï¼špriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q;\rstack, æ ˆ\rsize()\rempty()\rpush() å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªå…ƒç´ \rtop() è¿”å›æ ˆé¡¶å…ƒç´ \rpop() å¼¹å‡ºæ ˆé¡¶å…ƒç´ \rdeque, åŒç«¯é˜Ÿåˆ—\rsize()\rempty()\rclear()\rfront()/back()\rpush_back()/pop_back()\rpush_front()/pop_front()\rbegin()/end()\r[]\rset, map, multiset, multimap, åŸºäºå¹³è¡¡äºŒå‰æ ‘ï¼ˆçº¢é»‘æ ‘ï¼‰ï¼ŒåŠ¨æ€ç»´æŠ¤æœ‰åºåºåˆ—\rsize()\rempty()\rclear()\rbegin()/end()\r++, -- è¿”å›å‰é©±å’Œåç»§ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)\rset/multiset\rinsert() æ’å…¥ä¸€ä¸ªæ•°\rfind() æŸ¥æ‰¾ä¸€ä¸ªæ•°\rcount() è¿”å›æŸä¸€ä¸ªæ•°çš„ä¸ªæ•°\rerase()\r(1) è¾“å…¥æ˜¯ä¸€ä¸ªæ•°xï¼Œåˆ é™¤æ‰€æœ‰x O(k + logn)\r(2) è¾“å…¥ä¸€ä¸ªè¿­ä»£å™¨ï¼Œåˆ é™¤è¿™ä¸ªè¿­ä»£å™¨\rlower_bound()/upper_bound()\rlower_bound(x) è¿”å›å¤§äºç­‰äºxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨\rupper_bound(x) è¿”å›å¤§äºxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨\rmap/multimap\rinsert() æ’å…¥çš„æ•°æ˜¯ä¸€ä¸ªpair\rerase() è¾“å…¥çš„å‚æ•°æ˜¯pairæˆ–è€…è¿­ä»£å™¨\rfind()\r[] æ³¨æ„multimapä¸æ”¯æŒæ­¤æ“ä½œã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ O(logn)\rlower_bound()/upper_bound()\runordered_set, unordered_map, unordered_multiset, unordered_multimap, å“ˆå¸Œè¡¨\rå’Œä¸Šé¢ç±»ä¼¼ï¼Œå¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)\rä¸æ”¯æŒ lower_bound()/upper_bound()ï¼Œ è¿­ä»£å™¨çš„++ï¼Œ--\rbitset, åœ§ä½\rbitset\u0026lt;10000\u0026gt; s;\r~, \u0026amp;, |, ^\r\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\r==, !=\r[]\rcount() è¿”å›æœ‰å¤šå°‘ä¸ª1\rany() åˆ¤æ–­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ª1\rnone() åˆ¤æ–­æ˜¯å¦å…¨ä¸º0\rset() æŠŠæ‰€æœ‰ä½ç½®æˆ1\rset(k, v) å°†ç¬¬kä½å˜æˆv\rreset() æŠŠæ‰€æœ‰ä½å˜æˆ0\rflip() ç­‰ä»·äº~\rflip(k) æŠŠç¬¬kä½å–å\r"},{"id":33,"href":"/docs/cs/build/","title":"Build","section":"C S","content":" \rlearn-x-by-doing-y \rbuild-your-own-x \rProject Based Learning  "},{"id":34,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Javaå¹¶å‘ç¼–ç¨‹è‰ºæœ¯","section":"C S","content":"11.2 å®šä½é—®é¢˜\r#\r\rçº¿ä¸Šä»£ç å®šä½é—®é¢˜\n11.3 æ€§èƒ½æµ‹è¯•\r#\r\rç›¸å…³çš„å‘½ä»¤\n"},{"id":35,"href":"/docs/cs/courses/","title":"Courses","section":"C S","content":"Study Path\r#\r\r [MIT 6.Null The Missing Semester of Your CS Education]  ç¼–ç¨‹å…¥é—¨\r#\r\r CSE 251 Programming in C Programming Languages, Part A Standford CS106L C++ Programming CS 61A: Structure and Interpretation of Computer Programs  æ•°æ®ç»“æ„ä¸ç®—æ³•\r#\r\r UCB CS61B Data Structures Standford CS106B Programming Abstractions  è½¯ä»¶å·¥ç¨‹\r#\r\r MIT 6.031: Software Construction UCB CS169: software engineering  ä½“ç³»ç»“æ„\r#\r\r From Nand to Tetris Building a Modern Computer From First Principles UCB CS61C Great Ideas in Computer Architecture (Machine Structures)  ç³»ç»Ÿå…¥é—¨\r#\r\r MIT6.033: System Engineering CMU 15-213: Introduction to Computer System  æ“ä½œç³»ç»Ÿ\r#\r\r MIT 6.S081 Operating System Engineering UCB CS162: Operating Systems and System Programming  æ•°æ®åº“ç³»ç»Ÿ\r#\r\r CMU 15-445: Introduction to Database System (C++) UCB CS186: Introduction to Database System (Java)  è®¡ç®—æœºç½‘ç»œ\r#\r\r Stanford CS144: Computer Network  ç¼–è¯‘åŸç†\r#\r\r Stanford CS143: Compilers  å¹¶è¡Œä¸åˆ†å¸ƒå¼ç³»ç»Ÿ\r#\r\r CMU 15-418/Stanford CS149: Parallel Computing MIT 6.824: Distributed System  ç³»ç»Ÿå®‰å…¨\r#\r\r UCB CS161: Computer Security  "},{"id":36,"href":"/docs/cs/database/","title":"Database","section":"C S","content":" \rdb-tutorial æ˜¯ä¸€ä¸ªæ•°æ®åº“æ•™ç¨‹ã€‚ \rç”µå­ç§‘æŠ€å¤§å­¦åˆ†å¸ƒå¼å­˜å‚¨ä¸è®¡ç®—å®éªŒå®¤æ–°ç”Ÿè®­ç»ƒè®¡åˆ’ \rğŸ˜‹ A curated reading list about database systems \rReadings in Databases  "},{"id":37,"href":"/docs/cs/interviews/","title":"Interviews","section":"C S","content":" \ræ•´ç†itèµ„æ–™çš„ç™¾ç§‘å…¨åº“ \rä»‹ç»ä¸­å›½å„äºŒçº¿ä»¥ä¸ŠåŸå¸‚çš„äº’è”ç½‘ç¯å¢ƒä»¥åŠç”Ÿæ´»æˆæœ¬  Java\r#\r\r \rbugstack è™«æ´æ ˆ \rJava å…¨æ ˆçŸ¥è¯†ä½“ç³» \rJavaGuide \rJavaFamily \rJavaTutorial \rlearning-note \rJavaKeeper \räº’è”ç½‘ Java å·¥ç¨‹å¸ˆè¿›é˜¶çŸ¥è¯†å®Œå…¨æ‰«ç›² \rJavaHome \rJavaSourceCodeLearning \rDocs \rJavaYouth \rjavaDesign \rå¤§å‚é¢è¯•æŒ‡åŒ— \rç®—æ³•åˆ·é¢˜æŒ‡å—ã€Javaå¤šçº¿ç¨‹ä¸é«˜å¹¶å‘ã€Javaé›†åˆæºç ã€Spring bootã€Spring Cloudç­‰ç¬”è®°ï¼Œæºç çº§å­¦ä¹ ç¬”è®°åç»­ä¹Ÿä¼šæ›´æ–°ã€‚  C++\r#\r\r \rã€C++é¢è¯•\u0026amp;C++å­¦ä¹ æŒ‡å—ã€‘ è¿™é‡Œæ•´ç†äº†C++åç«¯ç ”å‘å·¥ç¨‹å¸ˆé¢è¯•å’Œå·¥ä½œå¿…å¤‡çš„çŸ¥è¯†ç‚¹ ã€‚  Others\r#\r\r \räº’è”ç½‘å…¬å¸å¸¸ç”¨æ¡†æ¶æºç èµæ \rTech Interview Handbook \rCS-Notes \rEverything you need to know to get the job.  "},{"id":38,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace è·Ÿè¸ªç³»ç»Ÿè°ƒç”¨ stat æ‰“å°æ–‡ä»¶ä¿¡æ¯ mount æŸ¥çœ‹æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿ grep telnet /etc/services åŒ…å«äº†ä¸€äº›ç†ŸçŸ¥çš„ç«¯å£å· ldd proc åˆ—å‡ºç¨‹åºçš„åŠ¨æ€ä¾èµ–æ€§ ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt xxd æŸ¥çœ‹æ–‡ä»¶äºŒè¿›åˆ¶  è¾“å‡ºå½“å‰ç”¨æˆ·æ˜¯ä¸æ˜¯ root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  æŸ¥çœ‹ç£ç›˜å¼•å¯¼æ‰‡åŒº (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  ç»Ÿè®¡æ‰€æœ‰ cpp æ–‡ä»¶çš„è¡Œæ•°\n find . | grep '\\.cpp$' | xargs cat | wc -l  ç»Ÿè®¡å‘½ä»¤è¡Œå‘½ä»¤çš„é¢‘ç‡\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  æ–‡ä»¶ç®¡ç† - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  æ–‡ä»¶æ£€ç´¢ - cat, more, less, head, tail, file, find\n  è¾“å…¥è¾“å‡ºæ§åˆ¶ - é‡å®šå‘, ç®¡é“, tee, xargs\n  æ–‡æœ¬å¤„ç† - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  æ­£åˆ™è¡¨è¾¾å¼\n  ç³»ç»Ÿç›‘æ§ - jobs, ps, top, kill, free, demsg, lsof\n   å¦‚ä½•æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶æ˜¯å¦å®Œå…¨ç›¸åŒ?   diff or md5sum\n  å¦‚ä½•åˆ—å‡ºä¸€ä¸ªCè¯­è¨€é¡¹ç›®ä¸­æ‰€æœ‰è¢«åŒ…å«è¿‡çš„å¤´æ–‡ä»¶?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n du -h -d 1 2\u0026gt;/dev/null | grep -v denied ç£ç›˜åˆ†æ\n\ré…ç½®linux\næŸ¥çœ‹æœ€å¤§ç©ºé—´å ç”¨ç›®å½•\nsudo du -h \u0026ndash;exclude=\u0026ldquo;mnt*\u0026rdquo; \u0026ndash;exclude=\u0026ldquo;proc*\u0026rdquo; -d 1 /\np@ssw0rd\n"},{"id":39,"href":"/docs/cs/linux/wsl/","title":"W S L","section":"C S","content":"\rä¸ºWSL2åŠ å›¾å½¢åŒ–ç•Œé¢é…ç½®\nè¿è¡Œ startxfce4\n"},{"id":40,"href":"/docs/cs/network/","title":"Network","section":"C S","content":"Tools\r#\r\r \rWhois  "},{"id":41,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"Network","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":42,"href":"/docs/cs/operatingsystem/","title":"Operating System","section":"C S","content":" \ræ“ä½œç³»ç»Ÿå¯¼è®º(ostep)ç¬”è®°/è¯¾åä¹ é¢˜ç­”æ¡ˆ/é™„åŠ ä»£ç   "},{"id":43,"href":"/docs/cs/programming/","title":"Programming","section":"C S","content":" \rC \rJava \rGo \rC++ \rPython \rRust \rJavaScript \rScala \rKotlin \rWeb  "},{"id":44,"href":"/docs/cs/programming/c++/","title":"C++","section":"Programming","content":"Resources\r#\r\r \rC++é‚£äº›äº‹ \rå…³äºC++STLçš„æ€»ä½“ä»‹ç» \rCheat Sheets \u0026amp; Infographics \rç°ä»£ C++ æ•™ç¨‹  "},{"id":45,"href":"/docs/cs/programming/go/","title":"Go","section":"Programming","content":"Resources\r#\r\r \rGo by Example \rGoè¯­è¨€åœ£ç»ä¸­æ–‡ç‰ˆ Link \rLearn Go with Tests \rã€æœªæ¥æœåŠ¡å™¨ç«¯ç¼–ç¨‹è¯­è¨€ã€‘æœ€å…¨ç©ºé™golangèµ„æ–™è¡¥ç»™åŒ…ï¼ˆæ»¡è¡€æˆ˜æ–—ï¼‰ï¼ŒåŒ…å«æ–‡ç« ï¼Œä¹¦ç±ï¼Œä½œè€…è®ºæ–‡ï¼Œç†è®ºåˆ†æï¼Œå¼€æºæ¡†æ¶ï¼Œäº‘åŸç”Ÿï¼Œå¤§ä½¬è§†é¢‘ï¼Œå¤§å‚å®æˆ˜åˆ†äº«ppt \r1000+ Hand-Crafted Go Examples, Exercises, and Quizzes \rA Tuor of Go \rStandard Go Project Layout \rGo è¯­è¨€è®¾è®¡ä¸å®ç° \rã€ŠEffective Goã€‹ä¸­è‹±åŒè¯­ç‰ˆ \rGoè¯­è¨€é«˜çº§ç¼–ç¨‹ \rPractical Go Lessons \rA hands-on approach to getting started with Go generics. \rList of Golang books \r7 days golang programs from scratch \rGolangStudy: Golang é¢è¯•å­¦ä¹  \rGolangä»å…¥é—¨åˆ°è·‘è·¯  "},{"id":46,"href":"/docs/cs/programming/js/","title":"J S","section":"Programming","content":" \rç°ä»£ JavaScript æ•™ç¨‹  "},{"id":47,"href":"/docs/cs/programming/rust/","title":"Rust","section":"Programming","content":"Resources\r#\r\r \rWriting an OS in Rust \rRust ç¨‹åºè®¾è®¡è¯­è¨€ \rA book about Rust Data Structures and Algorithms. \rRustè¯­è¨€åœ£ç»  "},{"id":48,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"Rust","content":"Cargo\r#\r\r cargo new project-name  "},{"id":49,"href":"/docs/cs/resource/","title":"Resource","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \rğŸ“š List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCSå…¬å¼€è¯¾ç¨‹å­¦ä¹ ç¾¤è¯¾ç¨‹æ¨è \rå…‹è±ç™»å¤§å­¦CS(çƒ­å¿ƒç½‘å‹æ•´ç†) \rğŸ“ Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos \rå†™åœ¨20å¹´åˆçš„æ ¡æ‹›é¢è¯•å¿ƒå¾—ä¸è‡ªå­¦CSç»éªŒåŠæ‰¾å·¥ä½œåˆ†äº« \rTeach Yourself Programming in Ten Years \rCSè‡ªå­¦æŒ‡å— \rä»å°ç™½åˆ°BATåç«¯å·¥ç¨‹å¸ˆçš„è‡ªå­¦è·¯çº¿ \rA Self-Learning, Modern Computer Science Curriculum \råæ ¡å…¬å¼€è¯¾ç¨‹è¯„ä»·ç½‘ \rBest-websites-a-programmer-should-visit \rCS-Awesome-Courses \rcs-video-courses \rEvery Programmer Should Know  \rExplore, Create and Share Learning Roadmaps in Tech \rAlgorithms-Cheatsheet-Resources \rRoadmap \rRico\u0026rsquo;s cheatsheets \rA collection of the best resources for programming, web development, computer science and more. \rğŸ’»ğŸ“–å¯¹å¼€å‘äººå‘˜æœ‰ç”¨çš„å®šå¾‹ã€ç†è®ºã€åŸåˆ™å’Œæ¨¡å¼ \rç»™æ–°å‘˜å·¥å’Œå®ä¹ ç”Ÿçš„ç”Ÿå­˜æŒ‡å—  "},{"id":50,"href":"/docs/cs/software/","title":"Software","section":"C S","content":" \rä¸ºä»€ä¹ˆè¿™ä¹ˆè®¾è®¡ç³»åˆ—æ–‡ç«  \rsystem-design-primer \rThe Architecture of Open Source Applications \rMy favorite papers \rpapers-we-love  "},{"id":51,"href":"/docs/cs/tools/","title":"Tools","section":"C S","content":" \rRegular Expression \rMaven \rDocker \rGDB \rAwesome cheatsheets  "},{"id":52,"href":"/docs/cs/tools/docker/","title":"Docker","section":"Tools","content":"ä½¿ç”¨Dockeræä¾›æœ¬é¡¹ç›®çš„Mysqlå’ŒRedisæœåŠ¡\r#\r\rInstall\r#\r\rhttps://docs.docker.com/install/linux/docker-ce/centos/\nhttps://blog.csdn.net/weixin_39477597/article/details/87715899\nhttps://blog.csdn.net/weixin_43569697/article/details/89279225\nCMDä¸­å†™windowsè·¯å¾„ //c\n-v /c\\Users\\sunhu\\Documents\\Study\\Tool\\calibre-web\\books\nDocker å¯åŠ¨ã€é‡å¯ã€å…³é—­\r#\r\rå¼€æœºè‡ªå¯\nsystemctl enable docker\nsystemctl start docker\nå®ˆæŠ¤è¿›ç¨‹é‡å¯ systemctl daemon-reload\né‡å¯dockeræœåŠ¡ systemctl restart docker / service docker restart\nå…³é—­ docker service docker stop / docker systemctl stop docker\nåœç”¨å…¨éƒ¨è¿è¡Œä¸­çš„å®¹å™¨:\r#\r\rdocker stop $(docker ps -q)\nåˆ é™¤å…¨éƒ¨å®¹å™¨ï¼š\r#\r\rdocker rm $(docker ps -aq)\nä¸€æ¡å‘½ä»¤å®ç°åœç”¨å¹¶åˆ é™¤å®¹å™¨ï¼š\r#\r\rdocker stop $(docker ps -q) \u0026amp; docker rm $(docker ps -aq)\rå‘½ä»¤\r#\r\r docker images docker search \u0026lt;image_name\u0026gt; docker pull \u0026lt;åŸŸå\u0026gt;//: docker rmi : docker inspect \u0026lt;image_id\u0026gt; æŸ¥çœ‹å®¹å™¨ä¿¡æ¯  å®¹å™¨å‘½ä»¤\r#\r\r docker create \u0026lt;image_name\u0026gt; docker run \u0026lt;image_name\u0026gt; docker run ubuntu /bin/echo \u0026ldquo;Test\u0026rdquo; docker run \u0026ndash;name demo -d ubuntu docker stop \u0026lt;container_id\u0026gt; docker ps æŸ¥çœ‹è¿è¡Œä¸­çš„å®¹å™¨ docker ps -a åˆ—å‡ºå¯åŠ¨è¿‡çš„å®¹å™¨ å¯ä»¥ä½¿ç”¨starté‡æ–°å¯åŠ¨ docker start \u0026lt;container_id\u0026gt; å¯åŠ¨å®¹å™¨ docker rm \u0026lt;container_id\u0026gt; docker rm -f \u0026lt;container_id\u0026gt; docker container top  docker exec \u0026lt;container_id\u0026gt;  docker exec -it \u0026lt;container_id\u0026gt; bash ç™»é™†åˆ°å®¹å™¨ä¸­    æ¡ˆä¾‹\r#\r\rdocker run \u0026ndash;name mysqlsvr -p 12345:3306 -e MYSQL_ROOT_PASSWORD=sfy1314 -d mysql\ndocker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server \u0026ndash;appendonly yes\nå¼€æœºè‡ªå¯\ndocker run \u0026ndash;restart=always \u0026ndash;name first-mysql -p 12345:3306 -e MYSQL_ROOT_PASSWORD=sfy1314 -d mysql\nMongoDB\r#\r\rdocker run \u0026ndash;name mongo -p 27017:27017 -v ~/Desktop/docker/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo\nç™»å½•åˆ°MongoDBå®¹å™¨ä¸­\ndocker exec -it mongo bash\né€šè¿‡Shellè¿æ¥MongoDB\nmongo -u admin -p admin\nRdis\r#\r\rè·å–é•œåƒ\ndocker pull redis\nå¯åŠ¨Redis\ndocker run \u0026ndash;name redis -d -p 6379:6379 redis\ndocker exec -it \u0026lt;container_name\u0026gt; redis-cli\nNginx\r#\r\rdocker run \u0026ndash;restart always \u0026ndash;name my-nginx -p 80:80 -d nginx\nRabbitMQ\r#\r\r#æŒ‡å®šç‰ˆæœ¬ï¼Œè¯¥ç‰ˆæœ¬åŒ…å«äº†webæ§åˆ¶é¡µé¢\rdocker pull rabbitmq:management\rdocker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management\rElasticSearch\r#\r\rdocker run -d -p 9200:9200 elasticsearch\r"},{"id":53,"href":"/docs/cs/tools/gdb/","title":"G D B","section":"Tools","content":"Resources\r#\r\r \rç”¨GDBè°ƒè¯•ç¨‹åº \r100-gdb-tips  GCC\r#\r\r  -E è·å–é¢„å¤„ç†åçš„æ–‡ä»¶å†…å®¹\n  -V å°†ç¼–è¯‘ã€é“¾æ¥è¿‡ç¨‹æ‰“å°\n  -g ç”¨äºGDBè°ƒè¯•\n  ltrace å‘½ä»¤ç”¨æ¥è·Ÿè¸ªç¨‹åºè¿è¡Œæ—¶è°ƒç”¨çš„åº“å‡½æ•°\n -S æŸ¥çœ‹ç³»ç»Ÿè°ƒç”¨ -e trace=write åªçœ‹writeç³»ç»Ÿè°ƒç”¨  strace æŸ¥çœ‹ç³»ç»Ÿè°ƒç”¨çš„å°è£…å‡½æ•°\nGDB\r#\r\rSegment Faultå¿«é€Ÿå®šä½\né¦–å…ˆç”Ÿæˆcoreæ–‡ä»¶ ä½¿ç”¨ulimit -a æŸ¥çœ‹core file sizeä¸º0åˆ™æ˜¯ä¸ä¼šè¾“å‡º(æ”¹æˆä¸é™åˆ¶ ulimit -c unlimited) è¿è¡Œç¨‹åºå‡ºé”™åˆ™ä¼šè¾“å‡ºï¼Œè°ƒè¯•æ—¶gdb ./hello core  list start ctrl + x + a  "},{"id":54,"href":"/docs/cs/tools/git/","title":"Git","section":"Tools","content":"// åˆ é™¤æœ¬åœ°åˆ†æ”¯ git branch -d localBranchName\n// åˆ é™¤è¿œç¨‹åˆ†æ”¯ git push origin \u0026ndash;delete remoteBranchName\nä¿®æ”¹github æ—¥æœŸ\ngit commit\rgit cat-file -p HEAD \u0026gt; tmp.txt\r# at this point, edit the file to replace the timestamp\rgit hash-object -t commit -w tmp.txt\r#=\u0026gt; 2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rgit update-ref -m 'commit: foo' refs/heads/master \\\r2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rå–æ¶ˆè·Ÿè¸ª,åˆ é™¤è¿œç¨‹æ–‡ä»¶\ngit rm -r --cached .\rgit add .\rgit commit -m \u0026quot;update gitignore\u0026quot;\ré…ç½®å…¨å±€ä¿¡æ¯\n \u0026ndash;local\n git config \u0026ndash;global user.name \u0026ldquo;myname\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;test@gmail.com\u0026rdquo;\n"},{"id":55,"href":"/docs/cs/tools/jenkins/","title":"Jenkins","section":"Tools","content":"https://linuxize.com/post/how-to-install-jenkins-on-ubuntu-20-04/\nhttps://www.cnblogs.com/chenxiaomeng/p/11412038.html\nhttps://www.cnblogs.com/ding2016/p/12988080.html\nservice jenkins restart[start\\stop]\nsystemctl status jenkins\n"},{"id":56,"href":"/docs/cs/tools/maven/","title":"Maven","section":"Tools","content":"mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.12 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.12.jar\n"},{"id":57,"href":"/docs/cs/tools/npm/","title":"Npm","section":"Tools","content":"\rnpkill\n"},{"id":58,"href":"/docs/cs/tools/regularexpression/","title":"Regular Expression","section":"Tools","content":"Resources\r#\r\r \rRegexLearn  "},{"id":59,"href":"/docs/cs/tools/vim/","title":"Vim","section":"Tools","content":"https://missing-semester-cn.github.io/2020/editors/\nhttps://vimawesome.com/\n"},{"id":60,"href":"/docs/cs/tools/vscode/","title":"Vscode","section":"Tools","content":"WSLç›¸å…³\r#\r\rvscode server for wsl closed unexpectedly\nnetsh winsock reseté‡ç½®ç½‘ç»œ æˆ–ç§»é™¤wslä¸­çš„~/.vscode-server\n"},{"id":61,"href":"/docs/english/","title":"English","section":"Docs","content":"ç½‘ç«™\r#\r\r https://www.eapfoundation.com/ https://lyricstraining.com/ å¬æ­Œ http://skesl.com/ https://www.speechace.com/ å£è¯­ https://www.vocabulary.com/play/ å•è¯ \rThe New York Times æ–°é—» \rScienceDaily æ–°é—» https://english-e-reader.net/ å…è´¹åˆ†çº§ä¹¦ç± \rYouGlish å£è¯­ \rOGDEN\u0026rsquo;s BASIC ENGLISH \rLongman Dictionary \rèšåˆå·¥å…· https://www.languagereactor.com/ è§†é¢‘ \rHow to learn English \rLearn English ğŸ‡¬ğŸ‡§ğŸ‡ºğŸ‡¸  "},{"id":62,"href":"/docs/leetcode/","title":"Leet Code","section":"Docs","content":" \rCodeTop  ç›®å‰åˆ†ç±»ç›®å½•\r#\r\rå‰‘æŒ‡ Offer\r#\r\ré¢è¯•é¢˜ \r#\r\rå›½åŒºå‘¨å¯¨\r#\r\r  ç¬¬273åœº\n \r5963. åè½¬ä¸¤æ¬¡çš„æ•°å­—(E) \r5964. æ‰§è¡Œæ‰€æœ‰åç¼€æŒ‡ä»¤(M) \r5965. ç›¸åŒå…ƒç´ çš„é—´éš”ä¹‹å’Œ(M)    ç¬¬274åœº\n \r5967. æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ A éƒ½åœ¨ B ä¹‹å‰(E) \r5968. é“¶è¡Œä¸­çš„æ¿€å…‰æŸæ•°é‡(M) \r5969. æ‘§æ¯å°è¡Œæ˜Ÿ(M)    Dynamic Programming\r#\r\r \r10. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…(H) \r44. é€šé…ç¬¦åŒ¹é…(H) \r45. è·³è·ƒæ¸¸æˆ II(M) \r62. Unique Paths(M) \r63. Unique Paths II(M) \r64. Minimum Path Sum(M) \r91. Decode Ways(M) \r118. Pascal\u0026rsquo;s Triangle(E) \r119. Pascal\u0026rsquo;s Triangle II(E) \r120. Triangle(M) \r122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II(M) \r123. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III(H) \r198. æ‰“å®¶åŠ«èˆ(M) \r213. æ‰“å®¶åŠ«èˆ II(M) \r264. Ugly Number II(E) \r309. æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ(M) \r509. Fibonacci Number(M) \r714. Best Time to Buy and Sell Stock with Transaction Fee(M)  Tree\r#\r\r \r559. Maximum Depth of N-ary Tree(E) \r700. Search in a Binary Search Tree(E) \r102. äºŒå‰æ ‘çš„å±‚åºéå†(M)  Heap\r#\r\r \r1046. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡(E) \r347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ (M) \r451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº(M)  Math\r#\r\r \r43. å­—ç¬¦ä¸²ç›¸ä¹˜(M) \r384. Shuffle an Array(E) \r519. Random Flip Matrix(M) \r1979. Find Greatest Common Divisor of Array(E) \r812. Largest Triangle Area(E)   Combinatorics  \r39. ç»„åˆæ€»å’Œ(M) \r39. ç»„åˆæ€»å’Œ II(M) \r46. å…¨æ’åˆ—(M) \r47. å…¨æ’åˆ— II(M)    DFS\r#\r\r \r17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ(M) \r37. è§£æ•°ç‹¬(H) \r51. N çš‡å(H) \r52. N çš‡å II(H) \r139. Word Break(M)  Recursion\r#\r\r \r1492. The kth Factor of n(M)  BinarySearch\r#\r\r\r33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„(M) 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®(M) 35. æœç´¢æ’å…¥ä½ç½®(E)\nSorts\r#\r\r Quick Select  \r215. Kth Largest Element in an Array   Index Sort  \r41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°(H)    LinkedList\r#\r\r \r2. ä¸¤æ•°ç›¸åŠ (M) \r19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹(M) \r21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨(E) \r23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨(H) \r24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹(M) \r25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨(H)  Stack\r#\r\r \r20. æœ‰æ•ˆçš„æ‹¬å·(E) \r32. æœ€é•¿æœ‰æ•ˆæ‹¬å·(H)   Monotonic Stack   \r42. æ¥é›¨æ°´(H)  Hash Table\r#\r\r \r49. å­—æ¯å¼‚ä½è¯åˆ†ç»„(M)  Two Pointers\r#\r\r \r11. ç››æœ€å¤šæ°´çš„å®¹å™¨(M) \r15. ä¸‰æ•°ä¹‹å’Œ(M) \r16. æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ(M) \r18. å››æ•°ä¹‹å’Œ(M) \r26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹(E) \r27. ç§»é™¤å…ƒç´ (E)   Sliding window  \r3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²(M) \r4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°(H) \r30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²(H)    String\r#\r\r \r6. Z å­—å½¢å˜æ¢(M) \r8. å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi)(M) \r14. æœ€é•¿å…¬å…±å‰ç¼€(E)   Manacher  \r5. æœ€é•¿å›æ–‡å­ä¸²(M)   KMP  \r28. å®ç° strStr()(E)    Others\r#\r\r \r1. ä¸¤æ•°ä¹‹å’Œ(E) \r7. æ•´æ•°åè½¬(M) \r9. å›æ–‡æ•°(E) \r22. æ‹¬å·ç”Ÿæˆ(E) \r29. ä¸¤æ•°ç›¸é™¤(M) \r31. ä¸‹ä¸€ä¸ªæ’åˆ—(M) \r36. æœ‰æ•ˆçš„æ•°ç‹¬(M) \r48. æ—‹è½¬å›¾åƒ(M) \r50. Pow(x, n)(M) \r1005. Maximize Sum Of Array After K Negations(E) \r383. Ransom Note(E) \r748. Shortest Completing Word(E)  Simulation\r#\r\r \r12. æ•´æ•°è½¬ç½—é©¬æ•°å­—(M) \r13. ç½—é©¬æ•°å­—è½¬æ•´æ•°(E) \r38. å¤–è§‚æ•°åˆ—(M)  Design\r#\r\r \r355. è®¾è®¡æ¨ç‰¹(M) \r146. LRU ç¼“å­˜(M)  "},{"id":63,"href":"/docs/leetcode/binarysearch/33/","title":"33rd","section":"Leet Code","content":" \rLink\n public int search(int[] nums, int target) { // æ‰¾åˆ°åˆ†éš”ç‚¹, ä¸€åŠåŒºé—´æ»¡è¶³æ€§è´¨ï¼Œå¦ä¸€åŠåˆ™ä¸æ»¡è¶³  // 2 3 4 5 6 7, 1  // 6 7, 1 2 3 4 5  int l = 0, r = nums.length - 1; int mid; while (l \u0026lt; r) { mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= nums[0]) { l = mid; } else { r = mid - 1; } } // åˆ¤æ–­åœ¨å·¦åŠè¾¹ã€å³åŠè¾¹  if (target \u0026gt;= nums[0]) { l = 0; } else { l = r + 1; r = nums.length - 1; } while (l \u0026lt; r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[r] == target) return r; return -1; } "},{"id":64,"href":"/docs/leetcode/binarysearch/34/","title":"34th","section":"Leet Code","content":" \rLink\n class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int l = 0, r = nums.length - 1; int mid; while (l \u0026lt; r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[l] != target) { return new int[]{-1, -1}; } int[] res = new int[2]; res[0] = l; l = 0; r = nums.length - 1; while (l \u0026lt; r) { mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026lt;= target) { l = mid; } else { r = mid - 1; } } res[1] = l; return res; } } "},{"id":65,"href":"/docs/leetcode/binarysearch/35/","title":"35th","section":"Leet Code","content":" \rLink\n public int searchInsert(int[] nums, int target) { int lo = 0, hi = nums.length, mid = 0; while (lo \u0026lt; hi) { mid = (lo + hi) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { hi = mid; } else { lo = mid + 1; } } return lo; } "},{"id":66,"href":"/docs/leetcode/design/146/","title":"146th","section":"Leet Code","content":" \rLink\n ä½¿ç”¨javaçš„åŒå‘é“¾è¡¨LinkedListæœ‰å‘å•Šï¼Œè¿‡ä¸äº†ã€‚\nclass LRUCache { private int capacity; private DoubleList list; private Map\u0026lt;Integer, Node\u0026gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap\u0026lt;\u0026gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.get(key); node.val = value; list.remove(node); } else { node = new Node(value, key); if (map.size() == capacity) { // full  Node last = list.removeLast(); map.remove(last.key); } } list.addFirst(node); map.put(key, node); } } class DoubleList { Node head, tail; public DoubleList() { this.head = null; this.tail = null; } public void addFirst(Node node) { if (head == null) { this.head = node; this.tail = node; } else { node.prev = null; node.next = head; head.prev = node; head = node; } } public void remove(Node node) { if (node == head) { this.head = node.next; if (this.head != null) { this.head.prev = null; } } else if (node == tail) { this.tail = node.prev; if (this.tail != null) { this.tail.next = null; } } else { Node prev = node.prev; prev.next = node.next; prev.next.prev = prev; } } public Node removeLast() { Node res = this.tail; if (this.head == this.tail) { res = this.head; this.head = this.tail = null; } else { Node node = this.tail.prev; node.next = null; this.tail = node; } return res; } } class Node { int val; int key; Node prev; Node next; public Node(int val, int key) { this.val = val; this.key = key; } } "},{"id":67,"href":"/docs/leetcode/design/355/","title":"355th","section":"Leet Code","content":" \rLink\n class Twitter { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; follows; private Map\u0026lt;Integer, PriorityQueue\u0026lt;Integer\u0026gt;\u0026gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map\u0026lt;Integer, Integer\u0026gt; orders = new HashMap\u0026lt;\u0026gt;(); public Twitter() { follows = new HashMap\u0026lt;\u0026gt;(); tweets = new HashMap\u0026lt;\u0026gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue\u0026lt;Integer\u0026gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue\u0026lt;Integer\u0026gt;((a, b) -\u0026gt; b - a); tweets.put(userId, tmp); } int key = ai.incrementAndGet(); orders.put(key, tweetId); tmp.offer(key); } public List\u0026lt;Integer\u0026gt; getNewsFeed(int userId) { List\u0026lt;Integer\u0026gt; followees = follows.get(userId); PriorityQueue\u0026lt;Integer\u0026gt; tmp = new PriorityQueue\u0026lt;\u0026gt;(); if (followees != null) { for (int followeeId : followees) { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(followeeId); if (t != null) { updateTop10Data(t, tmp); } } } else { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(userId); if (t != null) { updateTop10Data(t, tmp); } } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (tmp.size() \u0026gt; 0) { res.add(0, orders.get(tmp.poll())); } return res; } private void updateTop10Data(PriorityQueue\u0026lt;Integer\u0026gt; data, PriorityQueue\u0026lt;Integer\u0026gt; res) { for (int d : data) { if (res.size() \u0026gt;= 10) { if (res.peek() \u0026lt; d) { res.poll(); res.offer(d); } } else { res.offer(d); } } } public void follow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); tmp.add(followerId); follows.put(followerId, tmp); } if (tmp.contains(followeeId)) { return; } tmp.add(followeeId); } public void unfollow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { return; } tmp.remove(new Integer(followeeId)); } } "},{"id":68,"href":"/docs/leetcode/dfs/139/","title":"139th","section":"Leet Code","content":" \rLink\n éå†å­—ç¬¦ä¸²ï¼Œå°†å…¶åˆ†æˆä¸¤éƒ¨åˆ†leftå’Œrightï¼Œåˆ¤æ–­æ˜¯å¦éƒ½åœ¨wordListé‡Œã€‚\nåŠ ä¸Šè®°å¿†åŒ–\npublic boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(wordDict); Map\u0026lt;String, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set\u0026lt;String\u0026gt; set, Map\u0026lt;String, Boolean\u0026gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i \u0026lt; n; i++) { String left = s.substring(0, i); String right = s.substring(i, n); if (set.contains(left) \u0026amp;\u0026amp; dfs(right, set, map)) { map.put(s, true); return true; } } map.put(s, false); return false; } æœ€ä½³å®è·µï¼šä½¿ç”¨Trie\npublic class TreeNode { TreeNode[] children; boolean isWord; char value; TreeNode() { children = new TreeNode[26]; } } private TreeNode root = new TreeNode(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { TreeNode node = root; for (char c : word.toCharArray()) { if (node.children[c - \u0026#39;a\u0026#39;] == null) { node.children[c - \u0026#39;a\u0026#39;] = new TreeNode(); } node.children[c - \u0026#39;a\u0026#39;].value = c; node = node.children[c - \u0026#39;a\u0026#39;]; } node.isWord = true; } return dfs(s, 0); } private int[] memo = new int[301]; private boolean dfs(String s, int cur) { // s[cur:]  int n = s.length(); if (cur \u0026gt;= n) return true; if (memo[cur] == 1) return false; TreeNode node = root; for (int i = cur; i \u0026lt; n; i++) { TreeNode tmp = node.children[s.charAt(i) - \u0026#39;a\u0026#39;]; node = tmp; if (tmp != null) { if (tmp.isWord \u0026amp;\u0026amp; dfs(s, i + 1)) { return true; } } else { break; } } memo[cur] = 1; return false; } "},{"id":69,"href":"/docs/leetcode/dfs/17/","title":"17th","section":"Leet Code","content":" \rLink\n ä½¿ç”¨StringBuilderä¼˜åŒ–å­—ç¬¦ä¸²copy\nclass Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), new StringBuilder()); return res; } private void dfs(String digits, int pos, int len, StringBuilder cur) { if (pos == len) { res.add(cur.toString()); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { cur.append(c); dfs(digits, pos + 1, len, cur); cur.deleteCharAt(cur.length() - 1); } } } } class Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), \u0026#34;\u0026#34;); return res; } private void dfs(String digits, int pos, int len, String cur) { if (pos == len) { res.add(cur); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { dfs(digits, pos + 1, len, cur + c); } } } } "},{"id":70,"href":"/docs/leetcode/dfs/37/","title":"37th","section":"Leet Code","content":" \rLink\n class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init  for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;1\u0026#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] != \u0026#39;.\u0026#39;) return dfs(board, x, y + 1); for (int i = 0; i \u0026lt; 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x / 3][y / 3][i]) { board[x][y] = (char)(i + \u0026#39;1\u0026#39;); row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if (dfs(board, x, y + 1)) { return true; } board[x][y] = \u0026#39;.\u0026#39;; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; } } "},{"id":71,"href":"/docs/leetcode/dfs/51/","title":"51st","section":"Leet Code","content":" \rLink\n class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; int n; vector\u0026lt;bool\u0026gt; col, dg, udg; vector\u0026lt;string\u0026gt; path; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int _n) { n = _n; col = vector\u0026lt;bool\u0026gt;(n); dg = vector\u0026lt;bool\u0026gt;(n * 2); udg = vector\u0026lt;bool\u0026gt;(n * 2); path = vector\u0026lt;string\u0026gt;(n, string(n, \u0026#39;.\u0026#39;)); dfs(0); return res; } void dfs(int u) { if (u == n) { res.push_back(path); return; } for (int i = 0; i \u0026lt; n; i++) { if (!col[i] \u0026amp;\u0026amp; !dg[u + i] \u0026amp;\u0026amp; !udg[u - i + n]) { col[i] = dg[u + i] = udg[u - i + n] = true; path[u][i] = \u0026#39;Q\u0026#39;; dfs(u + 1); path[u][i] = \u0026#39;.\u0026#39;; col[i] = dg[u + i] = udg[u - i + n] = false; } } } }; "},{"id":72,"href":"/docs/leetcode/dfs/52/","title":"52nd","section":"Leet Code","content":" \rLink\n class Solution { boolean[] col, dg, udg; int n; public int totalNQueens(int n) { this.n = n; col = new boolean[n]; dg = new boolean[n * 2]; udg = new boolean[n * 2]; return dfs(0); } private int dfs(int u) { if (u == n) { return 1; } int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (!col[i] \u0026amp;\u0026amp; !dg[u - i + n] \u0026amp;\u0026amp; !udg[u + i]) { col[i] = dg[u - i + n] = udg[u + i] = true; res += dfs(u + 1); col[i] = dg[u - i + n] = udg[u + i] = false; } } return res; } } "},{"id":73,"href":"/docs/leetcode/dfs/5964/","title":"5964th","section":"Leet Code","content":" TODO: Link\n class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i \u0026lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i \u0026lt; len; i++) { if (checkAndRun(pos, s.charAt(i))) { res++; } else { break; } } return res; } private boolean checkAndRun(int[] pos, char c) { if (c == \u0026#39;U\u0026#39;) { if (pos[0] != 0) { pos[0]--; return true; } } else if (c == \u0026#39;R\u0026#39;) { if (pos[1] != (n - 1)) { pos[1]++; return true; } } else if (c == \u0026#39;L\u0026#39;) { if (pos[1] != 0) { pos[1]--; return true; } } else if (c == \u0026#39;D\u0026#39;) { if (pos[0] != (n - 1)) { pos[0]++; return true; } } return false; } } "},{"id":74,"href":"/docs/leetcode/dynamicprogramming/10/","title":"10th","section":"Leet Code","content":" \rLink\n public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // è¡¨ç¤º dp[i][j] = s[1..i] å’Œ p[1...j]æ˜¯å¦ç›¸ç­‰  boolean[][] dp = new boolean[m + 1][n + 1]; s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; dp[0][0] = true; for (int i = 0; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (j + 1 \u0026lt;= n \u0026amp;\u0026amp; p.charAt(j + 1) == \u0026#39;*\u0026#39;) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; p.charAt(j) != \u0026#39;*\u0026#39;) { dp[i][j] = dp[i - 1][j - 1] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == \u0026#39;.\u0026#39;); } else if (p.charAt(j) == \u0026#39;*\u0026#39;) { /** dp[i][j] = dp[i][j-2] || (dp[i-1][j-2] \u0026amp;\u0026amp; s[i]==p[j-1]) || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1]==p[j-1] \u0026amp;\u0026amp; s[i]==p[j-1]) dp[i-1][j] = dp[i-1][j-2] || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1] == p[j-1]) dp[i][j] = dp[i][j-2] || (dp[i-1][j] \u0026amp;\u0026amp; s[i]==p[j-1]) */ dp[i][j] = dp[i][j - 2] || (i \u0026gt; 0 \u0026amp;\u0026amp; dp[i - 1][j] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j - 1) || p.charAt(j - 1) == \u0026#39;.\u0026#39;)); } } } return dp[m][n]; } "},{"id":75,"href":"/docs/leetcode/dynamicprogramming/118/","title":"118th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i \u0026lt;= numRows; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= numRows; i++) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (int j = 1; j \u0026lt;= i; j++) { tmp.add(dp[i][j]); } ans.add(tmp); } return ans; } } "},{"id":76,"href":"/docs/leetcode/dynamicprogramming/119/","title":"119th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;Integer\u0026gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row \u0026lt;= rowIndex; row++) { for (int col = 1; col \u0026lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int col = 1; col \u0026lt;= rowIndex; col++) { ans.add(dp[rowIndex][col]); } return ans; } } è¿›é˜¶ä¼˜åŒ–ç©ºé—´ï¼šO(rowIndex)\nclass Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { vector\u0026lt;int\u0026gt; ans(rowIndex + 1, 1); for (int i = 0; i \u0026lt;= rowIndex; i++) { for (int j = i - 1; j \u0026gt;= 1; j--) { ans[j] = ans[j] + ans[j - 1]; } } return ans; } }; "},{"id":77,"href":"/docs/leetcode/dynamicprogramming/120/","title":"120th","section":"Leet Code","content":" \rLink\n DP è¦ä»ä¸‹å¾€ä¸Šæ‰¾ï¼Œå¦åˆ™ä¸ä¸€å®šæ˜¯å…¨å±€æœ€ä¼˜\n2 3 4 6 5 1 4 1 8 3\nclass Solution { public int minimumTotal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j \u0026lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt;= i; j++) { dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); } } return dp[0][0]; } } "},{"id":78,"href":"/docs/leetcode/dynamicprogramming/122/","title":"122nd","section":"Leet Code","content":" \rLink\n å¯ä»¥æŠŠæ•°æ®çœ‹æˆæŠ˜çº¿å›¾ï¼Œåˆ™æ‰€æœ‰ä¸Šå‡ä¹‹å’Œä¸ºè§£\npublic int maxProfit(int[] prices) { int res = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP\npublic int maxProfit(int[] prices) { int n = prices.length; // ç¬¬iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦  int[] dp1 = new int[n]; // ç¬¬iå¤©å–æ‰çš„æœ€å¤§åˆ©æ¶¦  int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i \u0026lt; n; i++) { // å¯ä»¥ä¸ä¹°æˆ–å–  dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] + prices[i]); } return dp2[n - 1]; } "},{"id":79,"href":"/docs/leetcode/dynamicprogramming/123/","title":"123rd","section":"Leet Code","content":" \rLink\n public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: æŒæœ‰ç¬¬ä¸€è‚¡çš„æœ€å¤§åˆ©ç›Š  // dp[0][1]: å”®å‡ºç¬¬ä¸€è‚¡çš„æœ€å¤§åˆ©ç›Š  // dp[0][2]: æŒæœ‰ç¬¬äºŒè‚¡çš„æœ€å¤§åˆ©ç›Š  // dp[0][3]: å”®å‡ºç¬¬äºŒè‚¡çš„æœ€å¤§åˆ©ç›Š  int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i \u0026lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i - 1]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i - 1]); } return Math.max(dp[n][1], dp[n][3]); } "},{"id":80,"href":"/docs/leetcode/dynamicprogramming/198/","title":"198th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: ç¬¬ä¸€ä¸ªæˆ¿é—´æŠ¢  // dp[0][1]: ç¬¬ä¸€ä¸ªæˆ¿é—´ä¸æŠ¢  int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } "},{"id":81,"href":"/docs/leetcode/dynamicprogramming/213/","title":"213th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j)  private int help(int[] nums, int i, int j) { // 0 : æŠ¢  // 1 : ä¸æŠ¢  int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i \u0026lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[j - 1][0], dp[j - 1][1]); } } "},{"id":82,"href":"/docs/leetcode/dynamicprogramming/264/","title":"264th","section":"Leet Code","content":" \rLink\n ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼Œä»é›†åˆ[1]å¼€å§‹ï¼Œæ¯æ¬¡é€‰å–é›†åˆå†…æœ€å°çš„å…ƒç´ x ç”Ÿæˆ[2x, 3x, 5x]\n[1] -\u0026gt; [2 3 5] -\u0026gt; [3 4 5 6 10] -\u0026gt; \u0026hellip;\nclass Solution { // Time Complexity: O(3N * lg3N)  // æ¯æ¬¡äº§ç”Ÿ æœ€å°æ•°çš„2ã€3ã€5å€æ•°  public int nthUglyNumber(int n) { PriorityQueue\u0026lt;Long\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); q.add(1L); long top = -1L; for (int i = 0; i \u0026lt; n; i++) { top = q.peek(); while (!q.isEmpty() \u0026amp;\u0026amp; q.peek() == top) { q.poll(); } q.add(top * 2); q.add(top * 3); q.add(top * 5); } return (int)top; } } dpæ€æƒ³ï¼Œå¯¹äºä»»ä½•ä¸‘æ•°ï¼Œå®ƒåªèƒ½ç”±æŸä¸€ä¸ªä¸‘æ•°x x2ã€x3ã€x*5é‡Œå¾—åˆ°ã€‚\nå®šä¹‰ä¸‰ä¸ªæŒ‡é’ˆiã€jã€kæ¥å®šè·Ÿè¸ªä¸‘æ•°çš„å¤§å°ã€‚\nnums X X X X X X idx2 ^\ridx3 ^\ridx5 ^\rclass Solution { // Time Complexity: O(n);  public int nthUglyNumber(int n) { int i = 0, j = 0, k = 0; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); res.add(1); for (int v = 0; v \u0026lt; n; v++) { int cur = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5)); res.add(cur); if (cur == res.get(i) * 2) i++; if (cur == res.get(j) * 3) j++; if (cur == res.get(k) * 5) k++; } return res.get(n - 1); } } "},{"id":83,"href":"/docs/leetcode/dynamicprogramming/309/","title":"309th","section":"Leet Code","content":" \rLink\n DP\npublic int maxProfit(int[] prices) { int n = prices.length; // iå¤©å–å‡ºçš„æœ€å¤§åˆ©æ¶¦  int[] dp1 = new int[n + 1]; // iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦  int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { // ç¬¬iå¤©å–å‡ºçš„æœ€å¤§åˆ©æ¶¦ = max(å‰å¤©ä¹°å…¥ä»Šå¤©å–å‡º, å‰å¤©å–å‡º)  dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // ç¬¬iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦ = max(å‰å¤©ä¹°å…¥, å‰ä¸¤å¤©å–å‡ºä»Šå¤©ä¹°å…¥)  dp2[i] = Math.max(dp2[i - 1], dp1[i - 2] - prices[i - 1]); } return dp1[n]; } "},{"id":84,"href":"/docs/leetcode/dynamicprogramming/44/","title":"44th","section":"Leet Code","content":" \rLink\n f[i][j]ï¼šè¡¨ç¤ºs[0..i]å’Œp[0..j]æ˜¯å¦åŒ¹é…\npublic boolean isMatch(String s, String p) { int m = s.length(), n = p.length(); s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (p.charAt(j) == \u0026#39;*\u0026#39;) { f[i][j] = (i \u0026gt; 0 \u0026amp;\u0026amp; f[i - 1][j]) || f[i][j - 1]; } else { f[i][j] = i \u0026gt; 0 \u0026amp;\u0026amp; f[i - 1][j - 1] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == \u0026#39;?\u0026#39;); } } } return f[m][n]; } "},{"id":85,"href":"/docs/leetcode/dynamicprogramming/45/","title":"45th","section":"Leet Code","content":" \rLink\n public int jump(int[] nums) { int n = nums.length; // f[i]: æœ€å°‘çš„è·³è·ƒæ¬¡æ•°åˆ°è¾¾i  int[] f = new int[n]; for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j + nums[j] \u0026lt; i) j++; f[i] = f[j] + 1; } return f[n - 1]; } "},{"id":86,"href":"/docs/leetcode/dynamicprogramming/509/","title":"509th","section":"Leet Code","content":" \rLink\n public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i \u0026lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; } "},{"id":87,"href":"/docs/leetcode/dynamicprogramming/62/","title":"62nd","section":"Leet Code","content":" \rLink\n DP\ndp[i][j] è¡¨ç¤ºèƒ½åˆ°iè¡Œjåˆ—ä¸åŒè·¯å¾„ä¸ªæ•°\nåˆå§‹åŒ–ç¬¬ä¸€è¡Œå’Œå’Œç¬¬ä¸€åˆ—ä¸º1\nclass Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { dp[i][1] = 1; } for (int j = 1; j \u0026lt;= n; j++) { dp[1][j] = 1; } for (int i = 2; i \u0026lt;= m; i++) { for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } DFS+è®°å¿†åŒ–\nclass Solution { public int uniquePaths(int m, int n) { int[][] memo = new int[m][n]; return dfs(0, 0, m, n, memo); } private int dfs(int i, int j, int m, int n, int[][] memo) { if (i \u0026gt;= m || j \u0026gt;= n || i \u0026lt; 0 || j \u0026lt; 0) { return 0; } if (memo[i][j] != 0) { return memo[i][j]; } if (i == m - 1 \u0026amp;\u0026amp; j == n - 1) { return 1; } int res = dfs(i + 1, j, m, n, memo) + dfs(i, j + 1, m, n, memo); memo[i][j] = res; return res; } } "},{"id":88,"href":"/docs/leetcode/dynamicprogramming/63/","title":"63rd","section":"Leet Code","content":" \rLink\n åŒ\r62é¢˜é¢˜æ€è·¯ä¸€æ ·\nç›´æ¥çœ‹DPè§£æ³•ï¼Œæ³¨æ„åˆå§‹åŒ–ï¼Œæœ‰éšœç¢ç‰©æ—¶ï¼Œå°±ä¸èƒ½å¾€åèµ°äº†\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } "},{"id":89,"href":"/docs/leetcode/dynamicprogramming/64/","title":"64th","section":"Leet Code","content":" \rLink\n dp[i][j] è¡¨ç¤ºåˆ°iè¡Œjåˆ—æœ€å°æ€»å’Œ æ³¨æ„åˆå§‹åŒ–\nclass Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int k = i; k \u0026gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j \u0026lt; n; j++) { for (int k = j; k \u0026gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } "},{"id":90,"href":"/docs/leetcode/dynamicprogramming/714/","title":"714th","section":"Leet Code","content":" \rLink\n ç¬¬iå¤©ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦buy[i]\nå–å‡ºçš„æœ€å¤§åˆ©æ¶¦sell[i]\nå–å‡ºçš„æ—¶å€™(å®Œæˆäº†ä¸€ç¬”äº¤æ˜“)å‡å»æ‰‹ç»­è´¹\nclass Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } } "},{"id":91,"href":"/docs/leetcode/dynamicprogramming/91/","title":"91st","section":"Leet Code","content":" \rLink\n DFSæœç´¢ + è®°å¿†åŒ– class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numDecodings(String s) { if (s == null ||ï½“.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i \u0026gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i \u0026lt; n - 1 \u0026amp;\u0026amp; isValid(s.substring(i, i + 2))) { res += dfs(s, i + 2); } memo.put(s.substring(i), res); return res; } private boolean isValid(String s) { int val = Integer.valueOf(s); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } private boolean isValid(char c) { int t = c - \u0026#39;0\u0026#39;; return 1 \u0026lt;= t \u0026amp;\u0026amp; t \u0026lt;= 26; } } DP\n\rclass Solution { public int numDecodings(String s) { s = \u0026#34;#\u0026#34; + s; int n = s.length(); // dp[i] = s[0]..s[i]è§£ç æ–¹å¼  int[] dp = new int[n]; dp[0] = 1; dp[1] = (s.charAt(1) == \u0026#39;0\u0026#39;) ? 0 : 1; for (int i = 2; i \u0026lt; n; i++) { if (!isValid(s.charAt(i)) \u0026amp;\u0026amp; !isValid(s.charAt(i - 1), s.charAt(i))) { return 0; } if (isValid(s.charAt(i))) { dp[i] = dp[i - 1]; } if (isValid(s.charAt(i - 1), s.charAt(i))) { dp[i] += dp[i - 2]; } } return dp[n - 1]; } private boolean isValid(char c) { return \u0026#39;1\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } private boolean isValid(char a, char b) { int val = (a - \u0026#39;0\u0026#39;) * 10 + (b - \u0026#39;0\u0026#39;); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } } "},{"id":92,"href":"/docs/leetcode/hashtable/49/","title":"49th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String str : strs) { String oldStr = str; char[] chs = str.toCharArray(); Arrays.sort(chs); str = new String(chs); List\u0026lt;String\u0026gt; tmp = map.getOrDefault(str, null); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); map.put(str, tmp); } tmp.add(oldStr); } List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (var e : map.entrySet()) { res.add(e.getValue()); } return res; } "},{"id":93,"href":"/docs/leetcode/heap/1046/","title":"1046th","section":"Leet Code","content":" \rLink\n // Time Complexity: O(nlogn)  // Space Complexity: O(n)  public int lastStoneWeight(int[] stones) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() \u0026gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.poll(); } "},{"id":94,"href":"/docs/leetcode/heap/347/","title":"347th","section":"Leet Code","content":" \rLink\n public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() \u0026gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!pq.isEmpty()) { res[idx++] = pq.poll(); } return res; } "},{"id":95,"href":"/docs/leetcode/heap/451/","title":"451st","section":"Leet Code","content":" \rLink\n public String frequencySort(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue\u0026lt;Character\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i \u0026lt; n; i++) { sb.append(c); } } return sb.toString(); } "},{"id":96,"href":"/docs/leetcode/linkedlist/19/","title":"19th","section":"Leet Code","content":" \rLink\n public ListNode removeNthFromEnd(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; int n = 0; while (head != null) { n++; head = head.next; } ListNode prev = dummy; for (int i = 0; i \u0026lt; (n - k); i++) { prev = prev.next; } prev.next = prev.next.next; return dummy.next; } "},{"id":97,"href":"/docs/leetcode/linkedlist/2/","title":"2nd","section":"Leet Code","content":" \rLink\n public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode curr = dummy; int t = 0; while (l1 != null || l2 != null || t != 0) { if (l1 != null) { t += l1.val; l1 = l1.next; } if (l2 != null) { t += l2.val; l2 = l2.next; } curr.next = new ListNode(t % 10); t /= 10; curr = curr.next; } return dummy.next; } "},{"id":98,"href":"/docs/leetcode/linkedlist/21/","title":"21st","section":"Leet Code","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode prev = dummy; while (l1 != null \u0026amp;\u0026amp; l2 != null) { if (l1.val \u0026lt; l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } if (l1 != null) { prev.next = l1; } if (l2 != null) { prev.next = l2; } return dummy.next; } "},{"id":99,"href":"/docs/leetcode/linkedlist/23/","title":"23rd","section":"Leet Code","content":" \rLink\n class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode dummy = new ListNode(); PriorityQueue\u0026lt;ListNode\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); for (var l : lists) { if (l != null) { // ç¤ºä¾‹3 ç‰¹ä¾‹  minHeap.offer(l); } } ListNode tail = dummy; while (!minHeap.isEmpty()) { ListNode cur = minHeap.poll(); tail.next = cur; tail = tail.next; cur = cur.next; if (cur != null) { minHeap.offer(cur); } } return dummy.next; } } "},{"id":100,"href":"/docs/leetcode/linkedlist/24/","title":"24th","section":"Leet Code","content":" \rLink\n public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy; p.next != null \u0026amp;\u0026amp; p.next.next != null;) { ListNode a = p.next; ListNode b = p.next.next; p.next = b; a.next = b.next; b.next = a; p = a; } return dummy.next; } "},{"id":101,"href":"/docs/leetcode/linkedlist/25/","title":"25th","section":"Leet Code","content":" \rLink\n public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy;;) { int n = 0; for (ListNode t = p.next; t != null; t = t.next) { n++; } if (n \u0026lt; k) { break; } // ç¿»è½¬kä¸ªèŠ‚ç‚¹  ListNode a = p.next, b = p.next.next; for (int i = 0; i \u0026lt; k - 1; i++) { var c = b.next; b.next = a; a = b; b = c; } var c = p.next; p.next = a; c.next = b; p = c; } return dummy.next; } "},{"id":102,"href":"/docs/leetcode/math/1979/","title":"1979th","section":"Leet Code","content":" \rLink\n public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a \u0026gt; b  private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); } "},{"id":103,"href":"/docs/leetcode/math/384/","title":"384th","section":"Leet Code","content":" \rLink\n å¸¸è§„æ´—ç‰Œç®—æ³•ï¼Œæ€è·¯ï¼šå¯¹nä¸ªæ•°éšæœºé€‰ä¸€ä¸ªä¸ç¬¬ä¸€ä¸ªæ•°äº¤æ¢ï¼Œé™¤å»ç¬¬ä¸€ä¸ªæ•°çš„n-1ä¸ªæ•°åŒæ ·æ“ä½œã€‚\nç¬¬ä¸€è½®ï¼š1/n\nç¬¬äºŒè½®ï¼š(n-1)/n * 1/(n-1)\nç¬¬ä¸‰è½®ï¼š(n-1)/n * (n-2)/(n-1) * 1/(n-2)\nâ€¦â€¦â€¦â€¦\nprivate int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i \u0026lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; } "},{"id":104,"href":"/docs/leetcode/math/39/","title":"39th","section":"Leet Code","content":" \rLink\n List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList\u0026lt;\u0026gt;(), 0); return res; } private void dfs(int[] candidates, int target, List\u0026lt;Integer\u0026gt; cur, int s) { if (target \u0026lt; 0) { return; } if (target == 0) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = s; i \u0026lt; candidates.length; i++) { if (candidates[i] \u0026gt; target) break; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i); cur.remove(cur.size() - 1); } } "},{"id":105,"href":"/docs/leetcode/math/40/","title":"40th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList\u0026lt;\u0026gt;(), 0); return res; } private void dfs(int[] candidates, int target, List\u0026lt;Integer\u0026gt; cur, int s) { if (target == 0) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = s; i \u0026lt; candidates.length; i++) { if (candidates[i] \u0026gt; target) break; if (i \u0026gt; s \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) continue; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i + 1); cur.remove(cur.size() - 1); } } } "},{"id":106,"href":"/docs/leetcode/math/43/","title":"43rd","section":"Leet Code","content":" \rLink\n string multiply(string num1, string num2) { int n = num1.size(), m = num2.size(); vector\u0026lt;int\u0026gt; A, B; for (int i = n - 1; i \u0026gt;= 0; i--) A.push_back(num1[i] - \u0026#39;0\u0026#39;); for (int i = m - 1; i \u0026gt;= 0; i--) B.push_back(num2[i] - \u0026#39;0\u0026#39;); vector\u0026lt;int\u0026gt; C(n + m); for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) C[i + j] += A[i] * B[j]; for (int i = 0, t = 0; i \u0026lt; C.size(); i++) { t += C[i]; C[i] = t % 10; t /= 10; } int k = C.size() - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; C[k] == 0) k--; string res; while (k \u0026gt;= 0) res += (C[k--] + \u0026#39;0\u0026#39;); return res; } public String multiply(String num1, String num2) { int n = num1.length(), m = num2.length(); int[] A = new int[n]; int[] B = new int[m]; int idx = 0; for (int i = n - 1; i \u0026gt;= 0; i--) { A[idx++] = num1.charAt(i) - \u0026#39;0\u0026#39;; } idx = 0; for (int i = m - 1; i \u0026gt;= 0; i--) { B[idx++] = num2.charAt(i) - \u0026#39;0\u0026#39;; } int[] C = new int[n + m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { C[i + j] += A[i] * B[j]; } } for (int i = 0, t = 0; i \u0026lt; C.length; i++) { t += C[i]; C[i] = t % 10; t /= 10; } int k = C.length - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; C[k] == 0) k--; StringBuilder sb = new StringBuilder(); while (k \u0026gt;= 0) { sb.append(C[k--]); } return sb.toString(); } "},{"id":107,"href":"/docs/leetcode/math/46/","title":"46th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); boolean[] st; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { st = new boolean[nums.length]; dfs(new ArrayList\u0026lt;\u0026gt;(), nums); return res; } private void dfs(List\u0026lt;Integer\u0026gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (st[i]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } } "},{"id":108,"href":"/docs/leetcode/math/47/","title":"47th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); boolean[] st; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { Arrays.sort(nums); st = new boolean[nums.length]; dfs(new ArrayList\u0026lt;\u0026gt;(), nums); return res; } private void dfs(List\u0026lt;Integer\u0026gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (st[i]) continue; if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !st[i - 1]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } } "},{"id":109,"href":"/docs/leetcode/math/519/","title":"519th","section":"Leet Code","content":" \rLink\n class Solution { private int m; private int n; private int count; private Map\u0026lt;Integer, Integer\u0026gt; map; /** è½¬æˆä¸€ç»´æ•°ç»„ ç´¢å¼•i ç›¸å½“äº=\u0026gt; [i/n][i%n]ï¼Œå¹¶ç”¨Mapåªè®°å½•è¢«é€‰ä¸­çš„ä¿¡æ¯ï¼ˆæ€è·¯ç±»ä¼¼384ï¼Œä½†æ˜¯ä¿å­˜æ‰€æœ‰æ•°ä¼šè¶…å‡ºå†…å­˜é™åˆ¶ï¼‰: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =\u0026gt; 5 =\u0026gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =\u0026gt; 6 =\u0026gt; 3 map[5] = 4 map[3] = map[4] = 5 ... ... */ public Solution(int m, int n) { this.m = m; this.n = n; this.count = 0; this.map = new HashMap\u0026lt;\u0026gt;(); } public int[] flip() { int k = (int)(Math.random() * (m * n - count)); int res = 0; if (map.get(k) == null) { res = k; } else { res = map.get(k); } int lastIdx = m * n - count - 1; if (map.get(lastIdx) != null) { map.put(k, map.get(lastIdx)); } else { map.put(k, lastIdx); } count++; return new int[]{res / n, res % n}; } public void reset() { map.clear(); count = 0; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(m, n); * int[] param_1 = obj.flip(); * obj.reset(); */ "},{"id":110,"href":"/docs/leetcode/math/812/","title":"812th","section":"Leet Code","content":" \rLink\n çœ‹è¯„è®ºåŒºéƒ½ç”¨çº¿æ€§ä»£æ•°ï¼Œæ²¡å­¦è¿‡çº¿æ€§ä»£æ•°çš„æˆ‘ï¼Œæ³ªç›®äº†å“­ï¼\npublic double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i \u0026lt; points.length; i++) { for (int j = i + 1; j \u0026lt; points.length; j++) { for (int k = j + 1; k \u0026lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp \u0026gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b \u0026gt; c) || (a + c \u0026gt; b) || (b + c) \u0026gt; a; } // æœæ–­æ‰¾ä¸ªå…¬å¼ï¼Œæµ·ä¼¦å…¬å¼  private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.sqrt(p * (p - a) * (p - b) * (p - c)); } private double length(int[] p1, int[] p2) { return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)); } "},{"id":111,"href":"/docs/leetcode/others/1/","title":"1st","section":"Leet Code","content":" \rLink\n public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int another = target - nums[i]; if (map.containsKey(another)) { return new int[]{i, map.get(another)}; } map.put(nums[i], i); } return null; } "},{"id":112,"href":"/docs/leetcode/others/1005/","title":"1005th","section":"Leet Code","content":" \rLink\n å†™çš„å®åœ¨æ˜¯å¤ªä¸‘é™‹äº†, å¤ªå¤šè¾¹ç•Œæ¡ä»¶ä¸æ˜“å†™\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // æœ€å°\u0026gt;0çš„æ•°ç´¢å¼•  for (int n : nums) { if (n \u0026lt; 0) i++; else break; } int j = i - 1; // æœ€å¤§è´Ÿæ•°ç´¢å¼•  int negCount = i; int idx = negCount - i; while (k \u0026gt; 0) { if (negCount \u0026gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i \u0026lt; nums.length \u0026amp;\u0026amp; nums[i] == 0) break; if ( i \u0026gt;= nums.length || (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt; nums[j])) { nums[j] = -nums[j]; } else { nums[i] = -nums[i]; } } k--; } int sum = 0; for (int n : nums) { sum += n; } return sum; } } ä¼˜å…ˆé˜Ÿåˆ—è§£æ³•(æœ€å°å †)\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int n : nums) { q.add(n); } while (k \u0026gt; 0) { q.add(0 - q.poll()); k--; } int sum = 0; while (!q.isEmpty()) { sum += q.poll(); } return sum; } } "},{"id":113,"href":"/docs/leetcode/others/22/","title":"22nd","section":"Leet Code","content":" \rLink\n class Solution { private List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; generateParenthesis(int n) { dfs(n, 0, 0, \u0026#34;\u0026#34;); return res; } private void dfs(int n, int open, int closed, String s) { if (open == n \u0026amp;\u0026amp; closed == n) { res.add(s); return; } if (open \u0026lt; n) { dfs(n, open + 1, closed, s + \u0026#34;(\u0026#34;); } if (closed \u0026lt; n \u0026amp;\u0026amp; closed \u0026lt; open) { dfs(n, open, closed + 1, s + \u0026#34;)\u0026#34;); } } } "},{"id":114,"href":"/docs/leetcode/others/29/","title":"29th","section":"Leet Code","content":" \rLink\n X / Y = K \u0026ndash;\u0026gt; X = YK \u0026ndash;\u0026gt; Kå‡è®¾K=(1110)2 åˆ™ X = Y * 2^3 + Y * 2^2 + Y * 2^1 å³logKä¸ªæ•°ç›¸åŠ \nclass Solution { public int divide(int dividend, int divisor) { int flag = 1; if (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) { flag = -1; } long a = Math.abs((long)dividend), b = Math.abs((long)divisor); List\u0026lt;Long\u0026gt; exp = new ArrayList\u0026lt;\u0026gt;(); for (long i = b; i \u0026lt;= a; i += i) { exp.add(i); } long res = 0; for (int i = exp.size() - 1; i \u0026gt;= 0; i--) { if (a \u0026gt;= exp.get(i)) { a -= exp.get(i); res += 1L \u0026lt;\u0026lt; i; } } res *= flag; if (res \u0026gt; Integer.MAX_VALUE || res \u0026lt; Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return (int)res; } } "},{"id":115,"href":"/docs/leetcode/others/31/","title":"31st","section":"Leet Code","content":" \rLink\n class Solution { // ä»å‰å¾€åæ‰¾ç¬¬ä¸€æ¬¡é™åºçš„ä½ç½®k  // ä»kå¼€å§‹æ‰¾è¾ƒk-1å¤§çš„æ•°ï¼Œäº¤æ¢  // åè½¬(k, end)  public void nextPermutation(int[] nums) { int n = nums.length; int k = n - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k - 1] \u0026gt;= nums[k]) k--; if (k \u0026lt;= 0) { reverse(nums, 0, n - 1); } else { int t = k; while (t \u0026lt; n \u0026amp;\u0026amp; nums[t] \u0026gt; nums[k - 1]) t++; swap(nums, k - 1, t - 1); reverse(nums, k, n - 1); } } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } // [begin, end]  private void reverse(int[] nums, int begin, int end) { for (int i = 0; i \u0026lt; (end - begin + 1) / 2; i++) { swap(nums, begin + i, end - i); } } } "},{"id":116,"href":"/docs/leetcode/others/36/","title":"36th","section":"Leet Code","content":" \rLink\n class Solution { public boolean isValidSudoku(char[][] board) { boolean[] st = new boolean[10]; // åˆ¤æ–­è¡Œ  for (int i = 0; i \u0026lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } // åˆ¤æ–­åˆ—  for (int i = 0; i \u0026lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j \u0026lt; 9; j++) { if (board[j][i] != \u0026#39;.\u0026#39;) { int t = board[j][i] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } // åˆ¤æ–­å°æ–¹æ ¼  for (int i = 0; i \u0026lt; 9; i += 3) { for (int j = 0; j \u0026lt; 9; j += 3) { Arrays.fill(st, false); for (int x = 0; x \u0026lt; 3; x++) { for (int y = 0; y \u0026lt; 3; y++) { if (board[x + i][y + j] != \u0026#39;.\u0026#39;) { int t = board[x + i][y + j] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } } } return true; } } "},{"id":117,"href":"/docs/leetcode/others/37/","title":"37th","section":"Leet Code","content":" \rLink\n class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init  for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;1\u0026#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] != \u0026#39;.\u0026#39;) return dfs(board, x, y + 1); for (int i = 0; i \u0026lt; 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x / 3][y / 3][i]) { board[x][y] = (char)(i + \u0026#39;1\u0026#39;); row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if (dfs(board, x, y + 1)) { return true; } board[x][y] = \u0026#39;.\u0026#39;; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; } } "},{"id":118,"href":"/docs/leetcode/others/383/","title":"383rd","section":"Leet Code","content":" \rLink\n class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - \u0026#39;a\u0026#39;] \u0026lt;= 0) return false; count[c - \u0026#39;a\u0026#39;]--; } return true; } } "},{"id":119,"href":"/docs/leetcode/others/48/","title":"48th","section":"Leet Code","content":" \rLink\n public void rotate(int[][] matrix) { int n = matrix.length; // æ²¿ç€å¯¹è§’çº¿ç¿»è½¬  for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } // æ²¿ç€ä¸­å¿ƒåˆ—ç¿»è½¬  for (int row = 0; row \u0026lt; n; row++) { for (int i = 0, j = n - 1; i \u0026lt; j; i++, j--) { int tmp = matrix[row][i]; matrix[row][i] = matrix[row][j]; matrix[row][j] = tmp; } } } "},{"id":120,"href":"/docs/leetcode/others/50/","title":"50th","section":"Leet Code","content":" \rLink\n public double myPow(double x, int n) { boolean isMinus = false; if (n \u0026lt; 0) { isMinus = true; } double res = 1; for (long k = (long)Math.abs((long)n); k != 0; k \u0026gt;\u0026gt;= 1) { if ((k \u0026amp; 0x1) == 0x1) { res *= x; } x *= x; } if (isMinus) { return 1 / res; } else { return res; } } "},{"id":121,"href":"/docs/leetcode/others/5963/","title":"5963rd","section":"Leet Code","content":" TODO: Link\n class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i) == \u0026#39;0\u0026#39;) { i--; } for ( ; i \u0026gt;= 0; i--) { sb.append(s.charAt(i)); } return sb.toString(); } } "},{"id":122,"href":"/docs/leetcode/others/5965/","title":"5965th","section":"Leet Code","content":" TODO: Link\n ç¨å¾®ä¼˜åŒ–ä¸‹è¿˜æ˜¯è¶…æ—¶ï¼Œæ”¾å¼ƒ\nclass Solution { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // if (i == begin) continue;  if (arr[begin] == arr[i]) { list.add(i); } } map.put(arr[begin], list); System.out.println(1); } else { System.out.println(2); } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } è¶…æ—¶\nclass Solution { public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (i == begin) continue; if (arr[begin] == arr[i]) { list.add(i); } } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } ``"},{"id":123,"href":"/docs/leetcode/others/5967/","title":"5967th","section":"Leet Code","content":" \rLink\n public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i \u0026lt; chs.length; i++) { if (chs[i] == \u0026#39;a\u0026#39;) { x = i; } else if (y == -1 \u0026amp;\u0026amp; chs[i] == \u0026#39;b\u0026#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x \u0026lt; y; } "},{"id":124,"href":"/docs/leetcode/others/5968/","title":"5968th","section":"Leet Code","content":" \rLink\n class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i \u0026lt; m - 1; i++) { if (!bank[i].contains(\u0026#34;1\u0026#34;)) { continue; } int t = calculate(bank, i); // è®¡ç®—è¿™ä¸€è¡Œç¬¦åˆçš„æ¿€å…‰æŸæ•°é‡  if (t \u0026gt; 0) { // update result  for (int j = 0; j \u0026lt; n; j++) { if (bank[i].charAt(j) == \u0026#39;1\u0026#39;) { res += t; } } } } return res; } private int calculate(String[] bank, int start) { int end = start; for (int i = end + 1; i \u0026lt; m; i++) { if (bank[i].contains(\u0026#34;1\u0026#34;)) { end = i; break; } } int result = 0; if (end != start) { for (int i = 0; i \u0026lt; n; i++) { if (bank[end].charAt(i) == \u0026#39;1\u0026#39;) { result++; } } } return result; } } "},{"id":125,"href":"/docs/leetcode/others/5969/","title":"5969th","section":"Leet Code","content":" [Link]\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t \u0026lt; a) { return false; } else { t += a; } } return true; } } "},{"id":126,"href":"/docs/leetcode/others/7/","title":"7th","section":"Leet Code","content":" \rLink\n public int reverse(int x) { // java è¿™é‡Œ-11 % 10 = -1 æ•°å­¦ä¸Šåº”è¯¥æ˜¯ 9  int flag = 1; if (x \u0026lt; 0) { flag = -1; x = -x; } int res = 0; while (x != 0) { if (res \u0026gt; ((Integer.MAX_VALUE - (x % 10)) / 10)) { return 0; } res = res * 10 + (x % 10); x /= 10; } return res * flag; } "},{"id":127,"href":"/docs/leetcode/others/748/","title":"748th","section":"Leet Code","content":" \rLink\n public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = \u0026#34;\u0026#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) \u0026amp;\u0026amp; word.length() \u0026lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i \u0026lt; a1.length; i++) { if (a1[i] \u0026gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.toCharArray()) { if (Character.isLetter(c)) { c = Character.toUpperCase(c); tmp[c - \u0026#39;A\u0026#39;]++; } } return tmp; } "},{"id":128,"href":"/docs/leetcode/others/9/","title":"9th","section":"Leet Code","content":" \rLink\n public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int y = x; int res = 0; while (x \u0026gt; 0) { res = res * 10 + (x % 10); x /= 10; } return res == y; } public boolean isPalindrome(int x) { String s = String.valueOf(x); return s.equals(new StringBuilder(s).reverse().toString()); } "},{"id":129,"href":"/docs/leetcode/recursion/1492/","title":"1492nd","section":"Leet Code","content":" \rLink\n public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f \u0026gt;= n \u0026amp;\u0026amp; k \u0026gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); } "},{"id":130,"href":"/docs/leetcode/simulation/12/","title":"12th","section":"Leet Code","content":" \rLink\n public String intToRoman(int num) { int[] values = new int[]{ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; String[] chs = new String[]{ \u0026#34;I\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;M\u0026#34; }; StringBuilder sb = new StringBuilder(); for (int i = values.length - 1; i \u0026gt;= 0; i--) { while (num \u0026gt;= values[i]) { num -= values[i]; sb.append(chs[i]); } } return sb.toString(); } "},{"id":131,"href":"/docs/leetcode/simulation/13/","title":"13th","section":"Leet Code","content":" \rLink\n public int romanToInt(String s) { Map\u0026lt;Character, Integer\u0026gt; hash = new HashMap\u0026lt;\u0026gt;(); hash.put(\u0026#39;I\u0026#39;, 1); hash.put(\u0026#39;V\u0026#39;, 5); hash.put(\u0026#39;X\u0026#39;, 10); hash.put(\u0026#39;L\u0026#39;, 50); hash.put(\u0026#39;C\u0026#39;, 100); hash.put(\u0026#39;D\u0026#39;, 500); hash.put(\u0026#39;M\u0026#39;, 1000); int res = 0; int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (i + 1 \u0026lt; n \u0026amp;\u0026amp; hash.get(s.charAt(i)) \u0026lt; hash.get(s.charAt(i + 1))) { res = res + (-hash.get(s.charAt(i))); } else { res = res + hash.get(s.charAt(i)); } } return res; } "},{"id":132,"href":"/docs/leetcode/simulation/38/","title":"38th","section":"Leet Code","content":" \rLink\n public String countAndSay(int n) { String res = \u0026#34;1\u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { StringBuilder t = new StringBuilder(); int m = res.length(); for (int j = 0; j \u0026lt; m; ) { int k = j + 1; while (k \u0026lt; m \u0026amp;\u0026amp; res.charAt(j) == res.charAt(k)) k++; t.append(k - j).append(res.charAt(j)); j = k; } res = t.toString(); } return res; } "},{"id":133,"href":"/docs/leetcode/sorts/215/","title":"215th","section":"Leet Code","content":" \rLink\n ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—\n// Time Complexity: O(nlgn)  // Space Complexity: O(k)  public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int num : nums) { if (q.size() == k) { if (num \u0026gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); } "},{"id":134,"href":"/docs/leetcode/sorts/41/","title":"41st","section":"Leet Code","content":" \rLink\n class Solution { public int firstMissingPositive(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { while (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] != i + 1 \u0026amp;\u0026amp; nums[i] \u0026lt;= nums.length \u0026amp;\u0026amp; nums[i] != nums[nums[i] - 1]) { int tmp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = tmp; } } for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != i + 1) { return i + 1; } } return nums.length + 1; } } "},{"id":135,"href":"/docs/leetcode/stack/20/","title":"20th","section":"Leet Code","content":" \rLink\n æŸ¥é˜…Asciiç è¡¨è¿›è¡Œç®€åŒ–\npublic boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); } else { if (st.size() \u0026gt; 0 \u0026amp;\u0026amp; Math.abs(st.peek() - s.charAt(i)) \u0026lt;= 2) { st.pop(); } else { return false; } } } return st.size() == 0; } public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); continue; } if (st.size() == 0 || (s.charAt(i) == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;(\u0026#39;) || (s.charAt(i) == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;[\u0026#39;) || (s.charAt(i) == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;{\u0026#39;)) { return false; } st.pop(); } return st.size() == 0; } "},{"id":136,"href":"/docs/leetcode/stack/32/","title":"32nd","section":"Leet Code","content":" \rLink\n public int longestValidParentheses(String s) { Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); int result = 0; for (int i = 0, start = -1; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { st.push(i); } else { if (st.isEmpty()) { start = i; } else { st.pop(); if (st.isEmpty()) { result = Math.max(result, i - start); } else { result = Math.max(result, i - st.peek()); } } } } return result; } "},{"id":137,"href":"/docs/leetcode/stack/42/","title":"42nd","section":"Leet Code","content":" \rLink\n \r\rDetail\npublic int trap(int[] height) { Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int ans = 0; for (int i = 0; i \u0026lt; height.length; i++) { while (!st.isEmpty() \u0026amp;\u0026amp; height[st.peek()] \u0026lt; height[i]) { int cur = st.pop(); if (st.isEmpty()) break; int l = st.peek(); int r = i; int h = Math.min(height[l], height[r]) - height[cur]; ans += (r - l - 1) * h; } st.push(i); } return ans; } "},{"id":138,"href":"/docs/leetcode/string/14/","title":"14th","section":"Leet Code","content":" \rLink\n public String longestCommonPrefix(String[] strs) { StringBuilder sb = new StringBuilder(); int n = strs[0].length(); for (int i = 0; i \u0026lt; n; i++) { char c = strs[0].charAt(i); for (int j = 1; j \u0026lt; strs.length; j++) { if (i \u0026gt;= strs[j].length() || c != strs[j].charAt(i)) { return sb.toString(); } } sb.append(c); } return sb.toString(); } "},{"id":139,"href":"/docs/leetcode/string/28/","title":"28th","section":"Leet Code","content":" \rLink\n public int strStr(String s, String p) { int m = p.length(); if (m == 0) return 0; int n = s.length(); s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; int[] next = new int[m + 1]; for (int i = 2, j = 0; i \u0026lt;= m; i++) { while (j != 0 \u0026amp;\u0026amp; p.charAt(i) != p.charAt(j + 1)) j = next[j]; if ( p.charAt(i) == p.charAt(j + 1)) j++; next[i] = j; } // åŒ¹é…  for (int i = 1, j = 0; i \u0026lt;= n; i++) { while (j != 0 \u0026amp;\u0026amp; s.charAt(i) != p.charAt(j + 1)) j = next[j]; if (s.charAt(i) == p.charAt(j + 1)) j++; if (j == m) return i - m; } return -1; } "},{"id":140,"href":"/docs/leetcode/string/5/","title":"5th","section":"Leet Code","content":" \rLink\n public String longestPalindrome(String s) { int n = s.length(); String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { int l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } l = i; r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } } return res; } "},{"id":141,"href":"/docs/leetcode/string/6/","title":"6th","section":"Leet Code","content":" \rLink\n è½¬æˆç´¢å¼•æ’åˆ—ï¼Œæ‰¾å‡ºè§„å¾‹\npublic String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; numRows; i++) { if (i == 0 || i == numRows - 1) { for (int j = i; j \u0026lt; n; j += 2 * numRows - 2) { sb.append(s.charAt(j)); } } else { for (int j = i, k = 2 * numRows - 2 - i; j \u0026lt; n || k \u0026lt; n; j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j \u0026lt; n) { sb.append(s.charAt(j)); } if (k \u0026lt; n) { sb.append(s.charAt(k)); } } } } return sb.toString(); } "},{"id":142,"href":"/docs/leetcode/string/8/","title":"8th","section":"Leet Code","content":" \rLink\n class Solution { public int myAtoi(String s) { int k = 0; int n = s.length(); while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) == \u0026#39; \u0026#39;) { k++; } if (k == n) { return 0; } int minus = 1; if (s.charAt(k) == \u0026#39;-\u0026#39;) { minus = -1; k++; } else if (s.charAt(k) == \u0026#39;+\u0026#39;) { k++; } int res = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s.charAt(k) \u0026lt;= \u0026#39;9\u0026#39;) { int x = s.charAt(k) - \u0026#39;0\u0026#39;; if (minus \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (Integer.MAX_VALUE - x) / 10) { return Integer.MAX_VALUE; } if (minus \u0026lt; 0 \u0026amp;\u0026amp; -res \u0026lt; (Integer.MIN_VALUE + x) / 10) { return Integer.MIN_VALUE; } if (-res * 10 - x == Integer.MIN_VALUE) { return Integer.MIN_VALUE; } res = res * 10 + x; k++; } res *= minus; return res; } } "},{"id":143,"href":"/docs/leetcode/tips/","title":"Tips","section":"Leet Code","content":"æ‘©å°”æŠ•ç¥¨ç®—æ³•\r#\r\r/* å¯¹äºnä¸ªå…ƒç´ ï¼Œè¶…è¿‡n/2çš„æ¬¡æ•°æœ€å¤šåªæœ‰ä¸€ä¸ªå…ƒç´ ã€‚åŒç†è¶…è¿‡n/3çš„æ¬¡æ•°æœ€å¤šåªæœ‰äºŒä¸ªå…ƒç´ ã€‚é€‰ä¸€ä¸ªcandidateï¼Œæ ‡è®°ä¸º1ï¼Œæ¯æ¬¡ä¸ä¸€æ ·æ ‡è®°å‡1ã€‚æ ‡è®°ä¸º0æ—¶ï¼Œå°†å½“å‰å…ƒç´ è®¾ä¸ºcandidateä¸”æ ‡è®°ä¸º1ã€‚(ç›¸å½“äºæ¶ˆé™¤ä¸ä¸€æ ·çš„å…ƒç´ )ï¼Œæœ€åéœ€è¦ç¡®å®šæ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚ */ "},{"id":144,"href":"/docs/leetcode/tree/102/","title":"102nd","section":"Leet Code","content":" \rLink\n è€ƒè™‘å½“å‰å±‚ç»“æŸæ¡ä»¶ï¼Œå³å½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); int count = q.size(); while (count \u0026gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; } "},{"id":145,"href":"/docs/leetcode/tree/559/","title":"559th","section":"Leet Code","content":" \rLink ä¸€é“ç®€å•çš„æœç´¢\n public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i \u0026lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; } "},{"id":146,"href":"/docs/leetcode/tree/700/","title":"700th","section":"Leet Code","content":" \rLink\n é€’å½’æœç´¢\nclass Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val \u0026gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } } "},{"id":147,"href":"/docs/leetcode/twopointers/11/","title":"11th","section":"Leet Code","content":" \rLink\n public int maxArea(int[] height) { int res = 0; for (int i = 0, j = height.length - 1; i \u0026lt; j; ) { res = Math.max(res, Math.min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) { i++; } else { j--; } } return res; } "},{"id":148,"href":"/docs/leetcode/twopointers/15/","title":"15th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) { // æ‰¾é è¿‘å·¦è¾¹ç¬¬ä¸€ä¸ª\u0026gt;=çš„kç´¢å¼•  k--; } if (nums[i] + nums[j] + nums[k] == 0) { res.add(List.of(nums[i], nums[j], nums[k])); } } } return res; } "},{"id":149,"href":"/docs/leetcode/twopointers/16/","title":"16th","section":"Leet Code","content":" \rLink\n public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { int j = i + 1, k = nums.length - 1; while (j \u0026lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum \u0026gt; target) { k--; } else { j++; } if (Math.abs(target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } return res; } public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) { k--; } int sum = nums[i] + nums[j] + nums[k]; // é è¿‘å·¦è¾¹ç¬¬ä¸€ä¸ª\u0026gt;=targetçš„k  if (Math.abs(sum - target) \u0026lt; Math.abs(target - res)) { res = sum; } if (k - 1 \u0026gt; j) { sum = nums[i] + nums[j] + nums[k - 1]; // \u0026lt; target  if ((target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } } return res; } `` "},{"id":150,"href":"/docs/leetcode/twopointers/18/","title":"18th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } for (int k = j + 1, u = n - 1; k \u0026lt; u; k++) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { continue; } while (k \u0026lt; u - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k] + nums[u - 1] \u0026gt;= target) { u--; } if (nums[i] + nums[j] + nums[k] + nums[u] == target) { res.add(List.of(nums[i], nums[j], nums[k], nums[u])); } } } } return res; } "},{"id":151,"href":"/docs/leetcode/twopointers/26/","title":"26th","section":"Leet Code","content":" \rLink\n public int removeDuplicates(int[] nums) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i == 0 || nums[i] != nums[i - 1]) { nums[j++] = nums[i]; } } return j; } "},{"id":152,"href":"/docs/leetcode/twopointers/27/","title":"27th","section":"Leet Code","content":" \rLink\n public int removeElement(int[] nums, int val) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[j++] = nums[i]; } } return j; } "},{"id":153,"href":"/docs/leetcode/twopointers/3/","title":"3rd","section":"Leet Code","content":" \rLink\n int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;char, int\u0026gt; map{}; int res = 0; int n = s.length(); int j = 0; for (int i = 0; i \u0026lt; n; i++) { map[s[i]]++; if (map[s[i]] \u0026gt; 1) { while (map[s[i]] \u0026gt; 1) { map[s[j++]]--; } } res = max(res, i - j + 1); } return res; } public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int res = 0; int n = s.length(); for (int i = 0, j = 0; i \u0026lt; n; i++) { map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1); if (map.get(s.charAt(i)) == 1) { res = Math.max(res, i - j + 1); continue; } while (map.get(s.charAt(i)) \u0026gt; 1) { map.put(s.charAt(j), map.get(s.charAt(j)) - 1); j++; } } return res; } "},{"id":154,"href":"/docs/leetcode/twopointers/30/","title":"30th","section":"Leet Code","content":" \rLink\n æ»‘åŠ¨çª—å£ + Hash\npublic List\u0026lt;Integer\u0026gt; findSubstring(String s, String[] words) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = s.length(), m = words.length; if (m == 0) { return res; } int w = words[0].length(); Map\u0026lt;String, Integer\u0026gt; tot = new HashMap\u0026lt;\u0026gt;(); for (String word : words) tot.put(word, tot.getOrDefault(word, 0) + 1); for (int i = 0; i \u0026lt; w; i++) { Map\u0026lt;String, Integer\u0026gt; wd = new HashMap\u0026lt;\u0026gt;(); int cnt = 0; for (int j = i; j + w \u0026lt;= n; j += w) { if (j \u0026gt;= i + m * w) { String word = s.substring(j - m * w, j - (m - 1) * w); wd.put(word, wd.get(word) - 1); if (tot.containsKey(word) \u0026amp;\u0026amp; wd.get(word) \u0026lt; tot.get(word)) cnt--; } String word = s.substring(j, j + w); wd.put(word, wd.getOrDefault(word, 0) + 1); if (tot.containsKey(word) \u0026amp;\u0026amp; wd.get(word) \u0026lt;= tot.get(word)) cnt++; if (cnt == m) res.add(j - (m - 1) * w); } } return res; } "},{"id":155,"href":"/docs/leetcode/twopointers/4/","title":"4th","section":"Leet Code","content":" \rLink\n public double findMedianSortedArrays(int[] nums1, int[] nums2) { int k = nums1.length + nums2.length; if (k % 2 == 0) { int left = findKth(nums1, 0, nums2, 0, k / 2); int right = findKth(nums1, 0, nums2, 0, k / 2 + 1); return (left + right) / 2.0; } else { return findKth(nums1, 0, nums2, 0, k / 2 + 1); } } // äºŒåˆ†åšæ³•  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { if (nums1.length - i \u0026gt; nums2.length - j) { return findKth(nums2, j, nums1, i, k); } if (nums1.length == i) { return nums2[j + k - 1]; } if (k == 1) { return Math.min(nums1[i], nums2[j]); } int k1 = Math.min(nums1.length - i, k / 2); int k2 = k - k1; if (nums1[i + k1 - 1] \u0026lt; nums2[j + k2 - 1]) { return findKth(nums1, i + k1, nums2, j, k - k1); } else { return findKth(nums1, i, nums2, j + k2, k - k2); } } //ä¼˜å…ˆé˜Ÿåˆ—åšæ³•  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); while (i \u0026lt; nums1.length) { pq.offer(nums1[i++]); } while (j \u0026lt; nums2.length) { pq.offer(nums2[j++]); } int res = 0; while (k-- \u0026gt; 0) { res = pq.poll(); } return res; } "},{"id":156,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/","title":"å‰‘æŒ‡ Offer","section":"Leet Code","content":" \rå‰‘æŒ‡ Offer 03. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—(E) \r14. ä¸ä¿®æ”¹æ•°ç»„æ‰¾å‡ºé‡å¤çš„æ•°å­—(E) \rå‰‘æŒ‡ Offer 04. äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾(M) \rå‰‘æŒ‡ Offer 05. æ›¿æ¢ç©ºæ ¼(E) \rå‰‘æŒ‡ Offer 50. ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦(E) \rå‰‘æŒ‡ Offer 32 - I. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘(M) \rå‰‘æŒ‡ Offer 32 - II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II(E) \rå‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III(M) \rå‰‘æŒ‡ Offer 47. ç¤¼ç‰©çš„æœ€å¤§ä»·å€¼(M) \rå‰‘æŒ‡ Offer 26. æ ‘çš„å­ç»“æ„(M) \rå‰‘æŒ‡ Offer 18. åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹(E) \rå‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹(E) \rå‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²(M) \rå‰‘æŒ‡ Offer 46. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²(M) \rå‰‘æŒ‡ Offer 25. åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨(M) \rå‰‘æŒ‡ Offer 57. å’Œä¸ºsçš„ä¸¤ä¸ªæ•°å­—(E) \rå‰‘æŒ‡ Offer 21. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢(E) \rå‰‘æŒ‡ Offer 58 - I. ç¿»è½¬å•è¯é¡ºåº(E) \rå‰‘æŒ‡ Offer 13. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´(M) \rå‰‘æŒ‡ Offer 12. çŸ©é˜µä¸­çš„è·¯å¾„(M) \rå‰‘æŒ‡ Offer 64. æ±‚1+2+â€¦+n(M) \rå‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹(M) \rå‰‘æŒ‡ Offer 55 - I. äºŒå‰æ ‘çš„æ·±åº¦(E) \rå‰‘æŒ‡ Offer 55 - II. å¹³è¡¡äºŒå‰æ ‘(E) \rå‰‘æŒ‡ Offer 68 - I. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ(E) \rå‰‘æŒ‡ Offer 68 - II. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ(E) \rå‰‘æŒ‡ Offer 15. äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°(E)  "},{"id":157,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/","title":"6th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n vector\u0026lt;int\u0026gt; reversePrint(ListNode* head) { vector\u0026lt;int\u0026gt; res; while (head) { res.push_back(head-\u0026gt;val); head = head-\u0026gt;next; } return vector\u0026lt;int\u0026gt;(res.rbegin(), res.rend()); } public int[] reversePrint(ListNode head) { Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head.val); head = head.next; } int[] res = new int[s.size()]; int idx = 0; while (!s.isEmpty()) { res[idx++] = s.pop(); } return res; } "},{"id":158,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/","title":"3rd","section":"å‰‘æŒ‡ Offer","content":" \rLink\n å°†å…ƒç´ æ”¾ç½®åˆ°å¯¹åº”çš„ä½ç½®ã€‚2ä»£è¡¨ä¸‹æ ‡ä¸º2çš„ä½ç½®\nint findRepeatNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { while (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] != nums[i]) { swap(nums[i], nums[nums[i]]); } if (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] == nums[i]) { return nums[i]; } } return -1; } "},{"id":159,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/","title":"4th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n \rä¸Šå›¾æ˜¯ä»å³ä¸Šè§’ï¼ŒåŒç†å·¦ä¸‹è§’\nä»å³ä¸Šè§’çœ‹æˆä¸€ä¸ªäºŒåˆ†æœç´¢æ ‘\nbool searchArray(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; array, int target) { if (array.size() == 0) { return false; } int m = array.size(); int n = array[0].size(); int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (array[i][j] == target) { return true; } else if (array[i][j] \u0026lt; target) { i++; } else { j--; } } return false; } public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] \u0026lt; target) { col++; } else { row--; } } return false; } "},{"id":160,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/","title":"5th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n Cè¯­è¨€éœ€è¦æ³¨æ„å†…å­˜åˆ†é…ï¼Œå…ˆæ±‚å‡ºç©ºæ ¼æ•°é‡ï¼Œåœ¨è®¡ç®—å‡ºéœ€è¦çš„å†…å­˜å¤§å°ã€‚\npublic String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39; \u0026#39;) { sb.append(\u0026#34;%20\u0026#34;); } else { sb.append(s.charAt(i)); } } return sb.toString(); } "},{"id":161,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/","title":"12th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || board[i][j] != word.charAt(idx)) { return false; } if (idx == word.length() - 1) { return true; } board[i][j] = \u0026#39;0\u0026#39;; boolean res = search(board, word, idx + 1, i + 1, j) || search(board, word, idx + 1, i - 1, j) || search(board, word, idx + 1, i, j + 1) || search(board, word, idx + 1, i, j - 1); board[i][j] = word.charAt(idx); return res; } èœå†™æ³•ï¼Œè¶…æ—¶\nclass Solution { private int m; private int n; private char[][] board; private String word; private boolean[][] visited; public boolean exist(char[][] board, String word) { this.m = board.length; this.n = board[0].length; this.visited = new boolean[m][n]; this.board = board; this.word = word; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dfs(sb, i, j)) return true; } } return false; } private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; private boolean dfs(StringBuilder cur, int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n) { return false; } if (visited[x][y]) { return false; } cur.append(board[x][y]); visited[x][y] = true; int cmp = cur.length() - word.length(); if (cmp == 0 \u0026amp;\u0026amp; word.equals(cur.toString())) { return true; } else if (cmp \u0026lt; 0) { for (int i = 0; i \u0026lt; 4; i++) { int tmpX = x + dirs[i][0]; int tmpY = y + dirs[i][1]; if (dfs(cur, tmpX, tmpY)) return true; } } visited[x][y] = false; cur.deleteCharAt(cur.length() - 1); return false; } } "},{"id":162,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/","title":"13th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n ç®€å•DFS\nclass Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x \u0026gt;= m || x \u0026lt; 0 || y \u0026gt;= n || y \u0026lt; 0) return 0; if (visited[x][y] || !isValid(x, y)) { return 0; } visited[x][y] = true; return 1 + dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1); } private boolean isValid(int x, int y) { int val = 0; while (x \u0026gt; 0) { val += (x % 10); x /= 10; } while (y \u0026gt; 0) { val += (y % 10); y /= 10; } return val \u0026lt;= k; } } "},{"id":163,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/","title":"15th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;\u0026gt;= 1; } return res; } "},{"id":164,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/","title":"18th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } } "},{"id":165,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/","title":"21st","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i \u0026lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; } "},{"id":166,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/","title":"22nd","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public ListNode getKthFromEnd(ListNode head, int k) { Stack\u0026lt;ListNode\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head); head = head.next; } if (k \u0026gt; s.size()) return null; ListNode res = null; while (k \u0026gt; 0) { k--; res = s.pop(); } return res; } "},{"id":167,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/","title":"25th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null \u0026amp;\u0026amp; cur2 != null) { if (cur1.val \u0026lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.next; } "},{"id":168,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/","title":"26th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) \u0026amp;\u0026amp; help(A.right, B.right); } } "},{"id":169,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/","title":"32 1","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } } "},{"id":170,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/","title":"32 2","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null]  while (q.peek() != null) { TreeNode node; List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); } res.add(tmp); q.offer(null); } return res; } } "},{"id":171,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/","title":"32 3","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList\u0026lt;Integer\u0026gt; tmp = new LinkedList\u0026lt;\u0026gt;(); int n = res.size(); for (int i = q.size(); i \u0026gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } res.add(tmp); } return res; } } "},{"id":172,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/","title":"46th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n DFS\npublic int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start \u0026gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - \u0026#39;0\u0026#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start \u0026lt; str.length() - 1) { // 06  if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - \u0026#39;0\u0026#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25; } åŠ¨æ€è§„åˆ’\npublic int translateNum(int num) { String str = String.valueOf(num); int n = str.length(); // ä»¥iä¸ºç»“å°¾ ä¸åŒç¿»è¯‘æ•°  int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1]; int val = (str.charAt(i - 2) - \u0026#39;0\u0026#39;) * 10 + (str.charAt(i - 1) - \u0026#39;0\u0026#39;); if (10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25) { dp[i] = (dp[i - 2] + dp[i - 1]); } } return dp[n]; } "},{"id":173,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/","title":"47th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } } "},{"id":174,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/","title":"48th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n åŒæŒ‡é’ˆ\npublic int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (j \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; } "},{"id":175,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/","title":"50th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n class Solution { public char firstUniqChar(String s) { Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - \u0026#39;a\u0026#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return \u0026#39; \u0026#39;; } } "},{"id":176,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/","title":"54th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n DFS\nprivate int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack\npublic int kthLargest(TreeNode root, int k) { Queue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (q.size() \u0026lt; k) { q.offer(node.val); } else if (q.peek() \u0026lt; node.val) { q.poll(); q.offer(node.val); } if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } return q.peek(); } "},{"id":177,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/","title":"55 1","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } "},{"id":178,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/","title":"55 2","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) \u0026lt; 2 \u0026amp;\u0026amp; (isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; } "},{"id":179,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/","title":"57th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i \u0026lt; j) { if (nums[i] + nums[j] \u0026lt; target) { i++; } else if (nums[i] + nums[j] \u0026gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; } "},{"id":180,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/","title":"58th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i \u0026gt;= 0) { while(i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] != \u0026#39; \u0026#39;) i--; sb.append(s.substring(i + 1, j + 1) + \u0026#34; \u0026#34;); while (i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] == \u0026#39; \u0026#39;) i--; j = i; } return sb.toString().trim(); } "},{"id":181,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/","title":"64th","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public int sumNums(int n) { boolean tmp = n \u0026gt; 1 \u0026amp;\u0026amp; (n += sumNums(n - 1)) \u0026gt; 0; return n; } "},{"id":182,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/","title":"68 1","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } } "},{"id":183,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/","title":"68 2","section":"å‰‘æŒ‡ Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left == null ? right : left; } ä»»æ„kä¸ªæ•°çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ\nprivate int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.val == p.val || node.val == q.val) { k--; } dfs(node.left, p, q); dfs(node.right, p, q); if (oldK == 2 \u0026amp;\u0026amp; k == 0 \u0026amp;\u0026amp; res == null) { res = node; } } "},{"id":184,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/","title":"A14","section":"å‰‘æŒ‡ Offer","content":" \rLink\n é€šè¿‡äºŒåˆ†æŸ¥æ‰¾ï¼Œåˆ¤æ–­å·¦å³åŒºé—´çš„ä¸ªæ•°\nint duplicateInArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 1, r = nums.size() - 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int cnt = 0; for (auto x : nums) { if (x \u0026gt;= l \u0026amp;\u0026amp; x \u0026lt;= mid) { cnt++; } } if (cnt \u0026gt; mid - l + 1) { r = mid; } else { l = mid + 1; } } return l; } "},{"id":185,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"é¢è¯•é¢˜","section":"Leet Code","content":" \ré¢è¯•é¢˜ 08.05. é€’å½’ä¹˜æ³•(M)  "},{"id":186,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/","title":"805th","section":"é¢è¯•é¢˜","content":" \rLink\n public int multiply(int A, int B) { if (B == 0) return 0; else if (B == 1) return A; else return A + multiply(A, B - 1); } "},{"id":187,"href":"/posts/test/test/","title":"Test","section":"Blog","content":"Test\n"},{"id":188,"href":"/posts/2022/","title":"å…³äºæˆ‘çš„2022çš„ä¸€äº›è®°å½•","section":"Blog","content":"æ”¶è—çš„æ’­å®¢\r#\r\r   æ’­å®¢åç§° æ·»åŠ æ—¥æœŸ type å¤‡æ³¨     \rHappy Path Programming 2022.02.19      æ”¶è—çš„åšå®¢\r#\r\r   åšå®¢åç§° æ·»åŠ æ—¥æœŸ type å¤‡æ³¨     \rcodedumpçš„ç½‘ç»œæ—¥å¿— 2022.02.17 ç³»ç»ŸçŸ¥è¯† å®è—   \rç¨‹åºå‘˜çš„å–µ 2022.02.18 æˆé•¿     æ”¶è—çš„æ–‡ç« \r#\r\r   æ–‡ç« åç§° æ·»åŠ æ—¥æœŸ type å¤‡æ³¨     - æˆ‘åœ¨èŒä¸šç”Ÿæ¶¯ä¸­å­¦åˆ°çš„æ‰€æœ‰è‰¯å¥½å®è·µ 2022.02.06 æŠ€æœ¯æ–‡ç«  å®è—   - èŠèŠå¾®è½¯é¢è¯• 2022.02.18 é¢è¯• å®è—   - Raft åˆ†å¸ƒå¼å…±è¯†ç®—æ³•åŠ¨ç”»æ¼”ç¤º 2022.03.02      "}]