[{"id":0,"href":"/docs/acwing/","title":"Acwing","section":"Docs","content":" \r785. 快速排序 \r786. 第k个数 \r787. 归并排序 \r788. 求逆序对的个数 \r789. 数的范围 \r790. 数的三次方根 \r791. 高精度加法 \r792. 高精度减法 \r793. 高精度乘法 \r794. 高精度除法 \r795. 前缀和 \r796. 子矩阵的和 \r797. 差分 \r798. 差分矩阵 \r799. 最长连续不重复子序列 \r800. 数组元素的目标和 \r801. 二进制中1的个数 \r802. 区间和 \r803. 区间合并 \r826. 单链表 \r827. 双链表 \r828. 模拟栈 \r829. 模拟队列 \r830. 单调栈 \r154. 滑动窗口 \r831. KMP字符串 \r835. Trie字符串统计 \r143. 最大异或对 \r836. 合并集合 \r837. 连通块中点的数量 \r240. 食物链 \r838. 堆排序 \r839. 模拟堆 \r840. 模拟散列表 \r841. 字符串哈希 \r842. 排列数字 \r843. N 皇后 \r844. 走迷宫 \r845. 八数码 \r846. 树的重心 \r847. 图中点的层次 \r848. 有向图的拓扑序列 \r849. Dijkstra求最短路 I \r850. Dijkstra求最短路 II \r851. spfa求最短路 \r852. spfa判断负环 \r853. 有边数限制的最短路 \r854. Floyd求最短路 \r858. Prim算法求最小生成树 \r859. Kruskal算法求最小生成树 \r860. 染色法判断二分圈 \r861. 二分圈的最大匹配 \r866. 试除法判定质数 \r867. 分解质因数 \r868. 筛质数 \r869. 试除法求约数 \r870. 约数个数 \r871. 约数之和 \r872. 最大公约数  \r"},{"id":1,"href":"/docs/acwing/basic/143/","title":"143rd","section":"Acwing","content":" \rLink  #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010, M = 31 * N; int n; int a[N]; int son[M][2], idx; void insert(int x) { int p = 0; for (int i = 30; i \u0026gt;= 0; i--) { int u = x \u0026gt;\u0026gt; i \u0026amp; 1; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } } int query(int x) { int p = 0, res = 0; for (int i = 30; i \u0026gt;= 0; i--) { int u = x \u0026gt;\u0026gt; i \u0026amp; 1; if (son[p][!u]) { p = son[p][!u]; res = res * 2 + !u; } else { p = son[p][u]; res = res * 2 + u; } } return res; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int res = 0; for (int i = 0; i \u0026lt; n; i++) { insert(a[i]); int t = query(a[i]); res = max(res, a[i] ^ t); } cout \u0026lt;\u0026lt; res; return 0; } "},{"id":2,"href":"/docs/acwing/basic/154/","title":"154th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n, k; int a[N], q[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i++) { // 判断并更新窗口  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; q[++tt] = i; if (i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i++) { // 判断并更新窗口  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt--; q[++tt] = i; if (i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } "},{"id":3,"href":"/docs/acwing/basic/240/","title":"240th","section":"Acwing","content":" \rLink\n \r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 50010; int n, m; int p[N], d[N]; int find(int x) { if (p[x] != x) { int t = find(p[x]); d[x] += d[p[x]]; p[x] = t; } return p[x]; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; int res = 0; while (m -- ) { int t, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t, \u0026amp;x, \u0026amp;y); if (x \u0026gt; n || y \u0026gt; n) res ++ ; else { int px = find(x), py = find(y); if (t == 1) { if (px == py \u0026amp;\u0026amp; (d[x] - d[y]) % 3) res ++ ; else if (px != py) { p[px] = py; d[px] = d[y] - d[x]; } } else { if (px == py \u0026amp;\u0026amp; (d[x] - d[y] - 1) % 3) res ++ ; else if (px != py) { p[px] = py; d[px] = d[y] + 1 - d[x]; } } } } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } "},{"id":4,"href":"/docs/acwing/basic/785/","title":"785th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i \u0026lt; n; i ++ ) printf(\u0026#34;%d \u0026#34;, q[i]); return 0; } "},{"id":5,"href":"/docs/acwing/basic/786/","title":"786th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int q[100001]; int quick_sort(int l, int r, int k) { if (l == r) { return q[l]; } int x = q[l], i = l - 1, j = r + 1; while (i \u0026lt; j) { while (q[++i] \u0026lt; x); while (q[--j] \u0026gt; x); if (i \u0026lt; j) { swap(q[i], q[j]); } } int sl = j - l + 1; if (k \u0026lt;= sl) return quick_sort(l, j, k); return quick_sort(j + 1, r, k - sl); } int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; q[i]; } cout \u0026lt;\u0026lt; quick_sort(0, n - 1, k); return 0; } "},{"id":6,"href":"/docs/acwing/basic/787/","title":"787th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int q[N], tmp[N]; void mergeSort(int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; mergeSort(l, mid), mergeSort(mid + 1, r); int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (q[i] \u0026lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; } while (i \u0026lt;= mid) tmp[k++] = q[i++]; while (j \u0026lt;= r) tmp[k++] = q[j++]; for (int i = l, j = 0; i \u0026lt;= r; i++, j++) q[i] = tmp[j]; } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; q[i]; mergeSort(0, n - 1); for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; q[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } "},{"id":7,"href":"/docs/acwing/basic/788/","title":"788th","section":"Acwing","content":" \rLink\n class Solution { private int[] tmp; public int reversePairs(int[] nums) { tmp = new int[nums.length]; return mergeSort(nums, 0, nums.length - 1); } private int mergeSort(int[] nums, int l, int r) { if (l \u0026gt;= r) { return 0; } int mid = (l + r) \u0026gt;\u0026gt; 1; int res = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r); // 归并  int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (nums[i] \u0026lt;= nums[j]) { tmp[k++] = nums[i++]; } else { tmp[k++] = nums[j++]; res += (mid - i + 1); } } while (i \u0026lt;= mid) { tmp[k++] = nums[i++]; } while (j \u0026lt;= r) { tmp[k++] = nums[j++]; } for (i = l, j = 0; i \u0026lt;= r; i++, j++) { nums[i] = tmp[j]; } return res; } } "},{"id":8,"href":"/docs/acwing/basic/790/","title":"790th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int main() { double x; cin \u0026gt;\u0026gt; x; double l = -1e4, r = 1e4; while (r - l \u0026gt; 1e-8) { double m = (l + r) / 2; if (m * m * m \u0026gt;= x) { r = m; } else { l = m; } } printf(\u0026#34;%.6lf\u0026#34;, r); return 0; } "},{"id":9,"href":"/docs/acwing/basic/791/","title":"791st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e6 + 10; vecotr\u0026lt;int\u0026gt; add(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i++) { if (i \u0026lt; A.size()) { t += A[i]; } if (i \u0026lt; B.size()) { t += B[i]; } C.push_back(t % 10); t /= 10; } if (t) { C.push_back(1); } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } auto C = add(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":10,"href":"/docs/acwing/basic/792/","title":"792nd","section":"Acwing","content":"两个正整数相减 A - B 考虑A \u0026lt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = -(|A| + |B|) 考虑A \u0026gt; 0, B \u0026lt; 0 \u0026ndash;\u0026gt; A - B = |A| + |B|\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; // 判断A\u0026gt;=B bool cmp(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() != B.size()) { return A.size() \u0026gt; B.size(); } for (int i = A.size() - 1; i \u0026gt;= 0; i--) { if (A[i] != B[i]) { return A[i] \u0026gt; B[i]; } } // 去掉前导0  while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return true; } vecotr\u0026lt;int\u0026gt; sub(vecotr\u0026lt;int\u0026gt; \u0026amp;A, vecotr\u0026lt;int\u0026gt; \u0026amp;B) { vecotr\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i++) { t = A[i] - t; if (i \u0026lt; B.size()) { t -= B[i]; } c.push_back((t + 10) % 10); if (t \u0026lt; 0) { t = 1; } else { t = 0; } } return C; } int main() { string a, b; vecotr\u0026lt;int\u0026gt; A, B, C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } for (int i = b.size() - 1; i \u0026gt;= 0; i--) { B.push_back(a[i] - \u0026#39;0\u0026#39;); } if (cmp(A, B)) { C = sub(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } else { C = sub(B, A); printf(\u0026#34;-\u0026#34;); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } } return 0; } "},{"id":11,"href":"/docs/acwing/basic/793/","title":"793rd","section":"Acwing","content":"两个正整数相乘 大*小\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; mul(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b) { vecotr\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t != 0; i++) { if (i \u0026lt; A.size()) { t += A[i] * b; } C.push_back(t % 10); t /= 10; } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A, vector\u0026lt;int\u0026gt; C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } C = mul(A, b); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } return 0; } "},{"id":12,"href":"/docs/acwing/basic/794/","title":"794th","section":"Acwing","content":"两个正整数相除 大/小\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; vecotr\u0026lt;int\u0026gt; div(vecotr\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vecotr\u0026lt;int\u0026gt; C; int t = 0; r = 0; for (int i = A.size(); i \u0026gt;= 0; i--) { r = r * 10 + A[i]; C.push_back(r / b); r = r % b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) { C.pop_back(); } return C; } int main() { string a; int b; vecotr\u0026lt;int\u0026gt; A, vector\u0026lt;int\u0026gt; C; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // a = \u0026#34;123456\u0026#34;  for (int i = a.size() - 1; i \u0026gt;= 0; i--) { A.push_back(a[i] - \u0026#39;0\u0026#39;); // A = [6, 5, 4, 3, 2, 1]  } int r; C = div(A, b, r); for (int i = C.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } "},{"id":13,"href":"/docs/acwing/basic/795/","title":"795th","section":"Acwing","content":"\rS[i] = a[1] + a[2] + ... a[i]\ra[l] + ... + a[r] = S[r] - S[l - 1]\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], s[N]; int main() { a[0] = 0; s[0] = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { s[i] = s[i - 1] + a[i]; } while (m--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;r, \u0026amp;l); printf(\u0026#34;%d\\n\u0026#34;, s[r] - s[l - 1]); } return 0; } "},{"id":14,"href":"/docs/acwing/basic/796/","title":"796th","section":"Acwing","content":"\rS[i, j] = 第i行j列格子左上部分所有元素的和\r以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\rS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\r#include \u0026lt;iostream\u0026gt; const int N = 1010; int n, m, q; int a[N][N], s[N][N]; int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } } while (q--) { int x1, y1, x2, y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); printf(\u0026#34;%d\\n\u0026#34;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 -1] + s[x1 - 1][y1 -1]); } return 0; } "},{"id":15,"href":"/docs/acwing/basic/797/","title":"797th","section":"Acwing","content":"\r给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) { insert(i, i, a[i]); } while (m--) { int l, r, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;c); insert(l, r, c); } for (int i = 1; i \u0026lt;= n; i++) { b[i] += b[i - 1]; } for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;%d \u0026#34;, b[i]); } return 0; } "},{"id":16,"href":"/docs/acwing/basic/798/","title":"798th","section":"Acwing","content":"\r给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\rS[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\r#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 1010; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { insert(i, j, i, j, a[i][j]); } } while (q--) { int x1, y1, x2, y2, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;c); insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { printf(\u0026#34;%d \u0026#34;, b[i][j]); } puts(\u0026#34;\u0026#34;); } return 0; } "},{"id":17,"href":"/docs/acwing/basic/799/","title":"799th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; int a[100010]; int s[100010]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int maxLen = 0; for (int i = 0, j = 0; i \u0026lt; n; i++) { s[a[i]]++; while (s[a[i]] \u0026gt; 1) { s[a[j]]--; j++; } if ((i - j + 1) \u0026gt; maxLen) { maxLen = i - j + 1; } } cout \u0026lt;\u0026lt; maxLen \u0026lt;\u0026lt; endl; return 0; } "},{"id":18,"href":"/docs/acwing/basic/801/","title":"801st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; int lowbit(int x) { return x \u0026amp; -x; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n--) { int x; cin \u0026gt;\u0026gt; x; int cnt = 0; while (x != 0) { x -= lowbit(x); cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":19,"href":"/docs/acwing/basic/802/","title":"802nd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n, m; int a[N], s[N]; vector\u0026lt;int\u0026gt; alls; vector\u0026lt;PII\u0026gt; add, query; // 将x映射到索引为(1--alls.size())的数 int find(int x) { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x); } for (int i = 0; i \u0026lt; m; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // 去重  sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 处理插入  for (auto item : add) { int x = find(item.first); a[x] += item.second; } // 预处理前缀和  for (int i = 1; i \u0026lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; // 处理查询  for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } } "},{"id":20,"href":"/docs/acwing/basic/803/","title":"803rd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 100010; void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) { if (ed \u0026lt; seg.first) { if (ed != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else { ed = max(ed, seg.second); } } if (st != -2e9) res.push_back({st, ed}); segs = res; } int main() { int n; vector\u0026lt;PII\u0026gt; segs; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; segs.push_back({l, r}); } merge(segs); cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl; return 0; } "},{"id":21,"href":"/docs/acwing/basic/826/","title":"826th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } void add_to_head(int x) { e[idx] = x; ne[idx] = head; head = idx; idx++; } // 将x插入到下标是k的点面 void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++; } // 将下标是k的点后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while (m--) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if (op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (!k) head = ne[head]; remove(k - 1); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":22,"href":"/docs/acwing/basic/827/","title":"827th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; int idx, e[N], l[N], r[N]; void init() { // 0表示head 1表示tail  r[0] = 1, l[1] = 0; idx = 2; } // 在下标为k的右边插入 void add(int k, int x) { e[idx] = x; l[idx] = k; r[idx] = r[k]; l[r[k]] = idx; r[k] = idx; idx++; } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { int n; cin \u0026gt;\u0026gt; n; init(); while (n--) { string op; cin \u0026gt;\u0026gt; op; int k, a; if (op == \u0026#34;R\u0026#34;) { cin \u0026gt;\u0026gt; a; add(l[1], a); } else if (op == \u0026#34;L\u0026#34;) { cin \u0026gt;\u0026gt; a; add(0, a); } else if (op == \u0026#34;D\u0026#34;) { cin \u0026gt;\u0026gt; k; remove(k + 1); } else if (op == \u0026#34;IL\u0026#34;) { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a; add(l[k + 1], a); } else if (op == \u0026#34;IR\u0026#34;) { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a; add(k + 1, a); } } for (int i = r[0]; i != 1; i = r[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } "},{"id":23,"href":"/docs/acwing/basic/830/","title":"830th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; const int N = 100010; int n; int stk[N], tt; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; while (tt \u0026amp;\u0026amp; skt[tt] \u0026gt;= x) tt--; if (tt) { cout \u0026lt;\u0026lt; skt[tt] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } skt[++tt] = x; } return 0; } "},{"id":24,"href":"/docs/acwing/basic/831/","title":"831st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 10010, M = 10010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; for (int i = 2, j = 0; i \u0026lt;= n; i++) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } for (int i = 1, j = 0; i \u0026lt;= m; i++) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == n) { cout \u0026lt;\u0026lt; i - n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; j = ne[j]; } } return 0; } "},{"id":25,"href":"/docs/acwing/basic/835/","title":"835th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; // idx=0 为根, cnt[n]:以n为结尾的数量 int son[N][26], cnt[N], idx; char str[N]; void insert(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p]++; } int query(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n--) { char op[2]; scanf(\u0026#34;%s%s\u0026#34;, op, str); if (op[0] == \u0026#39;I\u0026#39;) insert(str); else printf(\u0026#34;%d\\n\u0026#34;, query(str)); } return 0; } "},{"id":26,"href":"/docs/acwing/basic/836/","title":"836th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int p[N]; int n, m; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) p[i] = i; while (m--) { char op[2]; int a, b; scanf(\u0026#34;%s%d%d\u0026#34;, op, \u0026amp;a, \u0026amp;b); if (op[0] == \u0026#39;M\u0026#39;) { p[find(a)] = find(b); } else { if (find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } "},{"id":27,"href":"/docs/acwing/basic/837/","title":"837th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int p[N], sz[N]; int n, m; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { p[i] = i; sz[i] = 1; } while (m--) { char op[5]; int a, b; scanf(\u0026#34;%s\u0026#34;, op); if (op[0] == \u0026#39;C\u0026#39;) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (find(a) == find(b)) continue; sz[find(b)] += sz[find(a)]; p[find(a)] = find(b); } else if (op[1] == \u0026#39;1\u0026#39;) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if (find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } else { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;, sz[find(a)]); } } return 0; } "},{"id":28,"href":"/docs/acwing/basic/838/","title":"838th","section":"Acwing","content":" \rLink\n #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], sz; void down(int u) { int t = u; if (u * 2 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (t != u) { swap(h[t], h[u]); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u / 2] \u0026gt; h[u]) { swap(h[u], h[u / 2]); u /= 2; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; h[i]; } sz = n; for (int i = n / 2; i; i--) { down(i); } while (m --) { cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; h[1] = h[sz]; sz -= 1; down(1); } return 0; } "},{"id":29,"href":"/docs/acwing/basic/839/","title":"839th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string.h\u0026gt; using namespace std; const int N = 100010; int h[N], ph[N], hp[N], sz; void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= sz \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (t != u) { heap_swap(t, u); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u / 2] \u0026gt; h[u]) { heap_swap(u, u / 2); u /= 2; } } int main() { int n, m = 0; cin \u0026gt;\u0026gt; n; while (n--) { char op[10]; scanf(\u0026#34;%s\u0026#34;, op); int k, x; if (!strcmp(op, \u0026#34;I\u0026#34;)) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); m++; sz++; ph[m] = sz, hp[sz] = m; h[sz] = x; up(sz); } else if (!strcmp(op, \u0026#34;PM\u0026#34;)) { printf(\u0026#34;%d\\n\u0026#34;, h[1]); } else if (!strcmp(op, \u0026#34;DM\u0026#34;)) { heap_swap(1, sz); sz--; down(1); } else if (!strcmp(op, \u0026#34;D\u0026#34;)) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); k = ph[k]; heap_swap(k, sz); sz--; down(k), up(k); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;k, \u0026amp;x); k = ph[k]; h[k] = x; down(k), up(k); } } return 0; } "},{"id":30,"href":"/docs/acwing/basic/840/","title":"840th","section":"Acwing","content":"\r开放寻址法\r#\r\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 2000003, null = 0x3f3f3f3f; int h[N]; bool find(int x) { int k = (x % N + N) % N; while (h[k] != null \u0026amp;\u0026amp; h[k] != x) { k++; if (k == N) k = 0; } return k; } int main() { int n; cin \u0026gt;\u0026gt; n; memset(h, 0x3f, sizeof(h)); while (n--) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); int k = find(x); if (*op == \u0026#39;I\u0026#39;) h[k] = x; else { if (h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 拉链法\r#\r\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000003; int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx; idx++; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } int main() { int n; cin \u0026gt;\u0026gt; n; memset(h, -1, sizeof(h)); while (n--) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) insert(x); else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } "},{"id":31,"href":"/docs/acwing/basic/841/","title":"841st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main() { scanf(\u0026#34;%d%d%s\u0026#34;, \u0026amp;n, \u0026amp;m, str + 1); p[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while (m--) { int l1, r1, l2, r2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;l1, \u0026amp;r1, \u0026amp;l2, \u0026amp;r2); if (get(l1, r1) == get(l2, r2)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } return 0; } "},{"id":32,"href":"/docs/acwing/basic/842/","title":"842nd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 10; int n; int path[N]; bool st[N]; void dfs(int u) { if (u == n) { for (int i = 0; i \u0026lt; n; i++) printf(\u0026#34;%d \u0026#34;, path[i]); puts(\u0026#34;\u0026#34;); return; } for (int i = 1; i \u0026lt;= n; i++) { if (!st[i]) { path[u] = i; st[i] = true; dfs(u + 1); st[i] = false; } } } int main() { cin \u0026gt;\u0026gt; n; dfs(0); return 0; } "},{"id":33,"href":"/docs/acwing/basic/843/","title":"843rd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 20; int n; char g[N][N]; bool col[N], dg[N], udg[N]; void dfs(int u) { if (u == n) { for (int i = 0; i \u0026lt; n; i++) puts(g[i]); puts(\u0026#34;\u0026#34;); return; } for (int i = 0; i \u0026lt; n; i++) { if (!col[i] \u0026amp;\u0026amp; !dg[u + i] \u0026amp;\u0026amp; !udg[u - i + n]) { g[u][i] = \u0026#39;Q\u0026#39;; col[i] = dg[u + i] = udg[u - i + n] = true; dfs(u + 1); g[u][i] = \u0026#39;.\u0026#39;; col[i] = dg[u + i] = udg[u - i + n] = false; } } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) g[i][j] = \u0026#39;.\u0026#39;; dfs(0); return 0; } 方式二：\n#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 20; int n; char g[N][N]; bool row[N], col[N], dg[N], udg[N]; void dfs(int x, int y, int s) { if (y == n) y = 0, x++; if (x == n) { if (s == n) { for (int i = 0; i \u0026lt; n; i++) puts(g[i]); puts(\u0026#34;\u0026#34;); } return; } // 不放皇后  dfs(x, y + 1, s); // 放  if (!row[x] \u0026amp;\u0026amp; !col[y] \u0026amp;\u0026amp; !dg[x + y] \u0026amp;\u0026amp; !udg[x - y + n]) { g[x][y] = \u0026#39;Q\u0026#39;; row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; dfs(x, y + 1, s + 1); row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; g[x][y] = \u0026#39;.\u0026#39;; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) g[i][j] = \u0026#39;.\u0026#39;; dfs(0, 0, 0); return 0; } "},{"id":34,"href":"/docs/acwing/basic/844/","title":"844th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 110; int n, m; int g[N][N]; int d[N][N]; queue\u0026lt;PII\u0026gt; q; int bfs() { q.push({0, 0}); int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; memset(d, -1, sizeof(d)); d[0][0] = 0; while (!q.empty()) { auto t = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; m \u0026amp;\u0026amp; g[x][y] == 0 \u0026amp;\u0026amp; d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x, y}); } } } return d[n - 1][m - 1]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) cin \u0026gt;\u0026gt; g[i][j]; cout \u0026lt;\u0026lt; bfs() \u0026lt;\u0026lt; endl; } "},{"id":35,"href":"/docs/acwing/basic/845/","title":"845th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; int bfs(string state) { queue\u0026lt;string\u0026gt; q; unordered_map\u0026lt;string, int\u0026gt; d; q.push(state); d[state] = 0; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; string end = \u0026#34;12345678x\u0026#34;; while (q.size()) { auto t = q.front(); q.pop(); if (t == end) return d[t]; int distance = d[t]; int k = t.find(\u0026#39;x\u0026#39;); int x = k / 3, y = k % 3; for (int i = 0; i \u0026lt; 4; i ++ ) { int a = x + dx[i], b = y + dy[i]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; 3 \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; 3) { swap(t[a * 3 + b], t[k]); if (!d.count(t)) { d[t] = distance + 1; q.push(t); } swap(t[a * 3 + b], t[k]); } } } return -1; } int main() { char s[2]; string state; for (int i = 0; i \u0026lt; 9; i ++ ) { cin \u0026gt;\u0026gt; s; state += *s; } cout \u0026lt;\u0026lt; bfs(state) \u0026lt;\u0026lt; endl; return 0; } "},{"id":36,"href":"/docs/acwing/basic/846/","title":"846th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], e[N], ne[N], idx; bool st[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int ans = N; int dfs(int u) { st[u] = true; int sum = 1, res = 0; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { int s = dfs(j); res = max(res, s); sum += s; } } res = max(res, n - sum); ans = min(ans, res); return sum; } int main() { cin \u0026gt;\u0026gt; n; memset(h, -1, sizeof(h)); for (int i = 0; i \u0026lt; n - 1; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b), add(b, a); } // 从编号为1的节点开始搜索  dfs(1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } "},{"id":37,"href":"/docs/acwing/basic/847/","title":"847th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], e[N], ne[N], idx; int d[N], q[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int bfs() { int hh = 0, tt = 0; q[0] = 1; memset(d, -1, sizeof(d)); d[1] = 0; while (hh \u0026lt;= tt) { int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (d[j] == -1) { d[j] = d[t] + 1; q[++t] = j; } } } return d[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof(h)); for (int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b), add(b, a); } cout \u0026lt;\u0026lt; bfs() \u0026lt;\u0026lt; endl; return 0; } "},{"id":38,"href":"/docs/acwing/basic/848/","title":"848th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], e[N], ne[N], idx; int d[N], q[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int topsort() { int hh = 0, tt = -1; for (int i = 1; i \u0026lt;= n; i++) if (!d[i]) q[++tt] = i; while (hh \u0026lt;= tt) { int t = q[hh++]; for (int i = h[t]; i != - 1; i = ne[i]) { int j = e[i]; d[j]--; if (d[j] == 0) q[++tt] = j; } } return tt == n - 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof(h)); for (int i = 0; i \u0026lt; m; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b), add(b, a); d[b]++; } if (topsort()) { for (int i = 0; i \u0026lt; n; i++) printf(\u0026#34;%d \u0026#34;, q[i]); puts(\u0026#34;\u0026#34;); } else { puts(\u0026#34;-1\u0026#34;); } return 0; } "},{"id":39,"href":"/docs/acwing/basic/849/","title":"849th","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 510; int n, m; int g[N][N]; int dist[N]; bool st[N]; int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; n; i++) { int t = -1; for (int j = 1; j \u0026lt;= n; j++) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; st[t] = true; for (int j = 1; j \u0026lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); } if (dist[n] == 0x3f3f3f) return -1; return dist[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(g, 0x3f, sizeof g); while (m--) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; g[a][b] = min(g[a][b], c); } cout \u0026lt;\u0026lt; dijkstra() \u0026lt;\u0026lt; endl; return 0; } "},{"id":40,"href":"/docs/acwing/basic/850/","title":"850th","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 100010; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f) return -1; return dist[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof h); while (m--) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; add(a, b, c); } cout \u0026lt;\u0026lt; dijkstra() \u0026lt;\u0026lt; endl; return 0; } "},{"id":41,"href":"/docs/acwing/basic/851/","title":"851st","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof h); while (m--) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; add(a, b, c); } int t = spfa(); if (t == -1) puts(\u0026#34;impossible\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, t); return 0; } "},{"id":42,"href":"/docs/acwing/basic/852/","title":"852nd","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N], cnt[N]; bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } bool spfa() { queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { q.push(i); st[i] = true; } while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u0026gt;= n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(h, -1, sizeof h); while (m--) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; add(a, b, c); } bool t = spfa(); if (t) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); return 0; } "},{"id":43,"href":"/docs/acwing/basic/853/","title":"853rd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 510, M = 100010; int n, m, k; int dist[N], backup[N]; struct Edge { int a, b, w; } edges[M]; int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; k; i++) { memcpy(backup, dist, sizeof dist); for (int j = 0; j \u0026lt; m; j++) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], backup[a] + w); } } // 考虑： 一条边为奂权重， a -\u0026gt; b(weight=-2), 假设到不了a，则一定到不了b，但是会更新dist[b]的值  if (dist[n] \u0026gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; m; i++) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; edges[i] = {a, b, c}; } int t = bellman_ford(); if (t == -1) puts(\u0026#34;impossible\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, t); return 0; } "},{"id":44,"href":"/docs/acwing/basic/854/","title":"854th","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 210, INF = 1e9; int n, m, Q; int d[N][N]; void floyd() { for (int k = 1; k \u0026lt;= n; k++) for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; Q; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (i == j) d[i][j] = 0; else d[i][j] = INF; while (m--) { int a, b, w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; w; d[a][b] = min(d[a][b], w); } floyd(); while (Q--) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (d[a][b] \u0026gt; INF / 2) puts(\u0026#34;impossible\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, d[a][b]); } return 0; } "},{"id":45,"href":"/docs/acwing/basic/858/","title":"858th","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; if (i \u0026amp;\u0026amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(g, 0x3f, sizeof g); while (m -- ) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(\u0026#34;impossible\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, t); return 0; } "},{"id":46,"href":"/docs/acwing/basic/859/","title":"859th","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010, M = 200010, INF = 0x3f3f3f3f; int n, m; int p[N]; struct Edge { int a, b, w; bool operator\u0026lt; (const Edge \u0026amp;W)const { return w \u0026lt; W.w; } }edges[M]; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 初始化并查集  int res = 0, cnt = 0; for (int i = 0; i \u0026lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) { p[a] = b; res += w; cnt ++ ; } } if (cnt \u0026lt; n - 1) return INF; return res; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; m; i ++ ) { int a, b, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;w); edges[i] = {a, b, w}; } int t = kruskal(); if (t == INF) puts(\u0026#34;impossible\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, t); return 0; } "},{"id":47,"href":"/docs/acwing/basic/860/","title":"860th","section":"Acwing","content":"\rYes\n#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010, M = 200010; int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!color[j]) { if (!dfs(j, 3 - c)) return false; } else if (color[j] == c) return false; } return true; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b), add(b, a); } bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (!color[i]) { if (!dfs(i, 1)) { flag = false; break; } } if (flag) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); return 0; } "},{"id":48,"href":"/docs/acwing/basic/861/","title":"861st","section":"Acwing","content":"\r#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 510, M = 100010; int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; bool st[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n1, \u0026amp;n2, \u0026amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); } int res = 0; for (int i = 1; i \u0026lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } "},{"id":49,"href":"/docs/acwing/basic/866/","title":"866th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; bool is_prime(int x) { if (x \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n -- ) { int x; cin \u0026gt;\u0026gt; x; if (is_prime(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } return 0; } "},{"id":50,"href":"/docs/acwing/basic/867/","title":"867th","section":"Acwing","content":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; void divide(int x) { for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } if (x \u0026gt; 1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n -- ) { int x; cin \u0026gt;\u0026gt; x; divide(x); } return 0; } "},{"id":51,"href":"/docs/acwing/basic/868/","title":"868th","section":"Acwing","content":"\r朴素筛法\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N= 1000010; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i + i; j \u0026lt;= n; j += i) st[j] = true; } } int main() { int n; cin \u0026gt;\u0026gt; n; get_primes(n); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } 线性筛法 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int N= 1000010; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int main() { int n; cin \u0026gt;\u0026gt; n; get_primes(n); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } "},{"id":52,"href":"/docs/acwing/basic/869/","title":"869th","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n -- ) { int x; cin \u0026gt;\u0026gt; x; auto res = get_divisors(x); for (auto x : res) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } return 0; } "},{"id":53,"href":"/docs/acwing/basic/870/","title":"870th","section":"Acwing","content":"\r\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin \u0026gt;\u0026gt; n; unordered_map\u0026lt;int, int\u0026gt; primes; while (n -- ) { int x; cin \u0026gt;\u0026gt; x; for (int i = 2; i \u0026lt;= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x \u0026gt; 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) res = res * (p.second + 1) % mod; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } "},{"id":54,"href":"/docs/acwing/basic/871/","title":"871st","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin \u0026gt;\u0026gt; n; unordered_map\u0026lt;int, int\u0026gt; primes; while (n -- ) { int x; cin \u0026gt;\u0026gt; x; for (int i = 2; i \u0026lt;= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x \u0026gt; 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } "},{"id":55,"href":"/docs/acwing/basic/872/","title":"872nd","section":"Acwing","content":"\r#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n -- ) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%d\\n\u0026#34;, gcd(a, b)); } return 0; } "},{"id":56,"href":"/docs/book/resource/","title":"Resource","section":"Book","content":"相关资源\r#\r\r  \r藏经阁\n  \rNo Starch Press\n  \rThe Pragmatic Bookshelf\n  \rManning\n  \rO\u0026rsquo;Reilly\n  \rLet Me Read\n  \rLibrary Genesis\n  \rSaltTiger 目前我主要在以下网站收集编程类电子书，大家去这上面找书就好，下载方法也一并给出：\n  \rCoderProg，点击验证码，跳转至Rapidgator或Turbobit网盘，将网盘链接复制到\r木薯牛网盘中转站（1G流量1.33元）进行中转，即可下载。\n  \rAvaxHome，跳转至icerbox网盘，将网盘链接复制到\r思飞网盘中转站（1G icerbox流量2.8元）进行中转，中转后自动转存到绑定的百度网盘，即可下载。\n  \rFox eBook，跳转至NitroFlare网盘，将网盘链接复制到\r木薯牛网盘中转站进行中转，即可下载。\n  \rLibrary Genesis，点击Mirrors链接直接下载。\n  \rLet Me Read，点击验证码，跳转DirectLink直接下载。\n    \rZlibrary\n  \rLeanpub\n  \rThe best Programming books\n  "},{"id":57,"href":"/docs/book/timeline/","title":"Timeline","section":"Book","content":" 书籍是人类进步的阶梯。\n  温故而知新,可以为师矣。\n 喜欢读书的人在死之前，活过1000次，不读书的人只活过一次。\r-- 乔治 R.R. 马丁\r《Vim实用技巧》\n 2022/3/23 P48  《Java程序员修炼之道》\n 2022/3/23 P77  《挑战程序设计竞赛2-算法和数据结构》\n 2022/3/21 Ch1  《你真的会写代码吗》\n《现代 JavaScript 教程》\n 2022/3/12 Finish  《剑指Offer：名企面试官精讲典型编程题-电子工业出版社 (2017)》\n 2022/1/26 2.3.3  《计算的本质：深入剖析程序和计算机》\n 2022/1/26 Ch1  《人月神话》\n 2022/1/23  《图解TCP/IP》\n 2022/1/15  《Java编程思想》\n 2021/12/23 5.7  《C++ Primer》\n 2021/12/6 P57 2022/1/3 Ch2.4  《Java并发编程实战》\n《深度思考不断逼近问题的本质》\n 2021/10/10 2021/10/12 P58  《设计模式：可复用面向对象软件的基础》\n 2021/10/14 2021/11/4 CH1  《七周七语言：理解多种编程范型》\n 2021/10/21 Ch1  《Scala函数式编程》\n 2021/10/29 CH1 2021/11/11 CH2  《Head First设计模式》\n 2021/11/9  《现代操作系统》\n《English++ (English for Computer Science Students)》\n《C专家编程》\n 2022/1/1 Ch1 2022/3/18 2.4.2  《Spring Boot实战派让开发像搭积木一样简单》\n 2022/3/18 P33 2022/3/19 Finish  《现代 C++ 教程》\n 2022/3/7 Ch1 ~ Ch2 2022/3/8 Finish  《算法导论》\n 2022/1/24 Ch1 2022/1/26 Ch2 ~ Ch4 2022/2/10 Ch6 ~ Ch14  《精通Spring 4.x 企业应用开发实战》\n Todo 18、19、20  《Java性能权威指南》\n 2021/12/16 Ch1 2022/2/6 Ch2~Ch4  《自己动手写Java虚拟机》\n 2021/12/21 Ch1 2021/12/23 Ch2 2021/12/31 Ch3.3 2022/1/1 Ch3 2022/2/6 Ch4 2022/2/7 Ch5  《Head First设计模式》 《计算机组成与设计（RISC-V 版）》\n《深入理解Java模块系统》\n 2022/3/13 Ch1  《深入理解Java虚拟机：JVM高级特性与最佳实践》\n 2022/3/15 Ch1  《MySQL是怎样运行的：从根儿上理解MySQL》\n 2022/3/19  《Mysql技术内幕》 《Java并发编程实战》\n《数据结构与算法分析：C语言描述》\n 2021/10/14 P27 2021/11/5 CH2  《Scala函数式编程》\n 2022/3/4 P47 2022/3/8 Ch3  《Netty实战》\n 2022/3/9 Ch1 ~ Ch3  《Java高并发编程详解：多线程与架构设计》 《Java高并发编程详解：深入理解并发核心库》 《Java程序员修炼之道》 《编程之美》\n《gRPC与云原生应用开发：以Go和Java为例》\n 2022/3/4 P54 2022/3/5 P73 2022/3/6 Finish  《精力管理》\n 2022/3/5 Ch3  《巨人的工具》\n 2022/3/5  《领域驱动设计：软件核心复杂性应对之道》\n《测试驱动开发》\n 2022/3/2 Ch1 ~ Ch8 2022/3/3 Ch9 ~ Ch19 2022/3/4 Finish  《图解HTTP》\n 2022/2/26 Ch1 ~ Ch6 2022/2/27 Ch7 ~ Ch8 2022/2/28 Finish  《网络基本功系列》\n 2022/2/23 Ch1 ~ Ch3  《软件设计的哲学》\n 2022/2/22 Ch1 ~ Ch4  《Atomic Kotlin》\n 2022/3/1 P38 2022/3/2 P56 2022/3/7 P86  《On Java8》\n《Linux就该这么学》\n《UNIX网络编程 卷1：套接字联网API》\n 2021/12/8 P17 2022/2/10 Ch2 2022/3/4 Ch3 2022/3/7 Ch4 2022/3/8 Ch5 2022/3/13 Ch6 2022/3/20 Ch7 2022/3/22 Ch8 ~ Ch10  《TCP-IP详解 卷1：协议》\n 2021/10/16 CH1 2021/10/19 CH2 2021/10//20 CH3、CH4、CH5 2021/11/10 Ch8 2021/11/20 Ch9、Ch10 2022/3/4 Ch11  《LinuxUNIX系统编程》\n 2021/10/11 P46 2021/10/21 CH3 2021/11/4 CH4、5、6 2021/11/5 CH7 2021/11/21 Ch11、Ch12 2021//11/30 Ch13 2022/2/22 Ch14 2022/2/24 Ch15 ~ Ch19  《数据库系统概念》\n 2021/11/25 Ch1 2021/12/2 Ch2 2021/12/13 Ch3 2021/12/30 P102 2022/1/4 Ch4.5 2022/3/18 P126 2022/3/24 Ch5  《操作系统真象还原》\n 2021/10/21 2021/10/29 Ch0 2021/10/30 Ch1 2021/11/24 Ch2 2022/2/22 P81 2022/3/1 P91 2022/3/2 P101  《计算机系统要素：从零开始构建现代计算机》\n 2021/11/16 Ch8 2021/12/28 Ch9 2022/2/10 Ch10 2022/2/16 Ch11 2022/2/19 Finsih  《数据密集型应用系统设计》\n 2021/11/6 2021/11/19 Ch1 2021/11/28 Ch2、P86 2021/12/4 P89 2021/12/11 Ch3、P124 2021/12/12 Ch4 2021/12/21 2021/12/28 Ch5 2022/1/31 Ch6 2022/2/16 Ch7 2022/3/10 Ch8 2022/3/18 P319 2022/3/19 Ch9  《现代C++白皮书》\n 2021/12/30 P60  《计算机程序的构造和解释》\n 2022/2/13 3.5  《Redis设计与实现》\n 2021/10/13 CH7 2021/10/25 CH8、CH9  《Wireshark数据包分析实战》\n 2021/12/4 Ch1 2022/2/10 Ch2~Ch4 2022/2/14 Ch5 2022/3/13 Ch7 2022/3/14 Ch8 ~ Ch10 2022/3/16 Finish  《如何科学学外语 语言习得的真相与方法》\n 2022/2/2 Ch1~Ch4 2022/2/3 Finish  《软件开发实践：项目驱动式的Java开发指南》\n 2022/2/2 Ch1~Ch3 2022/2/3 Finish  《JAVA解惑》\n 2022/2/6 Finish  《算法4》\n 2022/1/25 Finish  《编程珠玑》\n 2021/11/27 Ch1 2021/12/14 Ch2 2022/1/3 Ch3 2022/1/25 Finish  《Java工程师修炼之道》\n 2022/1/11 1.1 2022/1/23 Finish  《The Little Schemer》\n 2021/11/15 Ch5 2021/11/25 Ch6 2022/1/15 Ch7 2022/1/22 Finish  《代码整洁之道》\n 2021/11/15 Ch3 2021/12/14 Ch4、Ch5、Ch6 2022/1/21 Ch7、8、9、10、11 2022/1/22 Finish  《Java并发编程的艺术》\n 2021/10/9 P280 ~ P304 2021/10/30 Finish  《操作系统导论》\n 2021/10/9 P204 - P229 2021/10/10 P228 - P259 2021/10/11 P259 - P289 2021/10/12 P289 - P311 2021/10/13 P311 - P335 2021/10/14 P335 - P366 2021/10/17 CH40、41、42 2021/10/18 Finish  《Build On Your Lisp》\n 2021/10/12 CH7 2021/10/23 CH10 2021/11/5 Finish  《UNIX环境高级编程》\n 2021/10/22 CH11 2021/10/31 CH12 2021/11/10 2021/11/20 Ch16 2021/11/24 Finish  "},{"id":58,"href":"/docs/cs/algo/","title":"Algo","section":"C S","content":" \rTemplates  Kata\r#\r\r \rAIZU ONLINE JUDGE \rCode Kata collection for JVM Languages and Libraries. \rExercism \rCodewars   Resources\r#\r\r \rSummary of MIT Introduction to Algorithms course \ralgo-basic \r《algorithm-note》中文版 \rMEGA \rElementary Algorithms  Tools\r#\r\r \rVisuAlgo.net \rBig-O Cheat Sheet \rAlgorithm Visualizer \rData Structure Visualizations  "},{"id":59,"href":"/docs/cs/algo/template/","title":"Template","section":"Algo","content":" \rAcwing模板\n 快速排序\r#\r\rvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } 归并排序\r#\r\rvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 二分\r#\r\r// 区间[l,r]划分成[l, mid], [mid + 1, r] void binary_search1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) { //check() 检查mid是否满足性质  r = mid; } else { l = mid + 1; } } } // 区间[l,r]划分成[l, mid - 1], [mid, r] void binary_search2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1\u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } } 双指针\r#\r\r常见问题分类：\r(1) 对于一个序列，用两个指针维护一段区间\r(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\rfor (int i = 0, j = 0; i \u0026lt; n; i ++ ) { while (j \u0026lt; i \u0026amp;\u0026amp; check(i, j)) j ++ ; // 具体问题的逻辑 } 位运算\r#\r\r求n的第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1\r返回n的最后一位1：lowbit(n) = n \u0026amp; -n\r离散化\r#\r\rvector\u0026lt;int\u0026gt; alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素  // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 区间合并\r#\r\r// 将所有存在交集的区间合并 void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 单链表\r#\r\r// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } 双链表\r#\r\r// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点  r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈\n// tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u0026gt; 0) { } 队列\r#\r\r 普通队列  // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u0026lt;= tt) { } 循环队列  // hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt) { } 单调栈\r#\r\r常见模型：找出每个数左边离它最近的比它大/小的数\nint tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 单调队列\r#\r\r常见模型：找出滑动窗口中的最大值/最小值\nint hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口  while (hh \u0026lt;= tt \u0026amp;\u0026amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP\r#\r\r// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 // 求模式串的Next数组： for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑  } } Trie树\r#\r\rint son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量  // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集\r#\r\r// (1)朴素并查集：  int p[N]; //存储每个点的祖宗节点  // 返回x的祖宗节点  int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n  for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合：  p[find(a)] = find(b); // (2)维护size的并查集：  int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量  // 返回x的祖宗节点  int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n  for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合：  size[find(b)] += size[find(a)]; p[find(a)] = find(b); // (3)维护到祖宗节点距离的并查集：  int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离  // 返回x的祖宗节点  int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n  for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合：  p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆\r#\r\r// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u / 2]) { heap_swap(u, u / 2); u \u0026gt;\u0026gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); 一般哈希\r#\r\r// (1) 拉链法  int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数  void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在  bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } // (2) 开放寻址法  int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置  int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希\r#\r\r核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\r小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\ntypedef unsigned long long ULL; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64  // 初始化 p[0] = 1; for (int i = 1; i \u0026lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STL简介\r#\r\rvector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair\u0026lt;int, int\u0026gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset\u0026lt;10000\u0026gt; s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 树与图的存储\r#\r\r树是一种特殊的图，与图的存储方式相同。\n对于无向图中的边ab，存储两条有向边a-\u0026gt;b, b-\u0026gt;a。\n因此我们可以只考虑有向图的存储。\n(1) 邻接矩阵：g[a][b] 存储边a-\u0026gt;b\n(2) 邻接表：\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-\u0026gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历\r#\r\r时间复杂度 O(n + m), n 表示点数，m 表示边数\n(1) 深度优先遍历\nint dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过  for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } (2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次\nqueue\u0026lt;int\u0026gt; q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!s[j]) { st[j] = true; // 表示点j已经被遍历过  q.push(j); } } } 拓扑排序\r#\r\r时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度  for (int i = 1; i \u0026lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh \u0026lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。  return tt == n - 1; } 朴素dijkstra算法\r#\r\r时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数\nint g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定  // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点  for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 用t更新其他点的距离  for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 堆优化版dijkstra\r#\r\r时间复杂度 O(m logn), n 表示点数，m 表示边数\ntypedef pair\u0026lt;int, int\u0026gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定  // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; heap.push({0, 1}); // first存储距离，second存储节点编号  while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Ford算法\r#\r\r时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数\n注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\nint n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离  struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。  for (int i = 0; i \u0026lt; n; i ++ ) { for (int j = 0; j \u0026lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] \u0026gt; dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] \u0026gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } spfa 算法（队列优化的Bellman-Ford算法）\r#\r\r时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中  // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入  { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfa判断图中是否存在负环\r#\r\r时间复杂度是 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中  // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组  // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。  queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u0026gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环  if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法\r#\r\r时间复杂度是 O(n3), n 表示点数\n初始化： for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k \u0026lt;= n; k ++ ) for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 朴素版prim算法\r#\r\r时间复杂度是 O(n^2 + m), n 表示点数，m 表示边数\nint n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中  // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; if (i \u0026amp;\u0026amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskal算法\r#\r\r时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数\nint n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组  struct Edge // 存储边 { int a, b, w; bool operator\u0026lt; (const Edge \u0026amp;W)const { return w \u0026lt; W.w; } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 初始化并查集  int res = 0, cnt = 0; for (int i = 0; i \u0026lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并  { p[a] = b; res += w; cnt ++ ; } } if (cnt \u0026lt; n - 1) return INF; return res; } 染色法判别二分图\r#\r\r时间复杂度是 O(n+m), n 表示点数，m 表示边数\nint n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色  // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 匈牙利算法\r#\r\r时间复杂度是 O(nm), n 表示点数，m 表示边数\nint n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过  bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i \u0026lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 试除法判定质数\r#\r\rbool is_prime(int x) { if (x \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数\r#\r\rvoid divide(int x) { for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } if (x \u0026gt; 1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } 朴素筛法求素数\r#\r\rint primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉  void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i; j \u0026lt;= n; j += i) st[j] = true; } } 线性筛法求素数\r#\r\rint primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉  void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数\r#\r\rvector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数和约数之和\r#\r\r如果 N = p1^c1 * p2^c2 * ... *pk^ck\r约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\r约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\r欧几里得算法\r#\r\rint gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 求欧拉函数\r#\r\rint phi(int x) { int res = x; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数\r#\r\rint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉  void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂\r#\r\r求 m^k mod p，时间复杂度 O(logk)。\nint qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } 扩展欧几里得算法\r#\r\r// 求x, y，使得ax + by = gcd(a, b)\nint exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 高斯消元\r#\r\r// a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c \u0026lt; n; c ++ ) { int t = r; for (int i = r; i \u0026lt; n; i ++ ) // 找到绝对值最大的行  if (fabs(a[i][c]) \u0026gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) \u0026lt; eps) continue; for (int i = c; i \u0026lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端  for (int i = n; i \u0026gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前上的首位变成1  for (int i = r + 1; i \u0026lt; n; i ++ ) // 用当前行将下面所有的列消成0  if (fabs(a[i][c]) \u0026gt; eps) for (int j = n; j \u0026gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r \u0026lt; n) { for (int i = r; i \u0026lt; n; i ++ ) if (fabs(a[i][n]) \u0026gt; eps) return 2; // 无解  return 1; // 有无穷多组解  } for (int i = n - 1; i \u0026gt;= 0; i -- ) for (int j = i + 1; j \u0026lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 递归法求组合数\r#\r\r// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i \u0026lt; N; i ++ ) for (int j = 0; j \u0026lt;= i; j ++ ) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; 通过预处理逆元的方式求组合数\r#\r\r首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]\r如果取模的数是质数，可以用费马小定理求逆元\rint qmi(int a, int k, int p) // 快速幂模板\r{\rint res = 1;\rwhile (k)\r{\rif (k \u0026amp; 1) res = (LL)res * a % p;\ra = (LL)a * a % p;\rk \u0026gt;\u0026gt;= 1;\r}\rreturn res;\r}\r// 预处理阶乘的余数和阶乘逆元的余数\rfact[0] = infact[0] = 1;\rfor (int i = 1; i \u0026lt; N; i ++ )\r{\rfact[i] = (LL)fact[i - 1] * i % mod;\rinfact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;\r}\rLucas定理\r#\r\r若p是质数，则对于任意整数 1 \u0026lt;= m \u0026lt;= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } int C(int a, int b) // 通过定理求组合数C(a, b) { int res = 1; for (int i = 1, j = a; i \u0026lt;= b; i ++, j -- ) { res = (LL)res * j % p; res = (LL)res * qmi(i, p - 2) % p; } return res; } int lucas(LL a, LL b) { if (a \u0026lt; p \u0026amp;\u0026amp; b \u0026lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; } 分解质因数法求组合数\r#\r\r当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\r1. 筛法求出范围内的所有质数\r2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...\r3. 用高精度乘法将所有质因子相乘\rint primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉  void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n！中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; a, int b) // 高精度乘低精度模板 { vector\u0026lt;int\u0026gt; c; int t = 0; for (int i = 0; i \u0026lt; a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数  for (int i = 0; i \u0026lt; cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector\u0026lt;int\u0026gt; res; res.push_back(1); for (int i = 0; i \u0026lt; cnt; i ++ ) // 用高精度乘法将所有质因子相乘  for (int j = 0; j \u0026lt; sum[i]; j ++ ) res = mul(res, primes[i]); 卡特兰数\r#\r\r给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\rNIM游戏\r#\r\r给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\r我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。\r所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。\rNIM博弈不存在平局，只有先手必胜和先手必败两种情况。\r定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0\r公平组合游戏ICG\r#\r\r若一个游戏满足：\r由两名玩家交替行动；\r在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\r不能行动的玩家判负；\r则称该游戏为一个公平组合游戏。\rNIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。\r有向图游戏\r#\r\r给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。\r任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\rMex运算\r#\r\r设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：\rmex(S) = min{x}, x属于自然数，且x不属于S\rSG函数\r#\r\r在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：\rSG(x) = mex({SG(y1), SG(y2), …, SG(yk)})\r特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\r有向图游戏的和\r#\r\r设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。\r有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：\rSG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\r定理\r有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。\r有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\r"},{"id":60,"href":"/docs/cs/build/","title":"Build","section":"C S","content":" \rlearn-x-by-doing-y \rbuild-your-own-x \rProject Based Learning  "},{"id":61,"href":"/docs/cs/concurency/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/","title":"Java并发编程艺术","section":"C S","content":"11.2 定位问题\r#\r\r线上代码定位问题\n11.3 性能测试\r#\r\r相关的命令\n"},{"id":62,"href":"/docs/cs/courses/","title":"Courses","section":"C S","content":"自学指南\r#\r\r CS不仅靠天赋，更靠兴趣与努力！\n 目前正在学习的课程\r#\r\rCS61A CS61B CS61C CS106B CS106L uw-programming algs4\nSchedule\r#\r\rThis week\u0026rsquo;s schedule\n 5:00~6:00 Memorize English\n  18:00~20:00 English\n  20:00~22:00 Solve dues\n  22:00~22:30 Memorize English\n Thanks\r#\r\r感谢\rCS自学指南对于信息的整合。你也可以和我一起在\r这里找到自己心仪的课程。\n [MIT 6.Null The Missing Semester of Your CS Education]  编程入门\r#\r\r CSE 251 Programming in C Programming Languages, Part A Standford CS106L C++ Programming CS 61A: Structure and Interpretation of Computer Programs  数据结构与算法\r#\r\r UCB CS61B Data Structures Standford CS106B Programming Abstractions  软件工程\r#\r\r MIT 6.031: Software Construction UCB CS169: software engineering  体系结构\r#\r\r From Nand to Tetris Building a Modern Computer From First Principles UCB CS61C Great Ideas in Computer Architecture (Machine Structures)  系统入门\r#\r\r MIT6.033: System Engineering CMU 15-213: Introduction to Computer System  操作系统\r#\r\r MIT 6.S081 Operating System Engineering UCB CS162: Operating Systems and System Programming  数据库系统\r#\r\r CMU 15-445: Introduction to Database System (C++) UCB CS186: Introduction to Database System (Java)  计算机网络\r#\r\r Stanford CS144: Computer Network  编译原理\r#\r\r Stanford CS143: Compilers  并行与分布式系统\r#\r\r CMU 15-418/Stanford CS149: Parallel Computing MIT 6.824: Distributed System  系统安全\r#\r\r UCB CS161: Computer Security  "},{"id":63,"href":"/docs/cs/database/","title":"Database","section":"C S","content":" \rdb-tutorial 是一个数据库教程。 \r电子科技大学分布式存储与计算实验室新生训练计划 \r😋 A curated reading list about database systems \rReadings in Databases \rA list of papers about distributed consensus. \rCollect some book about distributed storage system  "},{"id":64,"href":"/docs/cs/interviews/","title":"Interviews","section":"C S","content":" \r整理it资料的百科全库 \r介绍中国各二线以上城市的互联网环境以及生活成本  Java\r#\r\r \rbugstack 虫洞栈 \rJava 全栈知识体系 \rJavaGuide \rbestJavaer \rJavaFamily \rJavaTutorial \rlearning-note \rJavaKeeper \r互联网 Java 工程师进阶知识完全扫盲 \rJavaHome \rJavaSourceCodeLearning \rDocs \rJavaYouth \rjavaDesign \r大厂面试指北 \r算法刷题指南、Java多线程与高并发、Java集合源码、Spring boot、Spring Cloud等笔记，源码级学习笔记后续也会更新。  C++\r#\r\r \r【C++面试\u0026amp;C++学习指南】 这里整理了C++后端研发工程师面试和工作必备的知识点 。  Others\r#\r\r \r互联网公司常用框架源码赏析 \rTech Interview Handbook \rCS-Notes \rEverything you need to know to get the job.  "},{"id":65,"href":"/docs/cs/linux/main/","title":"Main","section":"C S","content":" strace 跟踪系统调用 stat 打印文件信息 mount 查看挂载的文件系统 grep telnet /etc/services 包含了一些熟知的端口号 ldd proc 列出程序的动态依赖性 ip addr / ping baidu.com df -h / find . -name \u0026ldquo;*.cpp\u0026rdquo; fdisk /dev/sdb shutdown -h 0 apt install qemu-system pdfjoin a.pdf b.pdf iconv -f gbk -t utf-8 file.txt xxd 查看文件二进制  输出当前用户是不是 root\n [ $UID -eq 0 ] \u0026amp;\u0026amp; echo \u0026quot;is root!\u0026quot;  查看磁盘引导扇区 (Master Boot Record)\n cat /dev/sdb | head -c 512 | ndisasm -b 16 -o 0x7c00 -  统计所有 cpp 文件的行数\n find . | grep '\\.cpp$' | xargs cat | wc -l  统计命令行命令的频率\n  history | tr -s ' ' | cut -d ' ' -f3 | sort | uniq -c | sort -nr\n  文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar\n  文件检索 - cat, more, less, head, tail, file, find\n  输入输出控制 - 重定向, 管道, tee, xargs\n  文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr\n  正则表达式\n  系统监控 - jobs, ps, top, kill, free, demsg, lsof\n   如何比较两个文件是否完全相同?   diff or md5sum\n  如何列出一个C语言项目中所有被包含过的头文件?   find . -name \u0026ldquo;*.[ch]\u0026rdquo; | xargs grep \u0026ldquo;#include\u0026rdquo; | sort | uniq\n du -h -d 1 2\u0026gt;/dev/null | grep -v denied 磁盘分析\n\r配置linux\n查看最大空间占用目录\nsudo du -h \u0026ndash;exclude=\u0026ldquo;mnt*\u0026rdquo; \u0026ndash;exclude=\u0026ldquo;proc*\u0026rdquo; -d 1 /\np@ssw0rd\n"},{"id":66,"href":"/docs/cs/linux/wsl/","title":"W S L","section":"C S","content":"\r为WSL2加图形化界面配置\n运行 startxfce4\n"},{"id":67,"href":"/docs/cs/network/","title":"Network","section":"C S","content":"Tools\r#\r\r \rWhois  "},{"id":68,"href":"/docs/cs/network/tcp-ip/","title":"Tcp Ip","section":"Network","content":"  sudo apt install net-tools\r#\r\r  ifconfig\n  netstat -in\n  tcpdump\n  "},{"id":69,"href":"/docs/cs/operatingsystem/","title":"Operating System","section":"C S","content":" \r操作系统导论(ostep)笔记/课后习题答案/附加代码  "},{"id":70,"href":"/docs/cs/programming/","title":"Programming","section":"C S","content":" \rC \rJava \rGo \rC++ \rPython \rRust \rJavaScript \rScala \rKotlin \rWeb  "},{"id":71,"href":"/docs/cs/programming/c++/","title":"C++","section":"Programming","content":"Resources\r#\r\r \rC++那些事 \r关于C++STL的总体介绍 \rCheat Sheets \u0026amp; Infographics \r现代 C++ 教程  "},{"id":72,"href":"/docs/cs/programming/go/","title":"Go","section":"Programming","content":"Resources\r#\r\r \rGo by Example \rGo语言圣经中文版 Link \rLearn Go with Tests \r【未来服务器端编程语言】最全空降golang资料补给包（满血战斗），包含文章，书籍，作者论文，理论分析，开源框架，云原生，大佬视频，大厂实战分享ppt \r1000+ Hand-Crafted Go Examples, Exercises, and Quizzes \rA Tuor of Go \rStandard Go Project Layout \rGo 语言设计与实现 \r《Effective Go》中英双语版 \rGo语言高级编程 \rPractical Go Lessons \rA hands-on approach to getting started with Go generics. \rList of Golang books \r7 days golang programs from scratch \rGolangStudy: Golang 面试学习 \rGolang从入门到跑路  "},{"id":73,"href":"/docs/cs/programming/java/","title":"Java","section":"Programming","content":" \rlearningSummary \rjetbrain.in Zhile \r芋道源码 —— 纯源码解析博客 \r深入浅出Java多线程  "},{"id":74,"href":"/docs/cs/programming/js/","title":"J S","section":"Programming","content":" \r现代 JavaScript 教程 \r函数式编程指北 \rFull Stack Open  "},{"id":75,"href":"/docs/cs/programming/rust/","title":"Rust","section":"Programming","content":"Resources\r#\r\r \rWriting an OS in Rust \rRust 程序设计语言 \rA book about Rust Data Structures and Algorithms. \rRust语言圣经  "},{"id":76,"href":"/docs/cs/programming/rust/readme/","title":"R E a D M E","section":"Rust","content":"Cargo\r#\r\r cargo new project-name  "},{"id":77,"href":"/docs/cs/programming/web/","title":"Web","section":"Programming","content":"Resources\r#\r\rhttps://css-speedrun.netlify.app/\nFramework\r#\r\r \rNext Ui  React\r#\r\r \rReact CheatSheet  "},{"id":78,"href":"/docs/cs/resource/","title":"Resource","section":"C S","content":"CS Resources\r#\r\r \rTeach Yourself Computer Science \r📚 List of awesome university courses for learning Computer Science! \rA complete computer science study plan to become a software engineer. \r97 Things Every Programmer Should Know \rCS公开课程学习群课程推荐 \r克莱登大学CS(热心网友整理) \r🎓 Path to a free self-taught education in Computer Science! \rThis is The Entire Computer Science Curriculum in 1000 YouTube Videos \r写在20年初的校招面试心得与自学CS经验及找工作分享 \rTeach Yourself Programming in Ten Years \rCS自学指南 \r从小白到BAT后端工程师的自学路线 \rA Self-Learning, Modern Computer Science Curriculum \r名校公开课程评价网 \rBest-websites-a-programmer-should-visit \rCS-Awesome-Courses \rcs-video-courses \rEvery Programmer Should Know  \rExplore, Create and Share Learning Roadmaps in Tech \rAlgorithms-Cheatsheet-Resources \rRoadmap \rRico\u0026rsquo;s cheatsheets \rA collection of the best resources for programming, web development, computer science and more. \r💻📖对开发人员有用的定律、理论、原则和模式 \r给新员工和实习生的生存指南 \rAudit Over 700 CS Classes From Renowned Universities  "},{"id":79,"href":"/docs/cs/software/","title":"Software","section":"C S","content":" \r为什么这么设计系列文章 \rsystem-design-primer \rThe Architecture of Open Source Applications \rMy favorite papers \rpapers-we-love \rC++11全套设计模式-23种指针的用法  "},{"id":80,"href":"/docs/cs/tools/","title":"Tools","section":"C S","content":" \rRegular Expression \rMaven \rDocker \rGDB \rLinux \rWSL  "},{"id":81,"href":"/docs/cs/tools/docker/","title":"Docker","section":"Tools","content":"使用Docker提供本项目的Mysql和Redis服务\r#\r\rInstall\r#\r\rhttps://docs.docker.com/install/linux/docker-ce/centos/\nhttps://blog.csdn.net/weixin_39477597/article/details/87715899\nhttps://blog.csdn.net/weixin_43569697/article/details/89279225\nCMD中写windows路径 //c\n-v /c\\Users\\sunhu\\Documents\\Study\\Tool\\calibre-web\\books\nDocker 启动、重启、关闭\r#\r\r开机自启\nsystemctl enable docker\nsystemctl start docker\n守护进程重启 systemctl daemon-reload\n重启docker服务 systemctl restart docker / service docker restart\n关闭 docker service docker stop / docker systemctl stop docker\n停用全部运行中的容器:\r#\r\rdocker stop $(docker ps -q)\n删除全部容器：\r#\r\rdocker rm $(docker ps -aq)\n一条命令实现停用并删除容器：\r#\r\rdocker stop $(docker ps -q) \u0026amp; docker rm $(docker ps -aq)\r命令\r#\r\r docker images docker search \u0026lt;image_name\u0026gt; docker pull \u0026lt;域名\u0026gt;//: docker rmi : docker inspect \u0026lt;image_id\u0026gt; 查看容器信息  容器命令\r#\r\r docker create \u0026lt;image_name\u0026gt; docker run \u0026lt;image_name\u0026gt; docker run ubuntu /bin/echo \u0026ldquo;Test\u0026rdquo; docker run \u0026ndash;name demo -d ubuntu docker stop \u0026lt;container_id\u0026gt; docker ps 查看运行中的容器 docker ps -a 列出启动过的容器 可以使用start重新启动 docker start \u0026lt;container_id\u0026gt; 启动容器 docker rm \u0026lt;container_id\u0026gt; docker rm -f \u0026lt;container_id\u0026gt; docker container top  docker exec \u0026lt;container_id\u0026gt;  docker exec -it \u0026lt;container_id\u0026gt; bash 登陆到容器中    案例\r#\r\rdocker run \u0026ndash;name mysqlsvr -p 12345:3306 -e MYSQL_ROOT_PASSWORD=sfy1314 -d mysql\ndocker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server \u0026ndash;appendonly yes\n开机自启\ndocker run \u0026ndash;restart=always \u0026ndash;name first-mysql -p 12345:3306 -e MYSQL_ROOT_PASSWORD=sfy1314 -d mysql\nMongoDB\r#\r\rdocker run \u0026ndash;name mongo -p 27017:27017 -v ~/Desktop/docker/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo\n登录到MongoDB容器中\ndocker exec -it mongo bash\n通过Shell连接MongoDB\nmongo -u admin -p admin\nRdis\r#\r\r获取镜像\ndocker pull redis\n启动Redis\ndocker run \u0026ndash;name redis -d -p 6379:6379 redis\ndocker exec -it \u0026lt;container_name\u0026gt; redis-cli\nNginx\r#\r\rdocker run \u0026ndash;restart always \u0026ndash;name my-nginx -p 80:80 -d nginx\nRabbitMQ\r#\r\r#指定版本，该版本包含了web控制页面\rdocker pull rabbitmq:management\rdocker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management\rElasticSearch\r#\r\rdocker run -d -p 9200:9200 elasticsearch\r"},{"id":82,"href":"/docs/cs/tools/gdb/","title":"G D B","section":"Tools","content":"Resources\r#\r\r \r用GDB调试程序 \r100-gdb-tips  GCC\r#\r\r  -E 获取预处理后的文件内容\n  -V 将编译、链接过程打印\n  -g 用于GDB调试\n  ltrace 命令用来跟踪程序运行时调用的库函数\n -S 查看系统调用 -e trace=write 只看write系统调用  strace 查看系统调用的封装函数\nGDB\r#\r\rSegment Fault快速定位\n首先生成core文件 使用ulimit -a 查看core file size为0则是不会输出(改成不限制 ulimit -c unlimited) 运行程序出错则会输出，调试时gdb ./hello core  list start ctrl + x + a  "},{"id":83,"href":"/docs/cs/tools/git/","title":"Git","section":"Tools","content":"Resources\r#\r\r \rLearning Git Branching \rGit Cheat Sheet: Commands and Best Practices  // 删除本地分支 git branch -d localBranchName\n// 删除远程分支 git push origin \u0026ndash;delete remoteBranchName\n修改github 日期\ngit commit\rgit cat-file -p HEAD \u0026gt; tmp.txt\r# at this point, edit the file to replace the timestamp\rgit hash-object -t commit -w tmp.txt\r#=\u0026gt; 2ee8fcc02658e23219143f5bcfe6f9a4615745f9\rgit update-ref -m 'commit: foo' refs/heads/master \\\r2ee8fcc02658e23219143f5bcfe6f9a4615745f9\r取消跟踪,删除远程文件\ngit rm -r --cached .\rgit add .\rgit commit -m \u0026quot;update gitignore\u0026quot;\r配置全局信息\n \u0026ndash;local\n git config \u0026ndash;global user.name \u0026ldquo;myname\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;test@gmail.com\u0026rdquo;\n"},{"id":84,"href":"/docs/cs/tools/jenkins/","title":"Jenkins","section":"Tools","content":"https://linuxize.com/post/how-to-install-jenkins-on-ubuntu-20-04/\nhttps://www.cnblogs.com/chenxiaomeng/p/11412038.html\nhttps://www.cnblogs.com/ding2016/p/12988080.html\nservice jenkins restart[start\\stop]\nsystemctl status jenkins\n"},{"id":85,"href":"/docs/cs/tools/linux/","title":"Linux","section":"Tools","content":"Resources\r#\r\r \rAwesome cheatsheets \r跟我一起写Makefile \rmodern-cmake-by-example \rThe Linux Command Handbook \rDev on Windows with WSL \rLinux 内核揭秘 \rLinux 命令行与 Shell 脚本教程(WIP) - ShellTutorial - Arch Linux Studio \rMaster the command line, in one page \rshell编程的若干实用技巧 \rShell How \r鸟哥的Linux私房菜：基础学习篇 第四版  Tools\r#\r\r \rcommand-not-found.com \rA collection of modern/faster/saner alternatives to common unix commands.  "},{"id":86,"href":"/docs/cs/tools/maven/","title":"Maven","section":"Tools","content":"mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.12 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.12.jar\n"},{"id":87,"href":"/docs/cs/tools/npm/","title":"Npm","section":"Tools","content":"\rnpkill\n"},{"id":88,"href":"/docs/cs/tools/regularexpression/","title":"Regular Expression","section":"Tools","content":"Resources\r#\r\r \rRegexLearn \rRegex One  "},{"id":89,"href":"/docs/cs/tools/vim/","title":"Vim","section":"Tools","content":"https://missing-semester-cn.github.io/2020/editors/\nhttps://vimawesome.com/\nResources\r#\r\r \rVim Cheat Sheet  "},{"id":90,"href":"/docs/cs/tools/vscode/","title":"Vscode","section":"Tools","content":"WSL相关\r#\r\rvscode server for wsl closed unexpectedly\nnetsh winsock reset重置网络 或移除wsl中的~/.vscode-server\n"},{"id":91,"href":"/docs/cs/tools/wsl/","title":"Wsl","section":"Tools","content":" \rWSL2 配置Xlaunch图形化界面  "},{"id":92,"href":"/docs/cs/tools/wsl/xlaunch/","title":"Xlaunch","section":"Wsl","content":"Windows安装VcXsrc\r#\r\r \r下载\n 选择显示模式 默认选择，最后勾选 允许防火墙 WSL配置与启动xfce4\r#\r\rsudo apt install -y xfce4 # 首先需要查看Windows系统和WSL2通信使用的虚拟网卡地址 $ cat vim /etc/resolv.conf sudo rm /etc/resolv.conf sudo bash -c \u0026#39;echo \u0026#34;nameserver windows ip\u0026#34; \u0026gt; /etc/resolv.conf\u0026#39; sudo bash -c \u0026#39;echo \u0026#34;[network]\u0026#34; \u0026gt; /etc/wsl.conf\u0026#39; sudo bash -c \u0026#39;echo \u0026#34;generateResolvConf = false\u0026#34; \u0026gt;\u0026gt; /etc/wsl.conf\u0026#39; $ vim ~/.bashrc # 在文件最后追加下面内容,地址使用上面查看到的 export DISPLAY=192.168.112.1:0 # 启动 sudo startxfce4 # 上面有坑，文件会被覆盖 # https://blog.csdn.net/IToBeNo_1/article/details/116333419 需要在cmd里wsl --shutdown 我目前是连的手机热点所以会变IP，不需要配置固定的windows IP "},{"id":93,"href":"/docs/english/","title":"English","section":"Docs","content":"网站\r#\r\r https://www.eapfoundation.com/ https://lyricstraining.com/ 听歌 http://skesl.com/ https://www.speechace.com/ 口语 https://www.vocabulary.com/play/ 单词 \rThe New York Times 新闻 \rScienceDaily 新闻 https://english-e-reader.net/ 免费分级书籍 \rYouGlish 口语 \rOGDEN\u0026rsquo;s BASIC ENGLISH \rLongman Dictionary \r聚合工具 https://www.languagereactor.com/ 视频 \rHow to learn English \rLearn English 🇬🇧🇺🇸  "},{"id":94,"href":"/docs/leetcode/","title":"Leet Code","section":"Docs","content":" \rCodeTop \r宫水三叶的刷题日记 \rThis repository contains the solutions and explanations to the algorithm problems on LeetCode.   目前分类目录\r#\r\r剑指 Offer\r#\r\r面试题 \r#\r\r国区周寨\r#\r\r  第273场\n \r5963. 反转两次的数字(E) \r5964. 执行所有后缀指令(M) \r5965. 相同元素的间隔之和(M)    第274场\n \r5967. 检查是否所有 A 都在 B 之前(E) \r5968. 银行中的激光束数量(M) \r5969. 摧毁小行星(M)    Dynamic Programming\r#\r\r \r10. 正则表达式匹配(H) \r44. 通配符匹配(H) \r45. 跳跃游戏 II(M) \r55. 跳跃游戏(M) \r62. 不同路径(M) \r63. 不同路径 II(M) \r64. 最小路径和(M) \r70. 爬楼梯(E) \r72. 编辑距离(H) \r91. Decode Ways(M) \r118. Pascal\u0026rsquo;s Triangle(E) \r119. Pascal\u0026rsquo;s Triangle II(E) \r120. Triangle(M) \r122. 买卖股票的最佳时机 II(M) \r123. 买卖股票的最佳时机 III(H) \r198. 打家劫舍(M) \r213. 打家劫舍 II(M) \r264. Ugly Number II(E) \r309. 最佳买卖股票时机含冷冻期(M) \r509. Fibonacci Number(M) \r714. Best Time to Buy and Sell Stock with Transaction Fee(M)  Tree\r#\r\r \r559. Maximum Depth of N-ary Tree(E) \r700. Search in a Binary Search Tree(E) \r102. 二叉树的层序遍历(M)  Heap\r#\r\r \r1046. 最后一块石头的重量(E) \r347. 前 K 个高频元素(M) \r451. 根据字符出现频率排序(M)  Math\r#\r\r \r43. 字符串相乘(M) \r66. 加一(E) \r67. 二进制求和(E) \r384. Shuffle an Array(E) \r519. Random Flip Matrix(M) \r1979. Find Greatest Common Divisor of Array(E) \r812. Largest Triangle Area(E)   Combinatorics  \r39. 组合总和(M) \r39. 组合总和 II(M) \r46. 全排列(M) \r47. 全排列 II(M) \r60. 排列序列(H)    Search\r#\r\r DFS   \r17. 电话号码的字母组合(M) \r37. 解数独(H) \r51. N 皇后(H) \r52. N 皇后 II(H) \r77. 组合(M) \r78. 子集(M) \r90. 子集 II(M) \r139. Word Break(M) \r216. 组合总和 III(M)   BFS   \r79. 单词搜索(M)  Recursion\r#\r\r \r1492. The kth Factor of n(M)  Sorts\r#\r\r Quick Select  \r215. Kth Largest Element in an Array   Index Sort  \r41. 缺失的第一个正数(H)    LinkedList\r#\r\r \r2. 两数相加(M) \r19. 删除链表的倒数第 N 个结点(M) \r21. 合并两个有序链表(E) \r23. 合并K个升序链表(H) \r24. 两两交换链表中的节点(M) \r25. K 个一组翻转链表(H) \r61. 旋转链表(H) \r83. 删除排序链表中的重复元素(E)  Stack\r#\r\r \r20. 有效的括号(E) \r32. 最长有效括号(H)   Monotonic Stack   \r42. 接雨水(H)  Hash Table\r#\r\r \r49. 字母异位词分组(M)  Two Pointers\r#\r\r \r11. 盛最多水的容器(M) \r15. 三数之和(M) \r16. 最接近的三数之和(M) \r18. 四数之和(M) \r26. 删除有序数组中的重复项(E) \r27. 移除元素(E) \r75. 颜色分类(M) \r80. 删除有序数组中的重复项 II(M) \r88. 合并两个有序数组(E)    Sliding window\n \r3. 无重复字符的最长子串(M) \r4. 寻找两个正序数组的中位数(H) \r30. 串联所有单词的子串(H) \r76. 最小覆盖子串(H)    Binary Search\n \r33. 搜索旋转排序数组(M) \r34. 在排序数组中查找元素的第一个和最后一个位置(M) \r35. 搜索插入位置(E) \r69. x 的平方根 (E) \r74. 搜索二维矩阵(M)    String\r#\r\r \r6. Z 字形变换(M) \r8. 字符串转换整数 (atoi)(M) \r14. 最长公共前缀(E) \r58. 最后一个单词的长度(E) \r65. 有效数字(H) \r68. 文本左右对齐(H)   Manacher  \r5. 最长回文子串(M)   KMP  \r28. 实现 strStr()(E)    Others\r#\r\r \r1. 两数之和(E) \r7. 整数反转(M) \r9. 回文数(E) \r22. 括号生成(E) \r29. 两数相除(M) \r31. 下一个排列(M) \r36. 有效的数独(M) \r48. 旋转图像(M) \r50. Pow(x, n)(M) \r56. 合并区间(M) \r57. 插入区间(M) \r1005. Maximize Sum Of Array After K Negations(E) \r383. Ransom Note(E) \r748. Shortest Completing Word(E)  Simulation\r#\r\r \r12. 整数转罗马数字(M) \r13. 罗马数字转整数(E) \r38. 外观数列(M) \r54. 螺旋矩阵(M) \r59. 螺旋矩阵 II(M) \r73. 矩阵置零(M)  Design\r#\r\r \r355. 设计推特(M) \r146. LRU 缓存(M)  "},{"id":95,"href":"/docs/leetcode/design/146/","title":"146th","section":"Leet Code","content":" \rLink\n 使用java的双向链表LinkedList有坑啊，过不了。\nclass LRUCache { private int capacity; private DoubleList list; private Map\u0026lt;Integer, Node\u0026gt; map; public LRUCache(int capacity) { this.capacity = capacity; this.list = new DoubleList(); this.map = new HashMap\u0026lt;\u0026gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } put(node.key, node.val); return node.val; } public void put(int key, int value) { Node node = map.get(key); if (node != null) { node = map.get(key); node.val = value; list.remove(node); } else { node = new Node(value, key); if (map.size() == capacity) { // full  Node last = list.removeLast(); map.remove(last.key); } } list.addFirst(node); map.put(key, node); } } class DoubleList { Node head, tail; public DoubleList() { this.head = null; this.tail = null; } public void addFirst(Node node) { if (head == null) { this.head = node; this.tail = node; } else { node.prev = null; node.next = head; head.prev = node; head = node; } } public void remove(Node node) { if (node == head) { this.head = node.next; if (this.head != null) { this.head.prev = null; } } else if (node == tail) { this.tail = node.prev; if (this.tail != null) { this.tail.next = null; } } else { Node prev = node.prev; prev.next = node.next; prev.next.prev = prev; } } public Node removeLast() { Node res = this.tail; if (this.head == this.tail) { res = this.head; this.head = this.tail = null; } else { Node node = this.tail.prev; node.next = null; this.tail = node; } return res; } } class Node { int val; int key; Node prev; Node next; public Node(int val, int key) { this.val = val; this.key = key; } } "},{"id":96,"href":"/docs/leetcode/design/355/","title":"355th","section":"Leet Code","content":" \rLink\n class Twitter { private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; follows; private Map\u0026lt;Integer, PriorityQueue\u0026lt;Integer\u0026gt;\u0026gt; tweets; private static final AtomicInteger ai = new AtomicInteger(0); private static final Map\u0026lt;Integer, Integer\u0026gt; orders = new HashMap\u0026lt;\u0026gt;(); public Twitter() { follows = new HashMap\u0026lt;\u0026gt;(); tweets = new HashMap\u0026lt;\u0026gt;(); } public void postTweet(int userId, int tweetId) { PriorityQueue\u0026lt;Integer\u0026gt; tmp = tweets.get(userId); if (tmp == null) { tmp = new PriorityQueue\u0026lt;Integer\u0026gt;((a, b) -\u0026gt; b - a); tweets.put(userId, tmp); } int key = ai.incrementAndGet(); orders.put(key, tweetId); tmp.offer(key); } public List\u0026lt;Integer\u0026gt; getNewsFeed(int userId) { List\u0026lt;Integer\u0026gt; followees = follows.get(userId); PriorityQueue\u0026lt;Integer\u0026gt; tmp = new PriorityQueue\u0026lt;\u0026gt;(); if (followees != null) { for (int followeeId : followees) { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(followeeId); if (t != null) { updateTop10Data(t, tmp); } } } else { PriorityQueue\u0026lt;Integer\u0026gt; t = tweets.get(userId); if (t != null) { updateTop10Data(t, tmp); } } List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); while (tmp.size() \u0026gt; 0) { res.add(0, orders.get(tmp.poll())); } return res; } private void updateTop10Data(PriorityQueue\u0026lt;Integer\u0026gt; data, PriorityQueue\u0026lt;Integer\u0026gt; res) { for (int d : data) { if (res.size() \u0026gt;= 10) { if (res.peek() \u0026lt; d) { res.poll(); res.offer(d); } } else { res.offer(d); } } } public void follow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); tmp.add(followerId); follows.put(followerId, tmp); } if (tmp.contains(followeeId)) { return; } tmp.add(followeeId); } public void unfollow(int followerId, int followeeId) { List\u0026lt;Integer\u0026gt; tmp = follows.get(followerId); if (tmp == null) { return; } tmp.remove(new Integer(followeeId)); } } "},{"id":97,"href":"/docs/leetcode/dynamicprogramming/10/","title":"10th","section":"Leet Code","content":" \rLink\n public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // 表示 dp[i][j] = s[1..i] 和 p[1...j]是否相等  boolean[][] dp = new boolean[m + 1][n + 1]; s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; dp[0][0] = true; for (int i = 0; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (j + 1 \u0026lt;= n \u0026amp;\u0026amp; p.charAt(j + 1) == \u0026#39;*\u0026#39;) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; p.charAt(j) != \u0026#39;*\u0026#39;) { dp[i][j] = dp[i - 1][j - 1] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == \u0026#39;.\u0026#39;); } else if (p.charAt(j) == \u0026#39;*\u0026#39;) { /** dp[i][j] = dp[i][j-2] || (dp[i-1][j-2] \u0026amp;\u0026amp; s[i]==p[j-1]) || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1]==p[j-1] \u0026amp;\u0026amp; s[i]==p[j-1]) dp[i-1][j] = dp[i-1][j-2] || (dp[i-2][j-2] \u0026amp;\u0026amp; s[i-1] == p[j-1]) dp[i][j] = dp[i][j-2] || (dp[i-1][j] \u0026amp;\u0026amp; s[i]==p[j-1]) */ dp[i][j] = dp[i][j - 2] || (i \u0026gt; 0 \u0026amp;\u0026amp; dp[i - 1][j] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j - 1) || p.charAt(j - 1) == \u0026#39;.\u0026#39;)); } } } return dp[m][n]; } "},{"id":98,"href":"/docs/leetcode/dynamicprogramming/118/","title":"118th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int[][] dp = new int[numRows + 1][numRows + 1]; dp[1][1] = 1; for (int i = 2; i \u0026lt;= numRows; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= numRows; i++) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); for (int j = 1; j \u0026lt;= i; j++) { tmp.add(dp[i][j]); } ans.add(tmp); } return ans; } } "},{"id":99,"href":"/docs/leetcode/dynamicprogramming/119/","title":"119th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;Integer\u0026gt; getRow(int rowIndex) { rowIndex += 1; int[][] dp = new int[rowIndex + 1][rowIndex + 1]; dp[1][1] = 1; for (int row = 2; row \u0026lt;= rowIndex; row++) { for (int col = 1; col \u0026lt;= row; col++) { dp[row][col] = dp[row - 1][col - 1] + dp[row - 1][col]; } } List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (int col = 1; col \u0026lt;= rowIndex; col++) { ans.add(dp[rowIndex][col]); } return ans; } } 进阶优化空间：O(rowIndex)\nclass Solution { public: vector\u0026lt;int\u0026gt; getRow(int rowIndex) { vector\u0026lt;int\u0026gt; ans(rowIndex + 1, 1); for (int i = 0; i \u0026lt;= rowIndex; i++) { for (int j = i - 1; j \u0026gt;= 1; j--) { ans[j] = ans[j] + ans[j - 1]; } } return ans; } }; "},{"id":100,"href":"/docs/leetcode/dynamicprogramming/120/","title":"120th","section":"Leet Code","content":" \rLink\n DP 要从下往上找，否则不一定是全局最优\n2 3 4 6 5 1 4 1 8 3\nclass Solution { public int minimumTotal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle) { int n = triangle.size(); int[][] dp = new int[n][n]; int res = 0; for (int j = 0; j \u0026lt;= n - 1; j++) { dp[n - 1][j] = triangle.get(n - 1).get(j); } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt;= i; j++) { dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); } } return dp[0][0]; } } "},{"id":101,"href":"/docs/leetcode/dynamicprogramming/122/","title":"122nd","section":"Leet Code","content":" \rLink\n 可以把数据看成折线图，则所有上升之和为解\npublic int maxProfit(int[] prices) { int res = 0; for (int i = 0; i \u0026lt; prices.length - 1; i++) { if (prices[i + 1] \u0026gt; prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } DP\npublic int maxProfit(int[] prices) { int n = prices.length; // 第i天买入的最大利润  int[] dp1 = new int[n]; // 第i天卖掉的最大利润  int[] dp2 = new int[n]; dp1[0] = -prices[0]; dp2[0] = 0; for (int i = 1; i \u0026lt; n; i++) { // 可以不买或卖  dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] + prices[i]); } return dp2[n - 1]; } "},{"id":102,"href":"/docs/leetcode/dynamicprogramming/123/","title":"123rd","section":"Leet Code","content":" \rLink\n public int maxProfit(int[] prices) { int n = prices.length; // dp[0][0]: 持有第一股的最大利益  // dp[0][1]: 售出第一股的最大利益  // dp[0][2]: 持有第二股的最大利益  // dp[0][3]: 售出第二股的最大利益  int[][] dp = new int[n + 1][4]; dp[0][0] = Integer.MIN_VALUE; dp[0][2] = Integer.MIN_VALUE; for (int i = 1; i \u0026lt;= n; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i - 1]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i - 1]); } return Math.max(dp[n][1], dp[n][3]); } "},{"id":103,"href":"/docs/leetcode/dynamicprogramming/198/","title":"198th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { int n = nums.length; // dp[0][0]: 第一个房间抢  // dp[0][1]: 第一个房间不抢  int[][] dp = new int[n][2]; dp[0][0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[n - 1][0], dp[n - 1][1]); } } "},{"id":104,"href":"/docs/leetcode/dynamicprogramming/213/","title":"213th","section":"Leet Code","content":" \rLink\n class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } return Math.max(help(nums, 1, nums.length), help(nums, 0, nums.length - 1)); } // [i,j)  private int help(int[] nums, int i, int j) { // 0 : 抢  // 1 : 不抢  int[][] dp = new int[nums.length][2]; dp[i][0] = nums[i]; while (++i \u0026lt; j) { dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0]); } return Math.max(dp[j - 1][0], dp[j - 1][1]); } } "},{"id":105,"href":"/docs/leetcode/dynamicprogramming/264/","title":"264th","section":"Leet Code","content":" \rLink\n 使用优先队列，从集合[1]开始，每次选取集合内最小的元素x 生成[2x, 3x, 5x]\n[1] -\u0026gt; [2 3 5] -\u0026gt; [3 4 5 6 10] -\u0026gt; \u0026hellip;\nclass Solution { // Time Complexity: O(3N * lg3N)  // 每次产生 最小数的2、3、5倍数  public int nthUglyNumber(int n) { PriorityQueue\u0026lt;Long\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); q.add(1L); long top = -1L; for (int i = 0; i \u0026lt; n; i++) { top = q.peek(); while (!q.isEmpty() \u0026amp;\u0026amp; q.peek() == top) { q.poll(); } q.add(top * 2); q.add(top * 3); q.add(top * 5); } return (int)top; } } dp思想，对于任何丑数，它只能由某一个丑数x x2、x3、x*5里得到。\n定义三个指针i、j、k来定跟踪丑数的大小。\nnums X X X X X X idx2 ^\ridx3 ^\ridx5 ^\rclass Solution { // Time Complexity: O(n);  public int nthUglyNumber(int n) { int i = 0, j = 0, k = 0; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); res.add(1); for (int v = 0; v \u0026lt; n; v++) { int cur = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5)); res.add(cur); if (cur == res.get(i) * 2) i++; if (cur == res.get(j) * 3) j++; if (cur == res.get(k) * 5) k++; } return res.get(n - 1); } } "},{"id":106,"href":"/docs/leetcode/dynamicprogramming/309/","title":"309th","section":"Leet Code","content":" \rLink\n DP\npublic int maxProfit(int[] prices) { int n = prices.length; // i天卖出的最大利润  int[] dp1 = new int[n + 1]; // i天买入的最大利润  int[] dp2 = new int[n + 1]; dp1[1] = 0; dp2[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { // 第i天卖出的最大利润 = max(前天买入今天卖出, 前天卖出)  dp1[i] = Math.max(dp2[i - 1] + prices[i - 1], dp1[i - 1]); // 第i天买入的最大利润 = max(前天买入, 前两天卖出今天买入)  dp2[i] = Math.max(dp2[i - 1], dp1[i - 2] - prices[i - 1]); } return dp1[n]; } "},{"id":107,"href":"/docs/leetcode/dynamicprogramming/44/","title":"44th","section":"Leet Code","content":" \rLink\n f[i][j]：表示s[0..i]和p[0..j]是否匹配\npublic boolean isMatch(String s, String p) { int m = s.length(), n = p.length(); s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (p.charAt(j) == \u0026#39;*\u0026#39;) { f[i][j] = (i \u0026gt; 0 \u0026amp;\u0026amp; f[i - 1][j]) || f[i][j - 1]; } else { f[i][j] = i \u0026gt; 0 \u0026amp;\u0026amp; f[i - 1][j - 1] \u0026amp;\u0026amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == \u0026#39;?\u0026#39;); } } } return f[m][n]; } "},{"id":108,"href":"/docs/leetcode/dynamicprogramming/45/","title":"45th","section":"Leet Code","content":" \rLink\n public int jump(int[] nums) { int n = nums.length; // f[i]: 最少的跳跃次数到达i  int[] f = new int[n]; for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j + nums[j] \u0026lt; i) j++; f[i] = f[j] + 1; } return f[n - 1]; } "},{"id":109,"href":"/docs/leetcode/dynamicprogramming/509/","title":"509th","section":"Leet Code","content":" \rLink\n public int fib(int n) { int p2 = 0, p1 = 1; for (int i = 1; i \u0026lt;= n; i++) { int tmp = p1; p1 = p1 + p2; p2 = tmp; } return p2; } "},{"id":110,"href":"/docs/leetcode/dynamicprogramming/55/","title":"55th","section":"Leet Code","content":" \rLink\n class Solution { public boolean canJump(int[] nums) { for (int i = 0, j = 0; i \u0026lt; nums.length; i++) { if (j \u0026lt; i) return false; j = Math.max(j, i + nums[i]); } return true; } } "},{"id":111,"href":"/docs/leetcode/dynamicprogramming/62/","title":"62nd","section":"Leet Code","content":" \rLink\n DP\ndp[i][j] 表示能到i行j列不同路径个数\n初始化第一行和和第一列为1\npublic int uniquePaths(int m, int n) { int[][] f = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i == 0 || j == 0) { f[i][j] = 1; } else { f[i][j] = f[i - 1][j] + f[i][j - 1]; } } } return f[m - 1][n - 1]; } DFS+记忆化\nclass Solution { public int uniquePaths(int m, int n) { int[][] memo = new int[m][n]; return dfs(0, 0, m, n, memo); } private int dfs(int i, int j, int m, int n, int[][] memo) { if (i \u0026gt;= m || j \u0026gt;= n || i \u0026lt; 0 || j \u0026lt; 0) { return 0; } if (memo[i][j] != 0) { return memo[i][j]; } if (i == m - 1 \u0026amp;\u0026amp; j == n - 1) { return 1; } int res = dfs(i + 1, j, m, n, memo) + dfs(i, j + 1, m, n, memo); memo[i][j] = res; return res; } } "},{"id":112,"href":"/docs/leetcode/dynamicprogramming/63/","title":"63rd","section":"Leet Code","content":" \rLink\n 同\r62题题思路一样\n直接看DP解法，注意初始化，有障碍物时，就不能往后走了\nclass Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0; i++) { dp[i][0] = 1; } for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0; j++) { dp[0][j] = 1; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } public int uniquePathsWithObstacles(int[][] o) { int m = o.length; if (m == 0) return 0; int n = o[0].length; int[][] f = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (o[i][j] == 0) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[i][j] = 1; } else { if (i \u0026gt; 0) f[i][j] += f[i - 1][j]; if (j \u0026gt; 0) f[i][j] += f[i][j - 1]; } } } } return f[m - 1][n - 1]; } "},{"id":113,"href":"/docs/leetcode/dynamicprogramming/64/","title":"64th","section":"Leet Code","content":" \rLink\n dp[i][j] 表示到i行j列最小总和 注意初始化\nclass Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int k = i; k \u0026gt;= 0; k--) { dp[i][0] += grid[k][0]; } } for (int j = 1; j \u0026lt; n; j++) { for (int k = j; k \u0026gt;= 0; k--) { dp[0][j] += grid[0][k]; } } int res = 0; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; } } public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) Arrays.fill(dp[i], Integer.MAX_VALUE); for (int i = 0; i \u0026lt; m; i++) for (int j = 0; j \u0026lt; n; j++) { if (i == 0 \u0026amp;\u0026amp; j == 0) { dp[i][j] = grid[i][j]; } else { if (i \u0026gt; 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + grid[i][j]); if (j \u0026gt; 0) dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + grid[i][j]); } } return dp[m - 1][n - 1]; } "},{"id":114,"href":"/docs/leetcode/dynamicprogramming/70/","title":"70th","section":"Leet Code","content":" \rLink\n public int climbStairs(int n) { int p1 = 1, p2 = 1; while (--n \u0026gt; 0) { int t = p1 + p2; p2 = p1; p1 = t; } return p1; } "},{"id":115,"href":"/docs/leetcode/dynamicprogramming/714/","title":"714th","section":"Leet Code","content":" \rLink\n 第i天买入的最大利润buy[i]\n卖出的最大利润sell[i]\n卖出的时候(完成了一笔交易)减去手续费\nclass Solution { public int maxProfit(int[] prices, int fee) { int n = prices.length; int[] buy = new int[n + 1]; int[] sell = new int[n + 1]; buy[1] = -prices[0]; for (int i = 2; i \u0026lt;= n; i++) { buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i - 1] - fee); } return sell[n]; } } "},{"id":116,"href":"/docs/leetcode/dynamicprogramming/72/","title":"72nd","section":"Leet Code","content":" \rLink\n f[i][j]: 表示word1[0..i]和word2[0..j]最小操作数\n考虑6种情况, 修改w1、插入w1、删除w1，最后合并修改和插入操作\npublic int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); word1 = \u0026#34; \u0026#34; + word1; word2 = \u0026#34; \u0026#34; + word2; int[][] f = new int[m + 1][n + 1]; for (int i = 0; i \u0026lt;= m; i++) f[i][0] = i; for (int i = 0; i \u0026lt;= n; i++) f[0][i] = i; for (int i = 1; i \u0026lt;= m; i++) for (int j = 1; j \u0026lt;= n; j++) { f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + 1; int t = word1.charAt(i) == word2.charAt(j) ? 0 : 1; f[i][j] = Math.min(f[i][j], f[i - 1][j - 1] + t); } return f[m][n]; } "},{"id":117,"href":"/docs/leetcode/dynamicprogramming/91/","title":"91st","section":"Leet Code","content":" \rLink\n DFS搜索 + 记忆化 class Solution { private Map\u0026lt;String, Integer\u0026gt; memo = new HashMap\u0026lt;\u0026gt;(); public int numDecodings(String s) { if (s == null ||ｓ.length() == 0) return 0; return dfs(s, 0); } private int dfs(String s, int i) { int n = s.length(); if (i \u0026gt;= n) return 1; if (memo.containsKey(s.substring(i))) return memo.get(s.substring(i)); if (!isValid(s.charAt(i))) return 0; int res = dfs(s, i + 1); if (i \u0026lt; n - 1 \u0026amp;\u0026amp; isValid(s.substring(i, i + 2))) { res += dfs(s, i + 2); } memo.put(s.substring(i), res); return res; } private boolean isValid(String s) { int val = Integer.valueOf(s); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } private boolean isValid(char c) { int t = c - \u0026#39;0\u0026#39;; return 1 \u0026lt;= t \u0026amp;\u0026amp; t \u0026lt;= 26; } } DP\n\rclass Solution { public int numDecodings(String s) { s = \u0026#34;#\u0026#34; + s; int n = s.length(); // dp[i] = s[0]..s[i]解码方式  int[] dp = new int[n]; dp[0] = 1; dp[1] = (s.charAt(1) == \u0026#39;0\u0026#39;) ? 0 : 1; for (int i = 2; i \u0026lt; n; i++) { if (!isValid(s.charAt(i)) \u0026amp;\u0026amp; !isValid(s.charAt(i - 1), s.charAt(i))) { return 0; } if (isValid(s.charAt(i))) { dp[i] = dp[i - 1]; } if (isValid(s.charAt(i - 1), s.charAt(i))) { dp[i] += dp[i - 2]; } } return dp[n - 1]; } private boolean isValid(char c) { return \u0026#39;1\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } private boolean isValid(char a, char b) { int val = (a - \u0026#39;0\u0026#39;) * 10 + (b - \u0026#39;0\u0026#39;); return 10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 26; } } "},{"id":118,"href":"/docs/leetcode/hashtable/49/","title":"49th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String str : strs) { String oldStr = str; char[] chs = str.toCharArray(); Arrays.sort(chs); str = new String(chs); List\u0026lt;String\u0026gt; tmp = map.getOrDefault(str, null); if (tmp == null) { tmp = new ArrayList\u0026lt;\u0026gt;(); map.put(str, tmp); } tmp.add(oldStr); } List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (var e : map.entrySet()) { res.add(e.getValue()); } return res; } "},{"id":119,"href":"/docs/leetcode/heap/1046/","title":"1046th","section":"Leet Code","content":" \rLink\n // Time Complexity: O(nlogn)  // Space Complexity: O(n)  public int lastStoneWeight(int[] stones) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; b - a); for (int stone : stones) { pq.offer(stone); } while (pq.size() \u0026gt; 1) { int y = pq.poll(); int x = pq.poll(); if (x == y) { continue; } else { pq.offer(y - x); } } return pq.size() == 0 ? 0 : pq.poll(); } "},{"id":120,"href":"/docs/leetcode/heap/347/","title":"347th","section":"Leet Code","content":" \rLink\n public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } int[] res = new int[k]; int idx = 0; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(a) - map.get(b)); for (var entry : map.entrySet()) { if (pq.size() \u0026lt; k) { pq.offer(entry.getKey()); } else if (entry.getValue() \u0026gt; map.get(pq.peek())) { pq.poll(); pq.offer(entry.getKey()); } } while (!pq.isEmpty()) { res[idx++] = pq.poll(); } return res; } "},{"id":121,"href":"/docs/leetcode/heap/451/","title":"451st","section":"Leet Code","content":" \rLink\n public String frequencySort(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } PriorityQueue\u0026lt;Character\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; map.get(b) - map.get(a)); for (char k : map.keySet()) { pq.offer(k); } StringBuilder sb = new StringBuilder(); while (!pq.isEmpty()) { char c = pq.poll(); int n = map.get(c); for (int i = 0; i \u0026lt; n; i++) { sb.append(c); } } return sb.toString(); } "},{"id":122,"href":"/docs/leetcode/linkedlist/19/","title":"19th","section":"Leet Code","content":" \rLink\n public ListNode removeNthFromEnd(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; int n = 0; while (head != null) { n++; head = head.next; } ListNode prev = dummy; for (int i = 0; i \u0026lt; (n - k); i++) { prev = prev.next; } prev.next = prev.next.next; return dummy.next; } "},{"id":123,"href":"/docs/leetcode/linkedlist/2/","title":"2nd","section":"Leet Code","content":" \rLink\n public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode curr = dummy; int t = 0; while (l1 != null || l2 != null || t != 0) { if (l1 != null) { t += l1.val; l1 = l1.next; } if (l2 != null) { t += l2.val; l2 = l2.next; } curr.next = new ListNode(t % 10); t /= 10; curr = curr.next; } return dummy.next; } "},{"id":124,"href":"/docs/leetcode/linkedlist/21/","title":"21st","section":"Leet Code","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode prev = dummy; while (l1 != null \u0026amp;\u0026amp; l2 != null) { if (l1.val \u0026lt; l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } if (l1 != null) { prev.next = l1; } if (l2 != null) { prev.next = l2; } return dummy.next; } "},{"id":125,"href":"/docs/leetcode/linkedlist/23/","title":"23rd","section":"Leet Code","content":" \rLink\n class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode dummy = new ListNode(); PriorityQueue\u0026lt;ListNode\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); for (var l : lists) { if (l != null) { // 示例3 特例  minHeap.offer(l); } } ListNode tail = dummy; while (!minHeap.isEmpty()) { ListNode cur = minHeap.poll(); tail.next = cur; tail = tail.next; cur = cur.next; if (cur != null) { minHeap.offer(cur); } } return dummy.next; } } "},{"id":126,"href":"/docs/leetcode/linkedlist/24/","title":"24th","section":"Leet Code","content":" \rLink\n public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy; p.next != null \u0026amp;\u0026amp; p.next.next != null;) { ListNode a = p.next; ListNode b = p.next.next; p.next = b; a.next = b.next; b.next = a; p = a; } return dummy.next; } "},{"id":127,"href":"/docs/leetcode/linkedlist/25/","title":"25th","section":"Leet Code","content":" \rLink\n public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(); dummy.next = head; for (ListNode p = dummy;;) { int n = 0; for (ListNode t = p.next; t != null; t = t.next) { n++; } if (n \u0026lt; k) { break; } // 翻转k个节点  ListNode a = p.next, b = p.next.next; for (int i = 0; i \u0026lt; k - 1; i++) { var c = b.next; b.next = a; a = b; b = c; } var c = p.next; p.next = a; c.next = b; p = c; } return dummy.next; } "},{"id":128,"href":"/docs/leetcode/linkedlist/61/","title":"61st","section":"Leet Code","content":" \rLink\n public ListNode rotateRight(ListNode head, int k) { if (head == null) return head; int n = 0; ListNode tail = head; for (var p = head; p != null; p = p.next) { n++; tail = p; } k = k % n; if (k == 0) return head; ListNode p = head; for (int i = 0; i \u0026lt; n - 1 - k; i++) { p = p.next; } tail.next = head; head = p.next; p.next = null; return head; } "},{"id":129,"href":"/docs/leetcode/linkedlist/83/","title":"83rd","section":"Leet Code","content":" \rLink\n public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.val == cur.next.val) { cur.next = cur.next.next; } else { cur = cur.next; } } return head; } public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; ListNode dummy = new ListNode(-1, head); ListNode p = dummy.next; for (ListNode cur = head.next; cur != null; cur = cur.next) { if (p.val != cur.val) { p.next = cur; p = p.next; } } p.next = null; return dummy.next; } "},{"id":130,"href":"/docs/leetcode/math/1979/","title":"1979th","section":"Leet Code","content":" \rLink\n public int findGCD(int[] nums) { Arrays.sort(nums); int x1 = nums[0]; int x2 = nums[nums.length - 1]; return gcd(x2, x1); } // a \u0026gt; b  private int gcd(int a, int b) { if (a % b == 0) return b; return gcd(b, a % b); } "},{"id":131,"href":"/docs/leetcode/math/384/","title":"384th","section":"Leet Code","content":" \rLink\n 常规洗牌算法，思路：对n个数随机选一个与第一个数交换，除去第一个数的n-1个数同样操作。\n第一轮：1/n\n第二轮：(n-1)/n * 1/(n-1)\n第三轮：(n-1)/n * (n-2)/(n-1) * 1/(n-2)\n…………\nprivate int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { int[] res = Arrays.copyOf(nums, nums.length); for (int i = 0; i \u0026lt; nums.length; i++) { swap(res, i, (int)(Math.random() * (nums.length - i)) + i); } return res; } private void swap(int[] num, int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; } "},{"id":132,"href":"/docs/leetcode/math/39/","title":"39th","section":"Leet Code","content":" \rLink\n List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList\u0026lt;\u0026gt;(), 0); return res; } private void dfs(int[] candidates, int target, List\u0026lt;Integer\u0026gt; cur, int s) { if (target \u0026lt; 0) { return; } if (target == 0) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = s; i \u0026lt; candidates.length; i++) { if (candidates[i] \u0026gt; target) break; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i); cur.remove(cur.size() - 1); } } "},{"id":133,"href":"/docs/leetcode/math/40/","title":"40th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); dfs(candidates, target, new ArrayList\u0026lt;\u0026gt;(), 0); return res; } private void dfs(int[] candidates, int target, List\u0026lt;Integer\u0026gt; cur, int s) { if (target == 0) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = s; i \u0026lt; candidates.length; i++) { if (candidates[i] \u0026gt; target) break; if (i \u0026gt; s \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) continue; cur.add(candidates[i]); dfs(candidates, target - candidates[i], cur, i + 1); cur.remove(cur.size() - 1); } } } "},{"id":134,"href":"/docs/leetcode/math/43/","title":"43rd","section":"Leet Code","content":" \rLink\n string multiply(string num1, string num2) { int n = num1.size(), m = num2.size(); vector\u0026lt;int\u0026gt; A, B; for (int i = n - 1; i \u0026gt;= 0; i--) A.push_back(num1[i] - \u0026#39;0\u0026#39;); for (int i = m - 1; i \u0026gt;= 0; i--) B.push_back(num2[i] - \u0026#39;0\u0026#39;); vector\u0026lt;int\u0026gt; C(n + m); for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) C[i + j] += A[i] * B[j]; for (int i = 0, t = 0; i \u0026lt; C.size(); i++) { t += C[i]; C[i] = t % 10; t /= 10; } int k = C.size() - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; C[k] == 0) k--; string res; while (k \u0026gt;= 0) res += (C[k--] + \u0026#39;0\u0026#39;); return res; } public String multiply(String num1, String num2) { int n = num1.length(), m = num2.length(); int[] A = new int[n]; int[] B = new int[m]; int idx = 0; for (int i = n - 1; i \u0026gt;= 0; i--) { A[idx++] = num1.charAt(i) - \u0026#39;0\u0026#39;; } idx = 0; for (int i = m - 1; i \u0026gt;= 0; i--) { B[idx++] = num2.charAt(i) - \u0026#39;0\u0026#39;; } int[] C = new int[n + m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { C[i + j] += A[i] * B[j]; } } for (int i = 0, t = 0; i \u0026lt; C.length; i++) { t += C[i]; C[i] = t % 10; t /= 10; } int k = C.length - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; C[k] == 0) k--; StringBuilder sb = new StringBuilder(); while (k \u0026gt;= 0) { sb.append(C[k--]); } return sb.toString(); } "},{"id":135,"href":"/docs/leetcode/math/46/","title":"46th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); boolean[] st; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { st = new boolean[nums.length]; dfs(new ArrayList\u0026lt;\u0026gt;(), nums); return res; } private void dfs(List\u0026lt;Integer\u0026gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (st[i]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } } "},{"id":136,"href":"/docs/leetcode/math/47/","title":"47th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); boolean[] st; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { Arrays.sort(nums); st = new boolean[nums.length]; dfs(new ArrayList\u0026lt;\u0026gt;(), nums); return res; } private void dfs(List\u0026lt;Integer\u0026gt; path, int[] nums) { if (path.size() == nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (st[i]) continue; if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !st[i - 1]) continue; st[i] = true; path.add(nums[i]); dfs(path, nums); path.remove(path.size() - 1); st[i] = false; } } } "},{"id":137,"href":"/docs/leetcode/math/519/","title":"519th","section":"Leet Code","content":" \rLink\n class Solution { private int m; private int n; private int count; private Map\u0026lt;Integer, Integer\u0026gt; map; /** 转成一维数组 索引i 相当于=\u0026gt; [i/n][i%n]，并用Map只记录被选中的信息（思路类似384，但是保存所有数会超出内存限制）: case1: case2: 1 2 3 4 {5} 6 1 2 3 {4} 5 =\u0026gt; 5 =\u0026gt; 4 map[5] = 6 map[4] = 5 1 2 3 4 {5} 1 2 {3} 4 =\u0026gt; 6 =\u0026gt; 3 map[5] = 4 map[3] = map[4] = 5 ... ... */ public Solution(int m, int n) { this.m = m; this.n = n; this.count = 0; this.map = new HashMap\u0026lt;\u0026gt;(); } public int[] flip() { int k = (int)(Math.random() * (m * n - count)); int res = 0; if (map.get(k) == null) { res = k; } else { res = map.get(k); } int lastIdx = m * n - count - 1; if (map.get(lastIdx) != null) { map.put(k, map.get(lastIdx)); } else { map.put(k, lastIdx); } count++; return new int[]{res / n, res % n}; } public void reset() { map.clear(); count = 0; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(m, n); * int[] param_1 = obj.flip(); * obj.reset(); */ "},{"id":138,"href":"/docs/leetcode/math/60/","title":"60th","section":"Leet Code","content":" \rLink\n 当n=4, k=9时，从1-4按顺序选取一个数，剩下的数组合情况有 (n - 1)!\n例: - 当选取1为第一位时，就有 3!=6种情况, k=9 \u0026gt; 6 显然第k位不是这种情况，此时减去这6种情况考虑下个数。\r- 当选取2为第一位时，就 3!=6种情况, k=3 《 6 显然是这种情况，继续判断剩下的数。\rclass Solution { public String getPermutation(int n, int k) { boolean[] st = new boolean[10]; StringBuilder res = new StringBuilder(); for (int i = 0; i \u0026lt; n; i++) { int fact = 1; for (int j = 1; j \u0026lt;= n - i - 1; j++) fact *= j; for (int j = 1; j \u0026lt;= n; j++) { if (!st[j]) { if (fact \u0026lt; k) k -= fact; else { res.append(j); st[j] = true; break; } } } } return res.toString(); } } "},{"id":139,"href":"/docs/leetcode/math/61/","title":"61st","section":"Leet Code","content":" \rLink\n public int[] plusOne(int[] digits) { int[] res = new int[digits.length + 1]; int idx = digits.length; for (int i = digits.length - 1, t = 1; i \u0026gt;= 0 || t \u0026gt; 0; i--) { if (i \u0026gt;= 0) t += digits[i]; res[idx--] = t % 10; t /= 10; } return Arrays.copyOfRange(res, idx + 1, res.length); } "},{"id":140,"href":"/docs/leetcode/math/67/","title":"67th","section":"Leet Code","content":" \rLink\n public String addBinary(String a, String b) { StringBuilder sa = new StringBuilder(a); sa.reverse(); StringBuilder sb = new StringBuilder(b); sb.reverse(); StringBuilder res = new StringBuilder(); for (int i = 0, t = 0; i \u0026lt; a.length() || i \u0026lt; b.length() || t != 0; i++) { if (i \u0026lt; sa.length()) t += (sa.charAt(i) - \u0026#39;0\u0026#39;); if (i \u0026lt; sb.length()) t += (sb.charAt(i) - \u0026#39;0\u0026#39;); res.append(t % 2); t /= 2; } return res.reverse().toString(); } "},{"id":141,"href":"/docs/leetcode/math/812/","title":"812th","section":"Leet Code","content":" \rLink\n 看评论区都用线性代数，没学过线性代数的我，泪目了哭！\npublic double largestTriangleArea(int[][] points) { double res = 0; for (int i = 0; i \u0026lt; points.length; i++) { for (int j = i + 1; j \u0026lt; points.length; j++) { for (int k = j + 1; k \u0026lt; points.length; k++) { if (isValid(points[i], points[j], points[k])) { double tmp = getArea(points[i], points[j], points[k]); if (tmp \u0026gt; res) { res = tmp; } } } } } return res; } private boolean isValid(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); return (a + b \u0026gt; c) || (a + c \u0026gt; b) || (b + c) \u0026gt; a; } // 果断找个公式，海伦公式  private double getArea(int[] p1, int[] p2, int[] p3) { double a = length(p1, p2); double b = length(p1, p3); double c = length(p2, p3); double p = (a + b + c) / 2; return Math.sqrt(p * (p - a) * (p - b) * (p - c)); } private double length(int[] p1, int[] p2) { return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)); } "},{"id":142,"href":"/docs/leetcode/others/1/","title":"1st","section":"Leet Code","content":" \rLink\n public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int another = target - nums[i]; if (map.containsKey(another)) { return new int[]{i, map.get(another)}; } map.put(nums[i], i); } return null; } "},{"id":143,"href":"/docs/leetcode/others/1005/","title":"1005th","section":"Leet Code","content":" \rLink\n 写的实在是太丑陋了, 太多边界条件不易写\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // 最小\u0026gt;0的数索引  for (int n : nums) { if (n \u0026lt; 0) i++; else break; } int j = i - 1; // 最大负数索引  int negCount = i; int idx = negCount - i; while (k \u0026gt; 0) { if (negCount \u0026gt; 0) { nums[idx] = -nums[idx]; idx++; negCount--; } else { if (i \u0026lt; nums.length \u0026amp;\u0026amp; nums[i] == 0) break; if ( i \u0026gt;= nums.length || (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt; nums[j])) { nums[j] = -nums[j]; } else { nums[i] = -nums[i]; } } k--; } int sum = 0; for (int n : nums) { sum += n; } return sum; } } 优先队列解法(最小堆)\nclass Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int n : nums) { q.add(n); } while (k \u0026gt; 0) { q.add(0 - q.poll()); k--; } int sum = 0; while (!q.isEmpty()) { sum += q.poll(); } return sum; } } "},{"id":144,"href":"/docs/leetcode/others/22/","title":"22nd","section":"Leet Code","content":" \rLink\n class Solution { private List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; generateParenthesis(int n) { dfs(n, 0, 0, \u0026#34;\u0026#34;); return res; } private void dfs(int n, int open, int closed, String s) { if (open == n \u0026amp;\u0026amp; closed == n) { res.add(s); return; } if (open \u0026lt; n) { dfs(n, open + 1, closed, s + \u0026#34;(\u0026#34;); } if (closed \u0026lt; n \u0026amp;\u0026amp; closed \u0026lt; open) { dfs(n, open, closed + 1, s + \u0026#34;)\u0026#34;); } } } "},{"id":145,"href":"/docs/leetcode/others/29/","title":"29th","section":"Leet Code","content":" \rLink\n X / Y = K \u0026ndash;\u0026gt; X = YK \u0026ndash;\u0026gt; K假设K=(1110)2 则 X = Y * 2^3 + Y * 2^2 + Y * 2^1 即logK个数相加\nclass Solution { public int divide(int dividend, int divisor) { int flag = 1; if (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) { flag = -1; } long a = Math.abs((long)dividend), b = Math.abs((long)divisor); List\u0026lt;Long\u0026gt; exp = new ArrayList\u0026lt;\u0026gt;(); for (long i = b; i \u0026lt;= a; i += i) { exp.add(i); } long res = 0; for (int i = exp.size() - 1; i \u0026gt;= 0; i--) { if (a \u0026gt;= exp.get(i)) { a -= exp.get(i); res += 1L \u0026lt;\u0026lt; i; } } res *= flag; if (res \u0026gt; Integer.MAX_VALUE || res \u0026lt; Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return (int)res; } } "},{"id":146,"href":"/docs/leetcode/others/31/","title":"31st","section":"Leet Code","content":" \rLink\n class Solution { // 从前往后找第一次降序的位置k  // 从k开始找较k-1大的数，交换  // 反转(k, end)  public void nextPermutation(int[] nums) { int n = nums.length; int k = n - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k - 1] \u0026gt;= nums[k]) k--; if (k \u0026lt;= 0) { reverse(nums, 0, n - 1); } else { int t = k; while (t \u0026lt; n \u0026amp;\u0026amp; nums[t] \u0026gt; nums[k - 1]) t++; swap(nums, k - 1, t - 1); reverse(nums, k, n - 1); } } private void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } // [begin, end]  private void reverse(int[] nums, int begin, int end) { for (int i = 0; i \u0026lt; (end - begin + 1) / 2; i++) { swap(nums, begin + i, end - i); } } } "},{"id":147,"href":"/docs/leetcode/others/36/","title":"36th","section":"Leet Code","content":" \rLink\n class Solution { public boolean isValidSudoku(char[][] board) { boolean[] st = new boolean[10]; // 判断行  for (int i = 0; i \u0026lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } // 判断列  for (int i = 0; i \u0026lt; 9; i++) { Arrays.fill(st, false); for (int j = 0; j \u0026lt; 9; j++) { if (board[j][i] != \u0026#39;.\u0026#39;) { int t = board[j][i] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } // 判断小方格  for (int i = 0; i \u0026lt; 9; i += 3) { for (int j = 0; j \u0026lt; 9; j += 3) { Arrays.fill(st, false); for (int x = 0; x \u0026lt; 3; x++) { for (int y = 0; y \u0026lt; 3; y++) { if (board[x + i][y + j] != \u0026#39;.\u0026#39;) { int t = board[x + i][y + j] - \u0026#39;0\u0026#39;; if (st[t]) return false; st[t] = true; } } } } } return true; } } "},{"id":148,"href":"/docs/leetcode/others/37/","title":"37th","section":"Leet Code","content":" \rLink\n class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init  for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;1\u0026#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] != \u0026#39;.\u0026#39;) return dfs(board, x, y + 1); for (int i = 0; i \u0026lt; 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x / 3][y / 3][i]) { board[x][y] = (char)(i + \u0026#39;1\u0026#39;); row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if (dfs(board, x, y + 1)) { return true; } board[x][y] = \u0026#39;.\u0026#39;; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; } } "},{"id":149,"href":"/docs/leetcode/others/383/","title":"383rd","section":"Leet Code","content":" \rLink\n class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count = new int[26]; for (char c : magazine.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } for (char c : ransomNote.toCharArray()) { if (count[c - \u0026#39;a\u0026#39;] \u0026lt;= 0) return false; count[c - \u0026#39;a\u0026#39;]--; } return true; } } "},{"id":150,"href":"/docs/leetcode/others/48/","title":"48th","section":"Leet Code","content":" \rLink\n public void rotate(int[][] matrix) { int n = matrix.length; // 沿着对角线翻转  for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } // 沿着中心列翻转  for (int row = 0; row \u0026lt; n; row++) { for (int i = 0, j = n - 1; i \u0026lt; j; i++, j--) { int tmp = matrix[row][i]; matrix[row][i] = matrix[row][j]; matrix[row][j] = tmp; } } } "},{"id":151,"href":"/docs/leetcode/others/50/","title":"50th","section":"Leet Code","content":" \rLink\n public double myPow(double x, int n) { boolean isMinus = false; if (n \u0026lt; 0) { isMinus = true; } double res = 1; for (long k = (long)Math.abs((long)n); k != 0; k \u0026gt;\u0026gt;= 1) { if ((k \u0026amp; 0x1) == 0x1) { res *= x; } x *= x; } if (isMinus) { return 1 / res; } else { return res; } } "},{"id":152,"href":"/docs/leetcode/others/56/","title":"56th","section":"Leet Code","content":" \rLink\n class Solution { public int[][] merge(int[][] intervals) { int n = intervals.length; int[][] res = new int[n][2]; Arrays.sort(intervals, (a, b) -\u0026gt; { if (a[0] == b[0]) { return a[1] - b[1]; } return a[0] - b[0]; }); int idx = 0; int l = intervals[0][0], r = intervals[0][1]; for (int i = 1; i \u0026lt; n; i++) { if (intervals[i][0] \u0026gt; r) { res[idx++] = new int[]{l, r}; l = intervals[i][0]; r = intervals[i][1]; } else { r = Math.max(r, intervals[i][1]); } } res[idx++] = new int[]{l, r}; return Arrays.copyOfRange(res, 0, idx); } } "},{"id":153,"href":"/docs/leetcode/others/57/","title":"57th","section":"Leet Code","content":" \rLink\n class Solution { public int[][] insert(int[][] a, int[] b) { if (a.length == 0) return new int[][]{{b[0], b[1]}}; int n = a.length; int[][] res = new int[n + 1][2]; int idx = 0; int k = 0; // 处理左边完全没有交集的情况  while (k \u0026lt; n \u0026amp;\u0026amp; a[k][1] \u0026lt; b[0]) { res[idx++] = new int[]{a[k][0], a[k][1]}; k++; } // 处理交集  if (k \u0026lt; n) { b[0] = Math.min(a[k][0], b[0]); while (k \u0026lt; n \u0026amp;\u0026amp; a[k][0] \u0026lt;= b[1]) { b[1] = Math.max(b[1], a[k][1]); k++; } } res[idx++] = new int[]{b[0], b[1]}; // 处理右边完全没有交集的情况  while (k \u0026lt; n) { res[idx++] = new int[]{a[k][0], a[k][1]}; k++; } return Arrays.copyOfRange(res, 0, idx); } } "},{"id":154,"href":"/docs/leetcode/others/5963/","title":"5963rd","section":"Leet Code","content":" TODO: Link\n class Solution { public boolean isSameAfterReversals(int num) { String val = String.valueOf(num); String r1 = reverse(val); if (r1.length() == 0) { return true; } String r2 = reverse(r1); return r2.equals(val); } private String reverse(String s) { StringBuilder sb = new StringBuilder(); int i = s.length() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i) == \u0026#39;0\u0026#39;) { i--; } for ( ; i \u0026gt;= 0; i--) { sb.append(s.charAt(i)); } return sb.toString(); } } "},{"id":155,"href":"/docs/leetcode/others/5965/","title":"5965th","section":"Leet Code","content":" TODO: Link\n 稍微优化下还是超时，放弃\nclass Solution { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = map.get(arr[begin]); if (list == null) { list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { // if (i == begin) continue;  if (arr[begin] == arr[i]) { list.add(i); } } map.put(arr[begin], list); System.out.println(1); } else { System.out.println(2); } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } 超时\nclass Solution { public long[] getDistances(int[] arr) { long[] res = new long[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { res[i] = calculate(arr, i); } return res; } private int calculate(int[] arr, int begin) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { if (i == begin) continue; if (arr[begin] == arr[i]) { list.add(i); } } int res = 0; for (int val : list) { res += Math.abs(begin - val); } return res; } } ``"},{"id":156,"href":"/docs/leetcode/others/5967/","title":"5967th","section":"Leet Code","content":" \rLink\n public boolean checkString(String s) { char[] chs = s.toCharArray(); int x = -1, y = -1; for (int i = 0; i \u0026lt; chs.length; i++) { if (chs[i] == \u0026#39;a\u0026#39;) { x = i; } else if (y == -1 \u0026amp;\u0026amp; chs[i] == \u0026#39;b\u0026#39;) { y = i; } } if (x == -1 || y == -1) { return true; } return x \u0026lt; y; } "},{"id":157,"href":"/docs/leetcode/others/5968/","title":"5968th","section":"Leet Code","content":" \rLink\n class Solution { private int res = 0; private int m; private int n; public int numberOfBeams(String[] bank) { m = bank.length; n = bank[0].length(); for (int i = 0; i \u0026lt; m - 1; i++) { if (!bank[i].contains(\u0026#34;1\u0026#34;)) { continue; } int t = calculate(bank, i); // 计算这一行符合的激光束数量  if (t \u0026gt; 0) { // update result  for (int j = 0; j \u0026lt; n; j++) { if (bank[i].charAt(j) == \u0026#39;1\u0026#39;) { res += t; } } } } return res; } private int calculate(String[] bank, int start) { int end = start; for (int i = end + 1; i \u0026lt; m; i++) { if (bank[i].contains(\u0026#34;1\u0026#34;)) { end = i; break; } } int result = 0; if (end != start) { for (int i = 0; i \u0026lt; n; i++) { if (bank[end].charAt(i) == \u0026#39;1\u0026#39;) { result++; } } } return result; } } "},{"id":158,"href":"/docs/leetcode/others/5969/","title":"5969th","section":"Leet Code","content":" [Link]\n class Solution { public boolean asteroidsDestroyed(int mass, int[] asteroids) { Arrays.sort(asteroids); long t = (long) mass; for (int a : asteroids) { if (t \u0026lt; a) { return false; } else { t += a; } } return true; } } "},{"id":159,"href":"/docs/leetcode/others/7/","title":"7th","section":"Leet Code","content":" \rLink\n public int reverse(int x) { // java 这里-11 % 10 = -1 数学上应该是 9  int flag = 1; if (x \u0026lt; 0) { flag = -1; x = -x; } int res = 0; while (x != 0) { if (res \u0026gt; ((Integer.MAX_VALUE - (x % 10)) / 10)) { return 0; } res = res * 10 + (x % 10); x /= 10; } return res * flag; } "},{"id":160,"href":"/docs/leetcode/others/748/","title":"748th","section":"Leet Code","content":" \rLink\n public String shortestCompletingWord(String licensePlate, String[] words) { int[] src = count(licensePlate); int min = Integer.MAX_VALUE; String res = \u0026#34;\u0026#34;; for (String word : words) { int[] tmp = count(word); if (isValid(src, tmp) \u0026amp;\u0026amp; word.length() \u0026lt; min) { min = word.length(); res = word; } } return res; } private boolean isValid(int[] a1, int[] a2) { for (int i = 0; i \u0026lt; a1.length; i++) { if (a1[i] \u0026gt; a2[i]) return false; } return true; } private int[] count(String word) { int[] tmp = new int[26]; for (char c : word.toCharArray()) { if (Character.isLetter(c)) { c = Character.toUpperCase(c); tmp[c - \u0026#39;A\u0026#39;]++; } } return tmp; } "},{"id":161,"href":"/docs/leetcode/others/9/","title":"9th","section":"Leet Code","content":" \rLink\n public boolean isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int y = x; int res = 0; while (x \u0026gt; 0) { res = res * 10 + (x % 10); x /= 10; } return res == y; } public boolean isPalindrome(int x) { String s = String.valueOf(x); return s.equals(new StringBuilder(s).reverse().toString()); } "},{"id":162,"href":"/docs/leetcode/recursion/1492/","title":"1492nd","section":"Leet Code","content":" \rLink\n public int kthFactor(int n, int k) { return help(n, k, 1); } private int help(int n, int k, int f) { if (f \u0026gt;= n \u0026amp;\u0026amp; k \u0026gt; 1) return -1; if (n % f == 0) { if (k == 1) return f; return help(n, k - 1, f + 1); } return help(n, k, f + 1); } "},{"id":163,"href":"/docs/leetcode/search/139/","title":"139th","section":"Leet Code","content":" \rLink\n 遍历字符串，将其分成两部分left和right，判断是否都在wordList里。\n加上记忆化\npublic boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(wordDict); Map\u0026lt;String, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); return dfs(s, set, map); } private boolean dfs(String s, Set\u0026lt;String\u0026gt; set, Map\u0026lt;String, Boolean\u0026gt; map) { if (map.containsKey(s)) { return map.get(s); } if (set.contains(s)) { map.put(s, true); return true; } int n = s.length(); for (int i = 1; i \u0026lt; n; i++) { String left = s.substring(0, i); String right = s.substring(i, n); if (set.contains(left) \u0026amp;\u0026amp; dfs(right, set, map)) { map.put(s, true); return true; } } map.put(s, false); return false; } 最佳实践：使用Trie\npublic class TreeNode { TreeNode[] children; boolean isWord; char value; TreeNode() { children = new TreeNode[26]; } } private TreeNode root = new TreeNode(); public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { for (String word : wordDict) { TreeNode node = root; for (char c : word.toCharArray()) { if (node.children[c - \u0026#39;a\u0026#39;] == null) { node.children[c - \u0026#39;a\u0026#39;] = new TreeNode(); } node.children[c - \u0026#39;a\u0026#39;].value = c; node = node.children[c - \u0026#39;a\u0026#39;]; } node.isWord = true; } return dfs(s, 0); } private int[] memo = new int[301]; private boolean dfs(String s, int cur) { // s[cur:]  int n = s.length(); if (cur \u0026gt;= n) return true; if (memo[cur] == 1) return false; TreeNode node = root; for (int i = cur; i \u0026lt; n; i++) { TreeNode tmp = node.children[s.charAt(i) - \u0026#39;a\u0026#39;]; node = tmp; if (tmp != null) { if (tmp.isWord \u0026amp;\u0026amp; dfs(s, i + 1)) { return true; } } else { break; } } memo[cur] = 1; return false; } "},{"id":164,"href":"/docs/leetcode/search/17/","title":"17th","section":"Leet Code","content":" \rLink\n 使用StringBuilder优化字符串copy\nclass Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), new StringBuilder()); return res; } private void dfs(String digits, int pos, int len, StringBuilder cur) { if (pos == len) { res.add(cur.toString()); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { cur.append(c); dfs(digits, pos + 1, len, cur); cur.deleteCharAt(cur.length() - 1); } } } } class Solution { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); String[] keyboards = new String[]{ \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;, }; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } dfs(digits, 0, digits.length(), \u0026#34;\u0026#34;); return res; } private void dfs(String digits, int pos, int len, String cur) { if (pos == len) { res.add(cur); return; } else { for (char c : keyboards[digits.charAt(pos) - \u0026#39;0\u0026#39;].toCharArray()) { dfs(digits, pos + 1, len, cur + c); } } } } "},{"id":165,"href":"/docs/leetcode/search/216/","title":"216th","section":"Leet Code","content":" \rLink\n class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum3(int k, int n) { dfs(k, n, 1); return res; } void dfs(int k, int target, int s) { if (target \u0026lt; 0) return; if (cur.size() == k) { if (target == 0) res.push_back(cur); return; } for (int i = s; i \u0026lt;= 9; i++) { if (target - i \u0026lt; 0) continue; cur.push_back(i); dfs(k, target - i, i + 1); cur.pop_back(); } } }; "},{"id":166,"href":"/docs/leetcode/search/37/","title":"37th","section":"Leet Code","content":" \rLink\n class Solution { boolean[][] row = new boolean[9][9]; boolean[][] col = new boolean[9][9]; boolean[][][] cell = new boolean[3][3][9]; public void solveSudoku(char[][] board) { // init  for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] != \u0026#39;.\u0026#39;) { int t = board[i][j] - \u0026#39;1\u0026#39;; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } private boolean dfs(char[][] board, int x, int y) { if (y == 9) { x++; y = 0; } if (x == 9) { return true; } if (board[x][y] != \u0026#39;.\u0026#39;) return dfs(board, x, y + 1); for (int i = 0; i \u0026lt; 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x / 3][y / 3][i]) { board[x][y] = (char)(i + \u0026#39;1\u0026#39;); row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if (dfs(board, x, y + 1)) { return true; } board[x][y] = \u0026#39;.\u0026#39;; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; } } "},{"id":167,"href":"/docs/leetcode/search/51/","title":"51st","section":"Leet Code","content":" \rLink\n class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; int n; vector\u0026lt;bool\u0026gt; col, dg, udg; vector\u0026lt;string\u0026gt; path; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int _n) { n = _n; col = vector\u0026lt;bool\u0026gt;(n); dg = vector\u0026lt;bool\u0026gt;(n * 2); udg = vector\u0026lt;bool\u0026gt;(n * 2); path = vector\u0026lt;string\u0026gt;(n, string(n, \u0026#39;.\u0026#39;)); dfs(0); return res; } void dfs(int u) { if (u == n) { res.push_back(path); return; } for (int i = 0; i \u0026lt; n; i++) { if (!col[i] \u0026amp;\u0026amp; !dg[u + i] \u0026amp;\u0026amp; !udg[u - i + n]) { col[i] = dg[u + i] = udg[u - i + n] = true; path[u][i] = \u0026#39;Q\u0026#39;; dfs(u + 1); path[u][i] = \u0026#39;.\u0026#39;; col[i] = dg[u + i] = udg[u - i + n] = false; } } } }; "},{"id":168,"href":"/docs/leetcode/search/52/","title":"52nd","section":"Leet Code","content":" \rLink\n class Solution { boolean[] col, dg, udg; int n; public int totalNQueens(int n) { this.n = n; col = new boolean[n]; dg = new boolean[n * 2]; udg = new boolean[n * 2]; return dfs(0); } private int dfs(int u) { if (u == n) { return 1; } int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (!col[i] \u0026amp;\u0026amp; !dg[u - i + n] \u0026amp;\u0026amp; !udg[u + i]) { col[i] = dg[u - i + n] = udg[u + i] = true; res += dfs(u + 1); col[i] = dg[u - i + n] = udg[u + i] = false; } } return res; } } "},{"id":169,"href":"/docs/leetcode/search/5964/","title":"5964th","section":"Leet Code","content":" TODO: Link\n class Solution { private int n; public int[] executeInstructions(int n, int[] startPos, String s) { int tmp = s.length(); int[] res = new int[tmp]; int idx = 0; this.n = n; for (int i = 0; i \u0026lt; tmp; i++) { res[idx++] = help(Arrays.copyOf(startPos, 2), s, i, tmp); } return res; } private int help(int[] pos, String s, int start, int len) { int res = 0; for (int i = start; i \u0026lt; len; i++) { if (checkAndRun(pos, s.charAt(i))) { res++; } else { break; } } return res; } private boolean checkAndRun(int[] pos, char c) { if (c == \u0026#39;U\u0026#39;) { if (pos[0] != 0) { pos[0]--; return true; } } else if (c == \u0026#39;R\u0026#39;) { if (pos[1] != (n - 1)) { pos[1]++; return true; } } else if (c == \u0026#39;L\u0026#39;) { if (pos[1] != 0) { pos[1]--; return true; } } else if (c == \u0026#39;D\u0026#39;) { if (pos[0] != (n - 1)) { pos[0]++; return true; } } return false; } } "},{"id":170,"href":"/docs/leetcode/search/77/","title":"77th","section":"Leet Code","content":" \rLink\n class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; cur = new ArrayList\u0026lt;\u0026gt;(); int n, k; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { this.n = n; this.k = k; dfs(1); return res; } private void dfs(int s) { if (cur.size() == k) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); return; } for (int i = s; i \u0026lt;= n; i++) { cur.add(i); dfs(i + 1); cur.remove(cur.size() - 1); } } } "},{"id":171,"href":"/docs/leetcode/search/78/","title":"78th","section":"Leet Code","content":" \rLink\n 集合的每个元素，都有可以选或不选。\n例如二进制: 001 表示选择第一个元数, 011 选择第一个第二元素\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = nums.length; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); for (int j = 0; j \u0026lt; n; j++) if (((i \u0026gt;\u0026gt; j) \u0026amp; 1) == 1) path.add(nums[j]); res.add(new ArrayList\u0026lt;\u0026gt;(path)); } return res; } DFS\nclass Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { res = new ArrayList\u0026lt;\u0026gt;(); dfs(nums, 0, new ArrayList\u0026lt;\u0026gt;()); return res; } private void dfs(int[] nums, int s, List\u0026lt;Integer\u0026gt; cur) { res.add(new ArrayList\u0026lt;\u0026gt;(cur)); for (int i = s; i \u0026lt; nums.length; i++) { cur.add(nums[i]); dfs(nums, i + 1, cur); cur.remove(cur.size() - 1); } } } "},{"id":172,"href":"/docs/leetcode/search/79/","title":"79th","section":"Leet Code","content":" \rLink\n class Solution { public boolean exist(char[][] board, String word) { char[] chs = word.toCharArray(); for (int i = 0; i \u0026lt; board.length; i++) { for (int j = 0; j \u0026lt; board[i].length; j++) { if (dfs(board, chs, i, j, 0)) return true; } } return false; } private int[] dx = {0, 0, 1, -1}, dy = {1, -1, 0, 0}; private boolean dfs(char[][] board, char[] word, int x, int y, int u) { if (board[x][y] != word[u]) return false; if (u == word.length - 1) return true; char t = board[x][y]; board[x][y] = \u0026#39;.\u0026#39;; for (int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt; 0 || nx \u0026gt;= board.length || ny \u0026lt; 0 || ny \u0026gt;= board[0].length || board[nx][ny] == \u0026#39;.\u0026#39;) { continue; } if (dfs(board, word, nx, ny, u + 1)) return true; } board[x][y] = t; return false; } } "},{"id":173,"href":"/docs/leetcode/search/90/","title":"90th","section":"Leet Code","content":" \rLink\n class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); dfs(nums, 0); return res; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int s) { res.push_back(cur); for (int i = s; i \u0026lt; nums.size(); i++) { if (i \u0026gt; s \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; cur.push_back(nums[i]); dfs(nums, i + 1); cur.pop_back(); } } }; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; path; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); dfs(nums, 0); return res; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int u) { if (u == nums.size()) { res.push_back(path); return; } // 统计当前数的个数  int k = u + 1; while (k \u0026lt; nums.size() \u0026amp;\u0026amp; nums[k] == nums[u]) k++; // 一个不选的情况  dfs(nums, k); // 遍历依次选择每个相同的数  for (int i = 1; i \u0026lt;= k - u; i++) { path.push_back(nums[u]); dfs(nums, k); } for (int i = 1; i \u0026lt;= k - u; i++) { path.pop_back(); } } }; "},{"id":174,"href":"/docs/leetcode/simulation/12/","title":"12th","section":"Leet Code","content":" \rLink\n public String intToRoman(int num) { int[] values = new int[]{ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000 }; String[] chs = new String[]{ \u0026#34;I\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;M\u0026#34; }; StringBuilder sb = new StringBuilder(); for (int i = values.length - 1; i \u0026gt;= 0; i--) { while (num \u0026gt;= values[i]) { num -= values[i]; sb.append(chs[i]); } } return sb.toString(); } "},{"id":175,"href":"/docs/leetcode/simulation/13/","title":"13th","section":"Leet Code","content":" \rLink\n public int romanToInt(String s) { Map\u0026lt;Character, Integer\u0026gt; hash = new HashMap\u0026lt;\u0026gt;(); hash.put(\u0026#39;I\u0026#39;, 1); hash.put(\u0026#39;V\u0026#39;, 5); hash.put(\u0026#39;X\u0026#39;, 10); hash.put(\u0026#39;L\u0026#39;, 50); hash.put(\u0026#39;C\u0026#39;, 100); hash.put(\u0026#39;D\u0026#39;, 500); hash.put(\u0026#39;M\u0026#39;, 1000); int res = 0; int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (i + 1 \u0026lt; n \u0026amp;\u0026amp; hash.get(s.charAt(i)) \u0026lt; hash.get(s.charAt(i + 1))) { res = res + (-hash.get(s.charAt(i))); } else { res = res + hash.get(s.charAt(i)); } } return res; } "},{"id":176,"href":"/docs/leetcode/simulation/38/","title":"38th","section":"Leet Code","content":" \rLink\n public String countAndSay(int n) { String res = \u0026#34;1\u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { StringBuilder t = new StringBuilder(); int m = res.length(); for (int j = 0; j \u0026lt; m; ) { int k = j + 1; while (k \u0026lt; m \u0026amp;\u0026amp; res.charAt(j) == res.charAt(k)) k++; t.append(k - j).append(res.charAt(j)); j = k; } res = t.toString(); } return res; } "},{"id":177,"href":"/docs/leetcode/simulation/54/","title":"54th","section":"Leet Code","content":" \rLink\n class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int n = matrix.length, m = matrix[0].length; int[] dx = new int[]{0, 1, 0, -1}; int[] dy = new int[]{1, 0, -1, 0}; boolean[][] st = new boolean[n][m]; for (int i = 0, d = 0, x = 0, y = 0; i \u0026lt; n * m; i++) { ans.add(matrix[x][y]); st[x][y] = true; int a = x + dx[d], b = y + dy[d]; if (a \u0026lt; 0 || a \u0026gt;= n || b \u0026lt; 0 || b \u0026gt;= m || st[a][b]) { d = (d + 1) % 4; a = x + dx[d]; b = y + dy[d]; } x = a; y = b; } return ans; } } "},{"id":178,"href":"/docs/leetcode/simulation/59/","title":"59th","section":"Leet Code","content":" \rLink\n class Solution { public int[][] generateMatrix(int n) { int[][] res = new int[n][n]; int[] dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0}; for (int i = 1, x = 0, y = 0, d = 0; i \u0026lt;= n * n; i++) { res[x][y] = i; int a = x + dx[d], b = y + dy[d]; if (a \u0026lt; 0 || a \u0026gt;= n || b \u0026lt; 0 || b \u0026gt;= n || res[a][b] != 0) { d = (d + 1) % 4; a = x + dx[d]; b = y + dy[d]; } x = a; y = b; } return res; } } "},{"id":179,"href":"/docs/leetcode/simulation/73/","title":"73rd","section":"Leet Code","content":" \rLink\n public void setZeroes(int[][] matrix) { int m = matrix.length, n = matrix[0].length; // 将第一行和第一列看成 (m - 1) * (n - 1) 行和列为0的标识  // 再用两个变量标识第一行和第一列  int r1 = 1, c1 = 1; for (int i = 0; i \u0026lt; n; i++) { if (matrix[0][i] == 0) { r1 = 0; break; } } for (int i = 0; i \u0026lt; m; i++) { if (matrix[i][0] == 0) { c1 = 0; break; } } // 设置列  for (int i = 1; i \u0026lt; m; i++) for (int j = 0; j \u0026lt; n; j++) if (matrix[i][j] == 0) matrix[0][j] = 0; // 设置行  for (int i = 0; i \u0026lt; n; i++) for (int j = 1; j \u0026lt; m; j++) if (matrix[j][i] == 0) matrix[j][0] = 0; // 设置 (m - 1) * (n - 1)  for (int i = 1; i \u0026lt; m; i++) if (matrix[i][0] == 0) for (int j = 1; j \u0026lt; n; j++) matrix[i][j] = 0; for (int i = 1; i \u0026lt; n; i++) if (matrix[0][i] == 0) for (int j = 1; j \u0026lt; m; j++) matrix[j][i] = 0; if (r1 == 0) for (int i = 0; i \u0026lt; n; i++) matrix[0][i] = 0; if (c1 == 0) for (int i = 0; i \u0026lt; m; i++) matrix[i][0] = 0; } "},{"id":180,"href":"/docs/leetcode/sorts/215/","title":"215th","section":"Leet Code","content":" \rLink\n 使用优先队列\n// Time Complexity: O(nlgn)  // Space Complexity: O(k)  public int findKthLargest(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); for (int num : nums) { if (q.size() == k) { if (num \u0026gt; q.peek()) { q.poll(); q.offer(num); } } else { q.offer(num); } } return q.peek(); } "},{"id":181,"href":"/docs/leetcode/sorts/41/","title":"41st","section":"Leet Code","content":" \rLink\n class Solution { public int firstMissingPositive(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { while (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] != i + 1 \u0026amp;\u0026amp; nums[i] \u0026lt;= nums.length \u0026amp;\u0026amp; nums[i] != nums[nums[i] - 1]) { int tmp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = tmp; } } for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != i + 1) { return i + 1; } } return nums.length + 1; } } "},{"id":182,"href":"/docs/leetcode/stack/20/","title":"20th","section":"Leet Code","content":" \rLink\n 查阅Ascii码表进行简化\npublic boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); } else { if (st.size() \u0026gt; 0 \u0026amp;\u0026amp; Math.abs(st.peek() - s.charAt(i)) \u0026lt;= 2) { st.pop(); } else { return false; } } } return st.size() == 0; } public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39; || s.charAt(i) == \u0026#39;{\u0026#39; || s.charAt(i) == \u0026#39;[\u0026#39;) { st.push(s.charAt(i)); continue; } if (st.size() == 0 || (s.charAt(i) == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;(\u0026#39;) || (s.charAt(i) == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;[\u0026#39;) || (s.charAt(i) == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; st.peek() != \u0026#39;{\u0026#39;)) { return false; } st.pop(); } return st.size() == 0; } "},{"id":183,"href":"/docs/leetcode/stack/32/","title":"32nd","section":"Leet Code","content":" \rLink\n public int longestValidParentheses(String s) { Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int n = s.length(); int result = 0; for (int i = 0, start = -1; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { st.push(i); } else { if (st.isEmpty()) { start = i; } else { st.pop(); if (st.isEmpty()) { result = Math.max(result, i - start); } else { result = Math.max(result, i - st.peek()); } } } } return result; } "},{"id":184,"href":"/docs/leetcode/stack/42/","title":"42nd","section":"Leet Code","content":" \rLink\n \r\rDetail\npublic int trap(int[] height) { Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int ans = 0; for (int i = 0; i \u0026lt; height.length; i++) { while (!st.isEmpty() \u0026amp;\u0026amp; height[st.peek()] \u0026lt; height[i]) { int cur = st.pop(); if (st.isEmpty()) break; int l = st.peek(); int r = i; int h = Math.min(height[l], height[r]) - height[cur]; ans += (r - l - 1) * h; } st.push(i); } return ans; } "},{"id":185,"href":"/docs/leetcode/string/14/","title":"14th","section":"Leet Code","content":" \rLink\n public String longestCommonPrefix(String[] strs) { StringBuilder sb = new StringBuilder(); int n = strs[0].length(); for (int i = 0; i \u0026lt; n; i++) { char c = strs[0].charAt(i); for (int j = 1; j \u0026lt; strs.length; j++) { if (i \u0026gt;= strs[j].length() || c != strs[j].charAt(i)) { return sb.toString(); } } sb.append(c); } return sb.toString(); } "},{"id":186,"href":"/docs/leetcode/string/28/","title":"28th","section":"Leet Code","content":" \rLink\n public int strStr(String s, String p) { int m = p.length(); if (m == 0) return 0; int n = s.length(); s = \u0026#34; \u0026#34; + s; p = \u0026#34; \u0026#34; + p; int[] next = new int[m + 1]; for (int i = 2, j = 0; i \u0026lt;= m; i++) { while (j != 0 \u0026amp;\u0026amp; p.charAt(i) != p.charAt(j + 1)) j = next[j]; if ( p.charAt(i) == p.charAt(j + 1)) j++; next[i] = j; } // 匹配  for (int i = 1, j = 0; i \u0026lt;= n; i++) { while (j != 0 \u0026amp;\u0026amp; s.charAt(i) != p.charAt(j + 1)) j = next[j]; if (s.charAt(i) == p.charAt(j + 1)) j++; if (j == m) return i - m; } return -1; } "},{"id":187,"href":"/docs/leetcode/string/5/","title":"5th","section":"Leet Code","content":" \rLink\n public String longestPalindrome(String s) { int n = s.length(); String res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { int l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } l = i; r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; s.charAt(l) == s.charAt(r)) { l--; r++; } if (res.length() \u0026lt; (r - l - 1)) { res = s.substring(l + 1, r); } } return res; } "},{"id":188,"href":"/docs/leetcode/string/58/","title":"58th","section":"Leet Code","content":" \rLink\n public int lengthOfLastWord(String s) { int j = s.length() - 1; while (s.charAt(j) == \u0026#39; \u0026#39;) j--; int i = j; while (i \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(i) != \u0026#39; \u0026#39;) i--; return j - i; } "},{"id":189,"href":"/docs/leetcode/string/6/","title":"6th","section":"Leet Code","content":" \rLink\n 转成索引排列，找出规律\npublic String convert(String s, int numRows) { if (numRows == 1) { return s; } StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; numRows; i++) { if (i == 0 || i == numRows - 1) { for (int j = i; j \u0026lt; n; j += 2 * numRows - 2) { sb.append(s.charAt(j)); } } else { for (int j = i, k = 2 * numRows - 2 - i; j \u0026lt; n || k \u0026lt; n; j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j \u0026lt; n) { sb.append(s.charAt(j)); } if (k \u0026lt; n) { sb.append(s.charAt(k)); } } } } return sb.toString(); } "},{"id":190,"href":"/docs/leetcode/string/65/","title":"65th","section":"Leet Code","content":" \rLink\n public boolean isNumber(String s) { if (s.charAt(0) == \u0026#39;+\u0026#39; || s.charAt(0) == \u0026#39;-\u0026#39;) s = s.substring(1); // 空符号  if (s.length() == 0) return false; // 有效小数判断  if (s.charAt(0) == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; (s.length() == 1 || s.charAt(1) == \u0026#39;e\u0026#39; || s.charAt(1) == \u0026#39;E\u0026#39;)) return false; int dot = 0, e = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;.\u0026#39;) { // .已经出现，或者点在e之后  if (dot \u0026gt; 0 || e \u0026gt; 0) return false; dot++; } else if (s.charAt(i) == \u0026#39;e\u0026#39; || s.charAt(i) == \u0026#39;E\u0026#39;) { // e在第一位, e在最后一位, e已经出现  if (i == 0 || i + 1 == s.length() || e \u0026gt; 0) return false; // ?e- || ?e+  if (s.charAt(i + 1) == \u0026#39;+\u0026#39; || s.charAt(i + 1) == \u0026#39;-\u0026#39;) { if (i + 2 == s.length()) return false; i++; } e++; } else if (s.charAt(i) \u0026lt; \u0026#39;0\u0026#39; || s.charAt(i) \u0026gt; \u0026#39;9\u0026#39;) return false; } return true; } "},{"id":191,"href":"/docs/leetcode/string/68/","title":"68th","section":"Leet Code","content":" \rLink\n public List\u0026lt;String\u0026gt; fullJustify(String[] words, int maxWidth) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; words.length; i++) { int j = i + 1; int len = words[i].length(); // 判断下一个单词能否放下  while (j \u0026lt; words.length \u0026amp;\u0026amp; len + 1 + words[j].length() \u0026lt;= maxWidth) len += 1 + words[j++].length(); StringBuilder line = new StringBuilder(); // 已经没有单词能放了  if (j == words.length || j == i + 1) { // 左对齐  line.append(words[i]); for (int k = i + 1; k \u0026lt; j; k++) line.append(\u0026#34; \u0026#34;).append(words[k]); while (line.length() \u0026lt; maxWidth) line.append(\u0026#34; \u0026#34;); } else { // 左右对齐  // cnt = 此行单词数, r = 这行需要的剩余空格  int cnt = j - i - 1, r = maxWidth - len + cnt; line.append(words[i]); int k = 0; // 为 r % cnt 个多分配一个空格  while (k \u0026lt; r % cnt) { for (int ii = 0; ii \u0026lt; r / cnt + 1; ii++) line.append(\u0026#34; \u0026#34;); line.append(words[i + k + 1]); k++; } while (k \u0026lt; cnt) { for (int ii = 0; ii \u0026lt; r / cnt; ii++) line.append(\u0026#34; \u0026#34;); line.append(words[i + k + 1]); k++; } } res.add(line.toString()); i = j -1; } return res; } "},{"id":192,"href":"/docs/leetcode/string/8/","title":"8th","section":"Leet Code","content":" \rLink\n class Solution { public int myAtoi(String s) { int k = 0; int n = s.length(); while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) == \u0026#39; \u0026#39;) { k++; } if (k == n) { return 0; } int minus = 1; if (s.charAt(k) == \u0026#39;-\u0026#39;) { minus = -1; k++; } else if (s.charAt(k) == \u0026#39;+\u0026#39;) { k++; } int res = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s.charAt(k) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s.charAt(k) \u0026lt;= \u0026#39;9\u0026#39;) { int x = s.charAt(k) - \u0026#39;0\u0026#39;; if (minus \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (Integer.MAX_VALUE - x) / 10) { return Integer.MAX_VALUE; } if (minus \u0026lt; 0 \u0026amp;\u0026amp; -res \u0026lt; (Integer.MIN_VALUE + x) / 10) { return Integer.MIN_VALUE; } if (-res * 10 - x == Integer.MIN_VALUE) { return Integer.MIN_VALUE; } res = res * 10 + x; k++; } res *= minus; return res; } } "},{"id":193,"href":"/docs/leetcode/tips/","title":"Tips","section":"Leet Code","content":"摩尔投票算法\r#\r\r/* 对于n个元素，超过n/2的次数最多只有一个元素。同理超过n/3的次数最多只有二个元素。选一个candidate，标记为1，每次不一样标记减1。标记为0时，将当前元素设为candidate且标记为1。(相当于消除不一样的元素)，最后需要确定是否符合条件。 */ "},{"id":194,"href":"/docs/leetcode/tree/102/","title":"102nd","section":"Leet Code","content":" \rLink\n 考虑当前层结束条件，即当前队列中的元素个数。\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); int count = q.size(); while (count \u0026gt; 0) { TreeNode node = q.poll(); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); count--; } ans.add(tmp); } return ans; } "},{"id":195,"href":"/docs/leetcode/tree/559/","title":"559th","section":"Leet Code","content":" \rLink 一道简单的搜索\n public int maxDepth(Node root) { if (root == null) return 0; if (root.children == null) return 1; int max = 0; int n = root.children.size(); for (int i = 0; i \u0026lt; n; i++) { max = Math.max(max, maxDepth(root.children.get(i))); } return max + 1; } "},{"id":196,"href":"/docs/leetcode/tree/700/","title":"700th","section":"Leet Code","content":" \rLink\n 递归搜索\nclass Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; if (val \u0026gt; root.val) { return searchBST(root.right, val); } else { return searchBST(root.left, val); } } } "},{"id":197,"href":"/docs/leetcode/twopointers/11/","title":"11th","section":"Leet Code","content":" \rLink\n public int maxArea(int[] height) { int res = 0; for (int i = 0, j = height.length - 1; i \u0026lt; j; ) { res = Math.max(res, Math.min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) { i++; } else { j--; } } return res; } "},{"id":198,"href":"/docs/leetcode/twopointers/15/","title":"15th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) { // 找靠近左边第一个\u0026gt;=的k索引  k--; } if (nums[i] + nums[j] + nums[k] == 0) { res.add(List.of(nums[i], nums[j], nums[k])); } } } return res; } "},{"id":199,"href":"/docs/leetcode/twopointers/16/","title":"16th","section":"Leet Code","content":" \rLink\n public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { int j = i + 1, k = nums.length - 1; while (j \u0026lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum \u0026gt; target) { k--; } else { j++; } if (Math.abs(target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } return res; } public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1, k = nums.length - 1; j \u0026lt; k; j++) { while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) { k--; } int sum = nums[i] + nums[j] + nums[k]; // 靠近左边第一个\u0026gt;=target的k  if (Math.abs(sum - target) \u0026lt; Math.abs(target - res)) { res = sum; } if (k - 1 \u0026gt; j) { sum = nums[i] + nums[j] + nums[k - 1]; // \u0026lt; target  if ((target - sum) \u0026lt; Math.abs(target - res)) { res = sum; } } } } return res; } `` "},{"id":200,"href":"/docs/leetcode/twopointers/18/","title":"18th","section":"Leet Code","content":" \rLink\n public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = nums.length; Arrays.sort(nums); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } for (int k = j + 1, u = n - 1; k \u0026lt; u; k++) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { continue; } while (k \u0026lt; u - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k] + nums[u - 1] \u0026gt;= target) { u--; } if (nums[i] + nums[j] + nums[k] + nums[u] == target) { res.add(List.of(nums[i], nums[j], nums[k], nums[u])); } } } } return res; } "},{"id":201,"href":"/docs/leetcode/twopointers/26/","title":"26th","section":"Leet Code","content":" \rLink\n public int removeDuplicates(int[] nums) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (i == 0 || nums[i] != nums[i - 1]) { nums[j++] = nums[i]; } } return j; } "},{"id":202,"href":"/docs/leetcode/twopointers/27/","title":"27th","section":"Leet Code","content":" \rLink\n public int removeElement(int[] nums, int val) { int j = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[j++] = nums[i]; } } return j; } "},{"id":203,"href":"/docs/leetcode/twopointers/3/","title":"3rd","section":"Leet Code","content":" \rLink\n int lengthOfLongestSubstring(string s) { int res = 0; unordered_map\u0026lt;char, int\u0026gt; m; int n = s.length(); for (int i = 0, j = 0; i \u0026lt; n; i++) { m[s[i]]++; while (m[s[i]] \u0026gt; 1) m[s[j++]]--; if (i - j + 1 \u0026gt; res) res = i - j + 1; } return res; } public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int res = 0; int n = s.length(); for (int i = 0, j = 0; i \u0026lt; n; i++) { map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1); if (map.get(s.charAt(i)) == 1) { res = Math.max(res, i - j + 1); continue; } while (map.get(s.charAt(i)) \u0026gt; 1) { map.put(s.charAt(j), map.get(s.charAt(j)) - 1); j++; } } return res; } "},{"id":204,"href":"/docs/leetcode/twopointers/30/","title":"30th","section":"Leet Code","content":" \rLink\n 滑动窗口 + Hash\npublic List\u0026lt;Integer\u0026gt; findSubstring(String s, String[] words) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int n = s.length(), m = words.length; if (m == 0) { return res; } int w = words[0].length(); Map\u0026lt;String, Integer\u0026gt; tot = new HashMap\u0026lt;\u0026gt;(); for (String word : words) tot.put(word, tot.getOrDefault(word, 0) + 1); for (int i = 0; i \u0026lt; w; i++) { Map\u0026lt;String, Integer\u0026gt; wd = new HashMap\u0026lt;\u0026gt;(); int cnt = 0; for (int j = i; j + w \u0026lt;= n; j += w) { if (j \u0026gt;= i + m * w) { String word = s.substring(j - m * w, j - (m - 1) * w); wd.put(word, wd.get(word) - 1); if (tot.containsKey(word) \u0026amp;\u0026amp; wd.get(word) \u0026lt; tot.get(word)) cnt--; } String word = s.substring(j, j + w); wd.put(word, wd.getOrDefault(word, 0) + 1); if (tot.containsKey(word) \u0026amp;\u0026amp; wd.get(word) \u0026lt;= tot.get(word)) cnt++; if (cnt == m) res.add(j - (m - 1) * w); } } return res; } "},{"id":205,"href":"/docs/leetcode/twopointers/33/","title":"33rd","section":"Leet Code","content":" \rLink\n public int search(int[] nums, int target) { // 找到分隔点, 一半区间满足性质，另一半则不满足  // 2 3 4 5 6 7, 1  // 6 7, 1 2 3 4 5  int l = 0, r = nums.length - 1; int mid; while (l \u0026lt; r) { mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= nums[0]) { l = mid; } else { r = mid - 1; } } // 判断在左半边、右半边  if (target \u0026gt;= nums[0]) { l = 0; } else { l = r + 1; r = nums.length - 1; } while (l \u0026lt; r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[r] == target) return r; return -1; } "},{"id":206,"href":"/docs/leetcode/twopointers/34/","title":"34th","section":"Leet Code","content":" \rLink\n class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) { return new int[]{-1, -1}; } int l = 0, r = nums.length - 1; int mid; while (l \u0026lt; r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { r = mid; } else { l = mid + 1; } } if (nums[l] != target) { return new int[]{-1, -1}; } int[] res = new int[2]; res[0] = l; l = 0; r = nums.length - 1; while (l \u0026lt; r) { mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026lt;= target) { l = mid; } else { r = mid - 1; } } res[1] = l; return res; } } "},{"id":207,"href":"/docs/leetcode/twopointers/35/","title":"35th","section":"Leet Code","content":" \rLink\n public int searchInsert(int[] nums, int target) { int lo = 0, hi = nums.length, mid = 0; while (lo \u0026lt; hi) { mid = (lo + hi) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) { hi = mid; } else { lo = mid + 1; } } return lo; } "},{"id":208,"href":"/docs/leetcode/twopointers/4/","title":"4th","section":"Leet Code","content":" \rLink\n public double findMedianSortedArrays(int[] nums1, int[] nums2) { int k = nums1.length + nums2.length; if (k % 2 == 0) { int left = findKth(nums1, 0, nums2, 0, k / 2); int right = findKth(nums1, 0, nums2, 0, k / 2 + 1); return (left + right) / 2.0; } else { return findKth(nums1, 0, nums2, 0, k / 2 + 1); } } // 二分做法  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { if (nums1.length - i \u0026gt; nums2.length - j) { return findKth(nums2, j, nums1, i, k); } if (nums1.length == i) { return nums2[j + k - 1]; } if (k == 1) { return Math.min(nums1[i], nums2[j]); } int k1 = Math.min(nums1.length - i, k / 2); int k2 = k - k1; if (nums1[i + k1 - 1] \u0026lt; nums2[j + k2 - 1]) { return findKth(nums1, i + k1, nums2, j, k - k1); } else { return findKth(nums1, i, nums2, j + k2, k - k2); } } //优先队列做法  private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); while (i \u0026lt; nums1.length) { pq.offer(nums1[i++]); } while (j \u0026lt; nums2.length) { pq.offer(nums2[j++]); } int res = 0; while (k-- \u0026gt; 0) { res = pq.poll(); } return res; } "},{"id":209,"href":"/docs/leetcode/twopointers/69/","title":"69th","section":"Leet Code","content":" \rLink\n public int mySqrt(int x) { if (x == 0) return 0; int l = 1, r = x; while (l \u0026lt; r) { int mid = (int) ((l + 1L + r) \u0026gt;\u0026gt; 1); if (mid \u0026lt;= x / mid) { l = mid; } else { r = mid - 1; } } return l; } "},{"id":210,"href":"/docs/leetcode/twopointers/74/","title":"74th","section":"Leet Code","content":" \rLink\n 看成一个一维数组的二分搜索过程\npublic boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int l = 0, r = m * n - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (matrix[mid / n][mid % n] \u0026gt;= target) r = mid; else l = mid + 1; } return matrix[r / n][r % n] == target; } 从右上角看成一个二分搜索树 O(m * n)\npublic boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int row = 0, col = n - 1; while (row \u0026lt; m \u0026amp;\u0026amp; col \u0026gt;= 0) { if (matrix[row][col] == target) return true; if (matrix[row][col] \u0026gt; target) { col--; } else { row++; } } return false; } "},{"id":211,"href":"/docs/leetcode/twopointers/75/","title":"75th","section":"Leet Code","content":" \rLink\n class Solution { public void sortColors(int[] nums) { for (int i = 0, j = 0, k = nums.length - 1; i \u0026lt;= k; ) { if (nums[i] == 0) { swap(nums, i, j); j++; i++; } else if (nums[i] == 2) { swap(nums, i, k); k--; } else { i++; } } } private void swap(int[] nums, int i, int j) { int t = nums[i]; nums[i] = nums[j]; nums[j] = t; } } "},{"id":212,"href":"/docs/leetcode/twopointers/76/","title":"76th","section":"Leet Code","content":" \rLink\n C++ map数组形式访问时会自动插入不存在的元数 值为默认\nstring minWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; hs, ht; for (auto c : t) ht[c]++; string res = \u0026#34;\u0026#34;; int cnt = 0; for (int i = 0, j = 0; i \u0026lt; s.size(); i++) { hs[s[i]]++; if (hs[s[i]] \u0026lt;= ht[s[i]]) { cnt++; } while (hs[s[j]] \u0026gt; ht[s[j]]) hs[s[j++]]--; if (cnt == t.size()) { if (!res.size() || i - j + 1 \u0026lt; res.size()) res = s.substr(j, i - j + 1); } } return res; } public String minWindow(String s, String t) { Map\u0026lt;Character, Integer\u0026gt; hs = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; ht = new HashMap\u0026lt;\u0026gt;(); for (var c : t.toCharArray()) ht.put(c, ht.getOrDefault(c, 0) + 1); int cnt = 0; String res = \u0026#34;\u0026#34;; for (int i = 0, j = 0; i \u0026lt; s.length(); i++) { hs.put(s.charAt(i), hs.getOrDefault(s.charAt(i), 0) + 1); if (hs.get(s.charAt(i)) \u0026lt;= ht.getOrDefault(s.charAt(i), 0)) cnt++; while (j \u0026lt;= i \u0026amp;\u0026amp; hs.get(s.charAt(j)) \u0026gt; ht.getOrDefault(s.charAt(j), 0)) { hs.put(s.charAt(j), hs.get(s.charAt(j)) - 1); j++; } if (cnt == t.length()) { if (res.length() == 0 || i - j + 1 \u0026lt; res.length()) res = s.substring(j, i + 1); } } return res; } "},{"id":213,"href":"/docs/leetcode/twopointers/80/","title":"80th","section":"Leet Code","content":" \rLink\n public int removeDuplicates(int[] nums) { int k = 0; for (int x : nums) { if (k \u0026lt; 2 || (nums[k - 1] != x || nums[k - 2] != x)) { nums[k++] = x; } } return k; } "},{"id":214,"href":"/docs/leetcode/twopointers/87/","title":"87th","section":"Leet Code","content":" \rLink\n public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1, j = n - 1; int k = m + n - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026gt;= 0) { if (nums1[i] \u0026gt; nums2[j]) { nums1[k--] = nums1[i--]; } else { nums1[k--] = nums2[j--]; } } while (j \u0026gt;= 0) { nums1[k--] = nums2[j--]; } } "},{"id":215,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/","title":"剑指 Offer","section":"Leet Code","content":" \r剑指 Offer 03. 数组中重复的数字(E) \r14. 不修改数组找出重复的数字(E) \r剑指 Offer 04. 二维数组中的查找(M) \r剑指 Offer 05. 替换空格(E) \r剑指 Offer 50. 第一个只出现一次的字符(E) \r剑指 Offer 32 - I. 从上到下打印二叉树(M) \r剑指 Offer 32 - II. 从上到下打印二叉树 II(E) \r剑指 Offer 32 - III. 从上到下打印二叉树 III(M) \r剑指 Offer 47. 礼物的最大价值(M) \r剑指 Offer 26. 树的子结构(M) \r剑指 Offer 18. 删除链表的节点(E) \r剑指 Offer 22. 链表中倒数第k个节点(E) \r剑指 Offer 48. 最长不含重复字符的子字符串(M) \r剑指 Offer 46. 把数字翻译成字符串(M) \r剑指 Offer 25. 合并两个排序的链表(M) \r剑指 Offer 57. 和为s的两个数字(E) \r剑指 Offer 21. 调整数组顺序使奇数位于偶数前面(E) \r剑指 Offer 58 - I. 翻转单词顺序(E) \r剑指 Offer 13. 机器人的运动范围(M) \r剑指 Offer 12. 矩阵中的路径(M) \r剑指 Offer 64. 求1+2+…+n(M) \r剑指 Offer 54. 二叉搜索树的第k大节点(M) \r剑指 Offer 55 - I. 二叉树的深度(E) \r剑指 Offer 55 - II. 平衡二叉树(E) \r剑指 Offer 68 - I. 二叉搜索树的最近公共祖先(E) \r剑指 Offer 68 - II. 二叉树的最近公共祖先(E) \r剑指 Offer 15. 二进制中1的个数(E)  "},{"id":216,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/006/","title":"6th","section":"剑指 Offer","content":" \rLink\n vector\u0026lt;int\u0026gt; reversePrint(ListNode* head) { vector\u0026lt;int\u0026gt; res; while (head) { res.push_back(head-\u0026gt;val); head = head-\u0026gt;next; } return vector\u0026lt;int\u0026gt;(res.rbegin(), res.rend()); } public int[] reversePrint(ListNode head) { Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head.val); head = head.next; } int[] res = new int[s.size()]; int idx = 0; while (!s.isEmpty()) { res[idx++] = s.pop(); } return res; } "},{"id":217,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/03/","title":"3rd","section":"剑指 Offer","content":" \rLink\n 将元素放置到对应的位置。2代表下标为2的位置\nint findRepeatNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { while (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] != nums[i]) { swap(nums[i], nums[nums[i]]); } if (i != nums[i] \u0026amp;\u0026amp; nums[nums[i]] == nums[i]) { return nums[i]; } } return -1; } "},{"id":218,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/04/","title":"4th","section":"剑指 Offer","content":" \rLink\n \r上图是从右上角，同理左下角\n从右上角看成一个二分搜索树\nbool searchArray(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; array, int target) { if (array.size() == 0) { return false; } int m = array.size(); int n = array[0].size(); int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (array[i][j] == target) { return true; } else if (array[i][j] \u0026lt; target) { i++; } else { j--; } } return false; } public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int row = m - 1; int col = 0; while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) { if (matrix[row][col] == target) { return true; } if (matrix[row][col] \u0026lt; target) { col++; } else { row--; } } return false; } "},{"id":219,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/05/","title":"5th","section":"剑指 Offer","content":" \rLink\n C语言需要注意内存分配，先求出空格数量，在计算出需要的内存大小。\npublic String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s.charAt(i) == \u0026#39; \u0026#39;) { sb.append(\u0026#34;%20\u0026#34;); } else { sb.append(s.charAt(i)); } } return sb.toString(); } "},{"id":220,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/12/","title":"12th","section":"剑指 Offer","content":" \rLink\n public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int idx, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || board[i][j] != word.charAt(idx)) { return false; } if (idx == word.length() - 1) { return true; } board[i][j] = \u0026#39;0\u0026#39;; boolean res = search(board, word, idx + 1, i + 1, j) || search(board, word, idx + 1, i - 1, j) || search(board, word, idx + 1, i, j + 1) || search(board, word, idx + 1, i, j - 1); board[i][j] = word.charAt(idx); return res; } 菜写法，超时\nclass Solution { private int m; private int n; private char[][] board; private String word; private boolean[][] visited; public boolean exist(char[][] board, String word) { this.m = board.length; this.n = board[0].length; this.visited = new boolean[m][n]; this.board = board; this.word = word; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dfs(sb, i, j)) return true; } } return false; } private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; private boolean dfs(StringBuilder cur, int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n) { return false; } if (visited[x][y]) { return false; } cur.append(board[x][y]); visited[x][y] = true; int cmp = cur.length() - word.length(); if (cmp == 0 \u0026amp;\u0026amp; word.equals(cur.toString())) { return true; } else if (cmp \u0026lt; 0) { for (int i = 0; i \u0026lt; 4; i++) { int tmpX = x + dirs[i][0]; int tmpY = y + dirs[i][1]; if (dfs(cur, tmpX, tmpY)) return true; } } visited[x][y] = false; cur.deleteCharAt(cur.length() - 1); return false; } } "},{"id":221,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/13/","title":"13th","section":"剑指 Offer","content":" \rLink\n 简单DFS\nclass Solution { private int m; private int n; private int k; private boolean[][] visited; public int movingCount(int m, int n, int k) { this.m = m; this.k = k; this.n = n; this.visited = new boolean[m][n]; return dfs(0, 0); } private int dfs(int x, int y) { if (x \u0026gt;= m || x \u0026lt; 0 || y \u0026gt;= n || y \u0026lt; 0) return 0; if (visited[x][y] || !isValid(x, y)) { return 0; } visited[x][y] = true; return 1 + dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1); } private boolean isValid(int x, int y) { int val = 0; while (x \u0026gt; 0) { val += (x % 10); x /= 10; } while (y \u0026gt; 0) { val += (y % 10); y /= 10; } return val \u0026lt;= k; } } "},{"id":222,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/15/","title":"15th","section":"剑指 Offer","content":" \rLink\n public int hammingWeight(int n) { int res = 0; while (n != 0) { res += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;\u0026gt;= 1; } return res; } "},{"id":223,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/18/","title":"18th","section":"剑指 Offer","content":" \rLink\n class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { prev.next = cur.next; break; } cur = cur.next; prev = prev.next; } return dummy.next; } } "},{"id":224,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/21/","title":"21st","section":"剑指 Offer","content":" \rLink\n public int[] exchange(int[] nums) { int i = 0, j = nums.length - 1; while (i \u0026lt; j) { if (nums[i] % 2 == 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; j--; } else { i++; } } return nums; } "},{"id":225,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/22/","title":"22nd","section":"剑指 Offer","content":" \rLink\n public ListNode getKthFromEnd(ListNode head, int k) { Stack\u0026lt;ListNode\u0026gt; s = new Stack\u0026lt;\u0026gt;(); while (head != null) { s.push(head); head = head.next; } if (k \u0026gt; s.size()) return null; ListNode res = null; while (k \u0026gt; 0) { k--; res = s.pop(); } return res; } "},{"id":226,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/25/","title":"25th","section":"剑指 Offer","content":" \rLink\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode prev = dummy; ListNode cur1 = l1, cur2 = l2; while (cur1 != null \u0026amp;\u0026amp; cur2 != null) { if (cur1.val \u0026lt; cur2.val) { prev.next = cur1; cur1 = cur1.next; } else { prev.next = cur2; cur2 = cur2.next; } prev = prev.next; } prev.next = (cur1 == null) ? cur2 : cur1; return dummy.next; } "},{"id":227,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/26/","title":"26th","section":"剑指 Offer","content":" \rLink\n class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { if (A == null || B == null) return false; return help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); } private boolean help(TreeNode A, TreeNode B) { if (B == null) return true; else if (A == null || A.val != B.val) return false; return help(A.left, B.left) \u0026amp;\u0026amp; help(A.right, B.right); } } "},{"id":228,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_1/","title":"32 1","section":"剑指 Offer","content":" \rLink\n class Solution { public int[] levelOrder(TreeNode root) { if (root == null) return new int[]{}; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while (!q.isEmpty()) { TreeNode node = q.poll(); tmp.add(node.val); if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } int[] res = new int[tmp.size()]; int idx = 0; for (int val : tmp) { res[idx++] = val; } return res; } } "},{"id":229,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_2/","title":"32 2","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); q.offer(null); // [3, null, 9, 20, null, 15, 7, null]  while (q.peek() != null) { TreeNode node; List\u0026lt;Integer\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(); while ((node = q.poll()) != null) { if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } tmp.add(node.val); } res.add(tmp); q.offer(null); } return res; } } "},{"id":230,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/32_3/","title":"32 3","section":"剑指 Offer","content":" \rLink\n class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); if (root != null) { q.offer(root); } while (!q.isEmpty()) { LinkedList\u0026lt;Integer\u0026gt; tmp = new LinkedList\u0026lt;\u0026gt;(); int n = res.size(); for (int i = q.size(); i \u0026gt; 0; i--) { TreeNode node = q.poll(); if (n % 2 == 0) { tmp.addLast(node.val); } else { tmp.addFirst(node.val); } if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } res.add(tmp); } return res; } } "},{"id":231,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/46/","title":"46th","section":"剑指 Offer","content":" \rLink\n DFS\npublic int translateNum(int num) { return dfs(String.valueOf(num), 0); } private int dfs(String str, int start) { if (start \u0026gt;= str.length()) return 1; int res = 0; int tmp = str.charAt(start) - \u0026#39;0\u0026#39;; if (isValid(tmp)) { res = dfs(str, start + 1); } if (start \u0026lt; str.length() - 1) { // 06  if (tmp == 0) return res; tmp = tmp * 10 + (str.charAt(start + 1) - \u0026#39;0\u0026#39;); if (isValid(tmp)) { res += dfs(str, start + 2); } } return res; } private boolean isValid(int val) { return 0 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25; } 动态规划\npublic int translateNum(int num) { String str = String.valueOf(num); int n = str.length(); // 以i为结尾 不同翻译数  int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1]; int val = (str.charAt(i - 2) - \u0026#39;0\u0026#39;) * 10 + (str.charAt(i - 1) - \u0026#39;0\u0026#39;); if (10 \u0026lt;= val \u0026amp;\u0026amp; val \u0026lt;= 25) { dp[i] = (dp[i - 2] + dp[i - 1]); } } return dp[n]; } "},{"id":232,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/47/","title":"47th","section":"剑指 Offer","content":" \rLink\n class Solution { public int maxValue(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; } } return dp[m][n]; } } "},{"id":233,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/48/","title":"48th","section":"剑指 Offer","content":" \rLink\n 双指针\npublic int lengthOfLongestSubstring(String s) { char[] chs = s.toCharArray(); int res = 0; int i = 0, j = 0; Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (j \u0026lt;= i \u0026amp;\u0026amp; i \u0026lt; chs.length) { if (map.getOrDefault(chs[i], false)) { res = Math.max(res, i - j); map.put(chs[j], false); j++; } else { map.put(chs[i], true); res = Math.max(res, i - j + 1); i++; } } return res; } "},{"id":234,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/50/","title":"50th","section":"剑指 Offer","content":" \rLink\n class Solution { public char firstUniqChar(String s) { Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int[] counts = new int[26]; char[] chs = s.toCharArray(); for (char c : chs) { counts[c - \u0026#39;a\u0026#39;]++; map.put(c, !map.containsKey(c)); } for (char c : chs) { if (map.get(c)) return c; } return \u0026#39; \u0026#39;; } } "},{"id":235,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/54/","title":"54th","section":"剑指 Offer","content":" \rLink\n DFS\nprivate int res, k; public int kthLargest(TreeNode root, int k) { res = 0; this.k = k; dfs(root); return res; } private void dfs(TreeNode node) { if (node == null) return; dfs(node.right); k--; if (k == 0) { res = node.val; return; } dfs(node.left); } Priority Queue + Stack\npublic int kthLargest(TreeNode root, int k) { Queue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (q.size() \u0026lt; k) { q.offer(node.val); } else if (q.peek() \u0026lt; node.val) { q.poll(); q.offer(node.val); } if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } return q.peek(); } "},{"id":236,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_1/","title":"55 1","section":"剑指 Offer","content":" \rLink\n public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } "},{"id":237,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/55_2/","title":"55 2","section":"剑指 Offer","content":" \rLink\n public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(getDepth(root.left) - getDepth(root.right)) \u0026lt; 2 \u0026amp;\u0026amp; (isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right)); } private int getDepth(TreeNode node) { if (node == null) return 0; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; } "},{"id":238,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/57/","title":"57th","section":"剑指 Offer","content":" \rLink\n public int[] twoSum(int[] nums, int target) { int i = 0, j = nums.length - 1; int[] res = new int[2]; while (i \u0026lt; j) { if (nums[i] + nums[j] \u0026lt; target) { i++; } else if (nums[i] + nums[j] \u0026gt; target) { j--; } else { res[0] = nums[i]; res[1] = nums[j]; break; } } return res; } "},{"id":239,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/58/","title":"58th","section":"剑指 Offer","content":" \rLink\n public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); char[] chs = s.toCharArray(); int i = chs.length - 1, j = chs.length - 1; while (i \u0026gt;= 0) { while(i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] != \u0026#39; \u0026#39;) i--; sb.append(s.substring(i + 1, j + 1) + \u0026#34; \u0026#34;); while (i \u0026gt;= 0 \u0026amp;\u0026amp; chs[i] == \u0026#39; \u0026#39;) i--; j = i; } return sb.toString().trim(); } "},{"id":240,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/64/","title":"64th","section":"剑指 Offer","content":" \rLink\n public int sumNums(int n) { boolean tmp = n \u0026gt; 1 \u0026amp;\u0026amp; (n += sumNums(n - 1)) \u0026gt; 0; return n; } "},{"id":241,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_1/","title":"68 1","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } else if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } else { return root; } } "},{"id":242,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/68_2/","title":"68 2","section":"剑指 Offer","content":" \rLink\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root.val == p.val || root.val == q.val) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) { return root; } return left == null ? right : left; } 任意k个数的最近公共祖先\nprivate int k = 2; private TreeNode res; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root, p, q); return res; } private void dfs(TreeNode node, TreeNode p, TreeNode q) { if (node == null) { return; } int oldK = k; if (node.val == p.val || node.val == q.val) { k--; } dfs(node.left, p, q); dfs(node.right, p, q); if (oldK == 2 \u0026amp;\u0026amp; k == 0 \u0026amp;\u0026amp; res == null) { res = node; } } "},{"id":243,"href":"/docs/leetcode/%E5%89%91%E6%8C%87offer/code/a14/","title":"A14","section":"剑指 Offer","content":" \rLink\n 通过二分查找，判断左右区间的个数\nint duplicateInArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 1, r = nums.size() - 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int cnt = 0; for (auto x : nums) { if (x \u0026gt;= l \u0026amp;\u0026amp; x \u0026lt;= mid) { cnt++; } } if (cnt \u0026gt; mid - l + 1) { r = mid; } else { l = mid + 1; } } return l; } "},{"id":244,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"面试题","section":"Leet Code","content":" \r面试题 08.05. 递归乘法(M)  "},{"id":245,"href":"/docs/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/code/0805/","title":"805th","section":"面试题","content":" \rLink\n public int multiply(int A, int B) { if (B == 0) return 0; else if (B == 1) return A; else return A + multiply(A, B - 1); } "},{"id":246,"href":"/docs/tools/","title":"Tools","section":"Docs","content":"工具\r#\r\r \r全网Mac软件收录！还不赶紧搜呀！！！ https://xclient.info/ \r音乐 \r阿虚同学的储物间 \rWindows镜像 \rGithub Wrapped  影视\r#\r\r https://www.btnull.org/mv/  "},{"id":247,"href":"/posts/test/test/","title":"Test","section":"Blog","content":"Test\n"},{"id":248,"href":"/posts/2022/","title":"关于我的2022的一些记录","section":"Blog","content":"收藏的播客\r#\r\r   播客名称 添加日期 type 备注     \rHappy Path Programming 2022.02.19      收藏的博客\r#\r\r   博客名称 添加日期 type 备注     \rcodedump的网络日志 2022.02.17 系统知识 宝藏   \r程序员的喵 2022.02.18 成长    \rRefactoring Guru 2022.03.10 设计模式    \rThe Valuable Dev 2022.03.10     \rDianHsu 2022.03.15 面试    \rROBERT HEATON 2022.03.20      收藏的文章\r#\r\r   文章名称 添加日期 type 备注     - 我在职业生涯中学到的所有良好实践 2022.02.06 技术文章 宝藏   - 聊聊微软面试 2022.02.18 面试 宝藏   - Raft 分布式共识算法动画演示 2022.03.02      "}]